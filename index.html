<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Wilson&#39;s blog | 我的算法竞赛知识</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  
    <link rel="alternate" href="atom.xml" title="Wilson's blog | 我的算法竞赛知识" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="css/style.css">
  
    <link rel="stylesheet" href="fancybox/jquery.fancybox-1.3.4.css">
  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="index.html">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
    <div class="main-nav-space-between"></div>
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
    
  </nav>
</div>
<div id="header-title">
  <h1 id="logo-wrap">
    <a href="index.html" id="logo">Wilson&#39;s blog | 我的算法竞赛知识</a>
  </h1>
  
</div>

      <div id="content" class="outer">
        <section id="main">
  
    <article id="post-复读大三" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="%E5%A4%8D%E8%AF%BB%E5%A4%A7%E4%B8%89/" class="article-date">
  <time class="dt-published" datetime="2022-09-12T15:41:44.000Z" itemprop="datePublished">2022-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="%E5%A4%8D%E8%AF%BB%E5%A4%A7%E4%B8%89/">复读大三</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>开学的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我感到很想完成几门早有耳闻的北美CS课程的实验<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>6.s081<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>MIT操作系统课<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>cs144<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>斯坦福计算机网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>15-213<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>CMU计算机系统结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>6.824<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>MIT分布式系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>构建一个真正 work 的系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时认真把它搞透<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是想到了一个命题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>我大四课这么少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用来复读大三怎么样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>如果大三可以重来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我会做些什么呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>
<h2 id="目标">目标</h2>
<p>考虑到我同时需要科研以及工作效率并不如想象中高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我定下了一个<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>看起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>可行性很高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>实现后也很有收获的目标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>完成 6.s081<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>cs144<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>15-213 三门课程的实验<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>完成质量需要比较高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里提出几点要求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ol>
<li>严格按照要求完成实验<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主要关注分数要求<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>所有通过性测试必须通过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跑分性测试达到较高分数线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>和任务点要求<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如 6.s081 的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>两个功能选择一个实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>不能不选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>清楚明白地了解自己在做什么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不能做完实验还感到有哪里含糊<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>不清楚<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果有疑问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>至少需要具体地列出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并在能力范围内尝试解决</li>
</ol>
<p>更高的要求包括<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>阅读源码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从零复现系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>不做硬性要求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>视前几周的精力情况决定要不要做6.824<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>第二周需要先尝试起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>把 Raft 的论文读起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="计划">计划</h2>
<p>目前的计划<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>每周每门课一个lab<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>除 6.824 外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>第一周已经做完了 cs144 Lab0-2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>6.s081 Lab0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>15-213 bomb lab(4/6)<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>data lab以前做过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不再重做<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>6.828 lab1 是以前做过的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>按照第一周的进度来看<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个计划还是很有希望按期执行的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>不过预测后期难度会增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>尤其是 OS…如果出现这种情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以2周/1.5周一个lab<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>如果计划理想进行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>到了中后期 cs144 就做完了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以投入更多精力做 6.824<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>注意到这里没有编译原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有点尴尬…其实我是很想手搓编译器的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且不想用 yacc/bison<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>除开科研可能需要的编译知识之外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它的优先级可能和分布式系统相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>暂时先不列入计划<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>执行一段时间上面的计划再重新考量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个重新考量不晚于第三周周末<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>本文每周一更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-6-824-Lab1-MapReduce" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="6-824-Lab1-MapReduce/" class="article-date">
  <time class="dt-published" datetime="2022-03-19T16:01:19.000Z" itemprop="datePublished">2022-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="6-824-Lab1-MapReduce/">6.824 Lab1 MapReduce</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>前前后后做了15个小时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>看到<code>PASSED ALL 30 TESTING TRIALS</code>的那一刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>太爽<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span></p>
<h2 id="概述">概述</h2>
<p>这个实验要求实现经典论文MapReduce的模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>MapReduce在Google内部是跑在一个服务器集群里的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这些服务器共享一个分布式文件系统GFS<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个实验只要求实现运行在本机多个进程上的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>本地文件系统上的MapReduce模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>省去了与分布式文件系统的交互<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>要做负载均衡这个很重要<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且应该很麻烦<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="实现过程流水账">实现过程流水账</h2>
<p>先读论文花了3h左右<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>内心活动<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>这论文真简单<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>然后开始实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我并不会go语言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>官网那个tour我也就做了一点点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>事实证明全做完比较省时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>第一次写的代码全是<code>if-else</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我还没有加入容错机制的时候代码已经复杂到我读不懂了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>内心活动<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>工业界实现这玩意的人是神仙吧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span>然后我把3个小时码的200多行代码全都回滚掉了:-(</p>
<p>第二次写代码之前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我决定写一个类似于有限状态自动机的东西<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>事实证明这个模型还不错<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>让我的思路变得比较清晰<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且便于拓展<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后花了2h画图+搭框架<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是只写了一堆<code>switch-case</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每种状态对应的转移和转移前需要进行的操作<em>的注释</em><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后就头晕<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>下班了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>今天是第三次碰这个东西<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>今天如果再自闭我可能就要对这实验产生心理阴影了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>好在我上次的DFA没啥大问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只是有些corner case没想到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>缝缝补补搞了一段时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>终于把注释转换成了代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最戏剧性的一刻来了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>开码10小时后我终于进行了第一次编译<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span>我以为会得到巨长无比的报错<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结果报错就八九行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后就是改完一行错再出现一行错<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>改完<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>最后一行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>错之后又蹦出来十几个错误<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>改了若干年……通过编译之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他在起始状态就出错了……然后又改了若干年<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>终于输出了结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p>第一个教训<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>把语言学明白<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>勤编译勤测试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>我查看输出文件的前三行<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>共两万行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现与标准输出一样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span>然后高兴地去跑测试脚本<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结果第一个正确性测试点就挂了……</p>
<blockquote>
<p>第二个教训<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>测试要认真严谨<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>然后又改了若干年<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>期间多次翻阅论文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现人家写进论文的东西都是经过取舍和迭代的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还是非常精华的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>后来就是无限改bug<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>调试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>按下不表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>终于在今天码代码的第8小时通过了所有测试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span></p>
<h3 id="做的不错的地方">做的不错的地方</h3>
<ol>
<li>画DFA</li>
<li>头脑不清楚的时候出门转转<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以花掉长达20分钟的时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是回来之后你就复活了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span></li>
</ol>
<h3 id="想要做得更好的地方">想要做得更好的地方</h3>
<ol>
<li>阶段性编译<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>测试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>例如我的DFA设计好了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这时候就可以测试下转移有没有问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后再在转移前后加功能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>有设计测试点的能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于这个实验<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我是用户<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且一定程度上可以说是赶时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以用老师的脚本来测试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>调试没有什么错<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是一旦成为真正意义上的开发者<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>bug都要自己找<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>不提开源社区之类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要有能力设计若干测试来检验自己的代码在各方面的正确性/性能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这确实需要写一些<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>没用的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是它们通常很简单<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且很有用<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如算法竞赛里的对拍程序和暴力程序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>例如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我尽管知道各个操作的时间/空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但还是不知道我这个实现并发性如何<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>究竟有多少CPU时间是overhead<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>证明我的DFA的正确性</li>
<li>Challenge</li>
<li>阅读老师的测试脚本<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>学习写脚本</li>
</ol>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/distributed-system/" rel="tag">distributed system</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/lab/" rel="tag">lab</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/system/" rel="tag">system</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CF-Edu123-题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="CF-Edu123-%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-03-07T13:47:25.000Z" itemprop="datePublished">2022-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/%E9%A2%98%E8%A7%A3/">题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="CF-Edu123-%E9%A2%98%E8%A7%A3/">CF Edu123 题解</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="f-basis">F. Basis</h2>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1644/problem/F">题面</a></p>
<p>考虑一群在操作 2 下可以互相变换的数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在其中可以取一个代表元<span class="markdown-them-math-inline">$arr$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假设<span class="markdown-them-math-inline">$arr$</span>由<span class="markdown-them-math-inline">$i$</span>种数字组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>把<span class="markdown-them-math-inline">$arr$</span>中数字<span class="markdown-them-math-inline">$j$</span>所在的下标的集合记作<span class="markdown-them-math-inline">$S_j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则这一群数组可以用集合的集合<span class="markdown-them-math-inline">$\{S_1,S_2,...,S_i\}$</span>来表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>称为一个<em>原型</em><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果只能做操作2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>答案就是第二类斯特林数<span class="markdown-them-math-inline">$\left\{n\atop i\right\}$</span>的前缀和<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>对<span class="markdown-them-math-inline">$i$</span>从1加到<span class="markdown-them-math-inline">$\min(k,n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>出于后面的实现方便<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将对<span class="markdown-them-math-inline">$i$</span>从2加到<span class="markdown-them-math-inline">$\min(k,n)$</span>的前缀和记作<span class="markdown-them-math-inline">$A(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这可以用<span class="markdown-them-math-inline">$O(n\log n)$</span>的复杂度来求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具体见<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/combinatorics/stirling/#_3">oi-wiki</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>接下来考虑操作1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们发现刚才找到的那些代表元当中有些可以经操作1生成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现在来删除它们<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>将原型<span class="markdown-them-math-inline">$arr$</span>改写成<em>连续的相同数个数的数组</em>的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记作<span class="markdown-them-math-inline">$arr'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如将<span class="markdown-them-math-inline">$1,1,2,2,3$</span>改写成<span class="markdown-them-math-inline">$2,2,1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ol>
<li>如果<span class="markdown-them-math-inline">$arr'$</span>只有一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是说<span class="markdown-them-math-inline">$arr$</span>中全都是相同的数字<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们发现<span class="markdown-them-math-inline">$arr$</span>一定可以由某个<em>改写前有至少两个不同数的原型</em>经一次操作1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$F(a, n)$</span>生成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是不用对<span class="markdown-them-math-inline">$arr$</span>计数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>也就是说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>题目中给的<span class="markdown-them-math-inline">$k&gt;1$</span>时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不用考虑这种情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果<span class="markdown-them-math-inline">$k=1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>输出1即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>如果<span class="markdown-them-math-inline">$arr'$</span>不只有一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>去掉<span class="markdown-them-math-inline">$arr'$</span>的最后一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考察前面的那些数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果它们的<span class="markdown-them-math-inline">$gcd$</span>不为1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则<span class="markdown-them-math-inline">$arr$</span>可以被别的原型由操作1生成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不用对<span class="markdown-them-math-inline">$arr$</span>计数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对一个<span class="markdown-them-math-inline">$gcd$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有<span class="markdown-them-math-inline">$A(\lceil {n\over gcd}\rceil)$</span>个原型可以被别的原型<span class="markdown-them-math-inline">$a$</span>生成<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>将<span class="markdown-them-math-inline">$arr$</span>中每连续<span class="markdown-them-math-inline">$gcd$</span>个数绑定<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再计算原型数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是<span class="markdown-them-math-inline">$A(\lceil {n\over gcd}\rceil)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>注意<span class="markdown-them-math-inline">$A$</span>是从2开始加的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为数字全部相同的原型并不能由操作1生成<span class="markdown-them-math-inline">$arr$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果这个<span class="markdown-them-math-inline">$gcd$</span>是合数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可能这些冗余数组会被它的因子删除多次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要控制这个次数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解决方法是用mobius函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>就是说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对<span class="markdown-them-math-inline">$gcd$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们计<span class="markdown-them-math-inline">$\mu(gcd)$</span>次<span class="markdown-them-math-inline">$A(\lceil {n\over gcd}\rceil)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ol>
<p>这里的mobius函数就是在对<span class="markdown-them-math-inline">$gcd$</span>的质因子集合<span class="markdown-them-math-inline">$S$</span>做容斥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>质因子集合<span class="markdown-them-math-inline">$S$</span>的子集<span class="markdown-them-math-inline">$S'\subset S$</span>可以与那些<em>各质因子至多出现一次的<span class="markdown-them-math-inline">$gcd$</span>的因子</em>建立一一映射<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个子集中有奇数个因子就取<span class="markdown-them-math-inline">$-1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>偶数个因子就取<span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有质因子出现2次就取0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>子集为空集时<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>对应于因子1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>也取1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>对一个给定的<span class="markdown-them-math-inline">$gcd$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那些能经操作1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$F(a, gcd)$</span>生成的原型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可以被<span class="markdown-them-math-inline">$gcd$</span>的因子<span class="markdown-them-math-inline">$d$</span>们经操作1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$F(F(a,d), gcd/d)$</span>生成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每个这样的原型被计了多少次呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>答案是</p>
<div class="markdown-them-math-block">$$\sum_{d|gcd}\mu(d)=\sum_{S'\subset S}(-1)^{|S'|}=\sum_{i=0}^{|S|}\binom{|S|}{i}(-1)^{i}\times 1^{|S|-i}=(-1+1)^{|S|}=[gcd=1]
$$</div><p>也就是实现了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若<span class="markdown-them-math-inline">$arr'$</span>除去最后一块外的所有数互质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$arr$</span>就属于<strong>基</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则不属于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这结束了我们的讨论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>关于<span class="markdown-them-math-inline">$0^0$</span>不等式和<span class="markdown-them-math-inline">$[gcd=1]$</span>的讨论可以和<a href="/Trie%E6%A0%91%E7%BB%B4%E6%8A%A4%E9%9B%86%E5%90%88%E7%9B%B8%E4%BA%A4%E6%80%A7/" title="Trie树维护集合相交性">Trie树维护集合相交性</a>相类比<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>最后的答案是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\sum_{gcd=1}^n\mu(gcd)A\left(\left\lceil\dfrac{n}{gcd}\right\rceil\right)
$$</div><p>直接整除分块求这个东西的一个上界是</p>
<div class="markdown-them-math-block">$$O(\sum_{gcd=1}^n\dfrac{n\log n}{gcd})=O(n\log n\sum_{d=1}^n\dfrac{1}{d})=O(n\log^2 n)
$$</div><p>注意不是<span class="markdown-them-math-inline">$O(n\sqrt{n}\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们还可以合并同一个<span class="markdown-them-math-inline">$\left\lceil\dfrac{n}{gcd}\right\rceil$</span>对应的所有<span class="markdown-them-math-inline">$\mu(gcd)$</span>之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>前缀和或者开桶统计一下就行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于后面那个求和只有其中的<span class="markdown-them-math-inline">$\sqrt{n}$</span>项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可能还达不到<span class="markdown-them-math-inline">$\log n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以理解为常数很小的<span class="markdown-them-math-inline">$\log n$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>经测试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对<span class="markdown-them-math-inline">$n=10^5$</span>该和为6.83<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" rel="tag">容斥原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/" rel="tag">斯特林数</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Trie树维护集合相交性" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="Trie%E6%A0%91%E7%BB%B4%E6%8A%A4%E9%9B%86%E5%90%88%E7%9B%B8%E4%BA%A4%E6%80%A7/" class="article-date">
  <time class="dt-published" datetime="2022-03-03T09:40:59.181Z" itemprop="datePublished">2022-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/">奇技淫巧</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="Trie%E6%A0%91%E7%BB%B4%E6%8A%A4%E9%9B%86%E5%90%88%E7%9B%B8%E4%BA%A4%E6%80%A7/">Trie树维护集合相交性</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这篇文章讲一个 trick<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他可以解决如下问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<blockquote>
<p>维护一个结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以添加和删除集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对询问中给定的新集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结构中有多少集合与之不交<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>
</blockquote>
<p>用这个 trick<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以在 <span class="markdown-them-math-inline">$O(2^{|S|})$</span> 的时间复杂度内添加或询问一个集合 <span class="markdown-them-math-inline">$S$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以在多个小集合的时候比较有用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>对两个集合 <span class="markdown-them-math-inline">$A$</span> 和 <span class="markdown-them-math-inline">$B$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑 <span class="markdown-them-math-inline">$B$</span> 的所有子集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>维护一个计数器 <span class="markdown-them-math-inline">$cnt$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对每个子集 <span class="markdown-them-math-inline">$S$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果它也是 <span class="markdown-them-math-inline">$A$</span> 的子集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为 <span class="markdown-them-math-inline">$cnt$</span> 加上 <span class="markdown-them-math-inline">$(-1)^{|S|}$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$cnt=\sum_{S\subset (A\cap B)}(-1)^{|S|}=\sum_{i=0}^{|S|}\binom{|S|}{i}(-1)^i\times 1^{|S|-i}=(1-1)^{|S|}
$$</div><p><span class="markdown-them-math-inline">$A\cap B=\emptyset$</span> 时形式上是<span class="markdown-them-math-inline">$0^0$</span>不定式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>根据定义式计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现它有由空集贡献的 1 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是 <span class="markdown-them-math-inline">$cnt$</span> 就标志着 <span class="markdown-them-math-inline">$A\cap B$</span> 是否为空<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>为空时 <span class="markdown-them-math-inline">$cnt=1$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则 <span class="markdown-them-math-inline">$cnt=0$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>现在我们维护一个 Trie 树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个节点代表一个集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当添加集合 <span class="markdown-them-math-inline">$A$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>给它的所有子集对应的节点权值加一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>删除时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就为所有子集对应的节点权值减一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以注意到空集对应节点的权值就代表当前结构中维护的集合个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>然后考虑询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>设在询问 <span class="markdown-them-math-inline">$S$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对所有 <span class="markdown-them-math-inline">$S'\subset S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果 Trie 树中有对应 <span class="markdown-them-math-inline">$S'$</span> 的节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就为计数器加上 <span class="markdown-them-math-inline">$(-1)^{|S'|}\times tr ie[S']$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对结构中维护的每个集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若它和 <span class="markdown-them-math-inline">$S$</span> 不交<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它对计数器的贡献就是 1 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则是 0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是计数器的值就代表了结构中与 <span class="markdown-them-math-inline">$S$</span> 不交的集合个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ARC136题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="ARC136%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-03-01T13:17:35.000Z" itemprop="datePublished">2022-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="ARC136%E9%A2%98%E8%A7%A3/">ARC136题解</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这场 ARC 比较考验观察能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是找到切入点的能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我会尽量在题解里给出一个观察的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>至于证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比猜到结论简单<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这场暴露出来我的容易进死胡同的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可能是人类本质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>就是一种思路做不出来的时候跳不出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>思维僵化了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>以后训练中得注意对想不出来的题尝试<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>跳出思维定势<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>也可能只是 trick 掌握得不够<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>导致跳出来也不知道想啥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以先多积累些思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>毕竟<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>思而不学则殆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="c-- circular addition">C - Circular Addition</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc136/tasks/arc136_c">题面</a></p>
<p>收获的思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ol>
<li>在差分数组上看区间加减</li>
<li>问最小操作次数时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>找几个下界<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>尝试证明其最大值可以取到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>证明时可以尝试把创造过程逆转为消除过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为消除时的信息更多<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而创造是在<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>创造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ol>
<p>我看到了第一个切入点<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>用差分数组处理区间加减问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果您对这个题毫无头绪<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以先对着这句话看自己能想到哪一步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>将目标数组看作环并作长为 <span class="markdown-them-math-inline">$n$</span> 的差分数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现这个差分数组和一定为 0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且每次操作一定是使得一个数 +1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个数 -1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>显然我们可以通过每次选择一正一负的一对位置操作来得到目标差分数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>操作次数为<em>差分数组中正值之和</em><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>然后我发现过不了最后一个样例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仔细一看发现其实也没能给出前两个样例的具体操作步骤<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不太对劲<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是可以交换差分数组上的操作顺序来获得额外的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>全体 +1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span> buff<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个信息在差分数组里被丢掉了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>从这时开始<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我就开始想着怎么最大化这个 buff<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及是不是最大 buff 和零 buff 之间的所有值都能取到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>陷入了苦战<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>按照题解来讲的话<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们已经观察到了一个操作次数下界<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还有另一个显然的下界<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是数组中的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们猜想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>他们中的最大值是可以被取到的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后反过来想将目标数组变为 0 的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们发现这个思路在近达上一场比赛 ARC135D 中就出现过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要学习一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>实际应用中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种猜想很可能会错<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>尤其是难题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>所以姑且提出一个做题步骤<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ol>
<li>观察总结此前得到的事实<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>提出猜想</li>
<li>代入样例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若有误返回1</li>
<li>尝试证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若证伪返回1</li>
<li>如果证明或不会证而自信<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>开码</li>
<li>如果没证出来且不太自信<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>多造点样例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再次手玩或对拍<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若有误返回1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则开码</li>
</ol>
<p>按照步骤<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们应当代入样例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>发现没问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>开始尝试证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果我们在每一时刻都能降低<strong>这一时刻的</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>差分数组下界<span class="markdown-them-math-inline">$L_1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>和<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>最大值下界<span class="markdown-them-math-inline">$L_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>中的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就构造性地证明了猜想的正确性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>为了降低最大者<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们需要对<span class="markdown-them-math-inline">$L_1$</span>和<span class="markdown-them-math-inline">$L_2$</span>的大小做出假设来进行进一步推理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ol>
<li><span class="markdown-them-math-inline">$L_1&lt;L_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>此时数组中不可能有 0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则为了从 0 增加到 <span class="markdown-them-math-inline">$L_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>差分数组中正值部分至少是 <span class="markdown-them-math-inline">$L_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这与 <span class="markdown-them-math-inline">$L_1&lt;L_2$</span> 矛盾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是全体 -1 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样能使 <span class="markdown-them-math-inline">$L_2$</span> 减小 1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li><span class="markdown-them-math-inline">$L_1&gt;L_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>如果数组中有 0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们只要挑选一段包含最大值的极大非零区间来全体 -1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样能使 <span class="markdown-them-math-inline">$L_1$</span> 减小 1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果数组中没有 0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数组中一定有若干<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>山谷<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以一定可以找一段极大的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>连续最大值区间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>要求其左右不再是最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>来减 1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这能使 <span class="markdown-them-math-inline">$L_1$</span> 减小 1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li><span class="markdown-them-math-inline">$L_1=L_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>如果数组中有 0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一定是单调增加到 <span class="markdown-them-math-inline">$L_2$</span> 再单调减小到 0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将非零部分 -1 即可同时减小 <span class="markdown-them-math-inline">$L_1$</span> 和 <span class="markdown-them-math-inline">$L_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果数组中没有0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数组中一定有若干<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>山谷<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果*极大的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>连续最大值区间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>*唯一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么将其减 1 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>否则<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一定可以找到一个区间覆盖所有的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如除去最小值后获得的区间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>将这个区间全体减 1 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ol>
<p>把这个过程反过来想会变得更难想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>尤其是 <span class="markdown-them-math-inline">$L_1=L_2$</span> 时的操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>所以这个<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>减小双下限最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>的 trick 应该被加入知识库<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="d-- without carry">D - Without Carry</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc136/tasks/arc136_d">题面</a></p>
<p>收获<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>SOSdp</p>
<p>推荐博文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/45223">SOSdp</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/72488">zeta transform</a> 前者为后者前置知识<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>本题只需要学习前者<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是来都来了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为什么不都学一下呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>
<p>读完博文直接就会做了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不会就看官方题解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不必多说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="e-- non-coprime dag">E - Non-coprime DAG</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc136/tasks/arc136_e">题面</a></p>
<p>收获<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><s>我观察能力低下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></s></p>
<ol>
<li>不够耐心<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一条思路还没想透彻就放弃</li>
<li>可以把结论写出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更容易发现规律<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>形式的不同会影响思考方式</li>
</ol>
<p>在看题解之前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>您至少应该发现<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>不可达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>和<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>互质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>并不等价<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如9可以经12和14到达35<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>并且经过了一定的思考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>对 <span class="markdown-them-math-inline">$i&lt;j$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考察 <span class="markdown-them-math-inline">$i$</span> 是否可达 <span class="markdown-them-math-inline">$j$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>后文同余符号皆模 2 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$f(i)$</span> 为 <span class="markdown-them-math-inline">$i$</span> 的最小质因子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ol>
<li><span class="markdown-them-math-inline">$i\equiv 0,\;j\equiv 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时一定可达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li><span class="markdown-them-math-inline">$i\equiv 0,\;j\equiv 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时来到了第一个重要观察<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>可以尝试经过 <span class="markdown-them-math-inline">$j - f(j)$</span> 这一偶数到达 <span class="markdown-them-math-inline">$j$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以不超过 <span class="markdown-them-math-inline">$j-f(j)$</span> 的偶数都 ok <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即要求<span class="markdown-them-math-inline">$i\leq j-f(j)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而比它大的偶数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>和 <span class="markdown-them-math-inline">$j$</span> 的差距已经小于其最小质因子了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>没有机会走到 <span class="markdown-them-math-inline">$j$</span> 了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li><span class="markdown-them-math-inline">$i\equiv 1,\;j\equiv 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>类似于 2 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要求<span class="markdown-them-math-inline">$i+f(i)\leq j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li><span class="markdown-them-math-inline">$i\equiv 1,\; j\equiv 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时来到了第二个重要观察<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也是我卡住的地方<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于我没有将上面的观察列出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我并没有注意经过偶数到达奇数这条路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或者隐约觉得这效率低下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>其实这个类比还是比较明显的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大脑好用时起码可以猜一个结论出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>先写结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$i+f(i)\leq j-f(j)$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>首先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>两者都是奇数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就决定了只加一个<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>一定为奇的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>质因数并不能使 <span class="markdown-them-math-inline">$i$</span> 到达 <span class="markdown-them-math-inline">$j$</span>  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>至少要加 2 个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果想由偶数搭桥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然<code>i -&gt; i+f(i) -&gt; j-f(j) -&gt; j</code>的路径就是最优的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果不这样做<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么 <span class="markdown-them-math-inline">$i,j$</span> 有公因子<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>此时 <span class="markdown-them-math-inline">$i+f(i)\leq j-f(j)$</span> 必成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或者仍然可以理解为从偶数搭桥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么还是需要转到 <span class="markdown-them-math-inline">$j-fac(j)$</span> 再转到 <span class="markdown-them-math-inline">$j$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$fac(j)$</span> 是 <span class="markdown-them-math-inline">$j$</span> 的某个因子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而这一个转变最少也要加 <span class="markdown-them-math-inline">$f(i)$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转变后最少也要再加 <span class="markdown-them-math-inline">$f(j)$</span> 到达 <span class="markdown-them-math-inline">$j$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>本质还是从偶数搭桥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ol>
<p>现在我们获得了<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>可达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>的数学表达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我又卡在这里了<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>我去想 DAG 了并且没跳出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>悲<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>注意到不等号左右的内容都很相似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且右侧可以加1<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>因为模2的限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>两式仍然等价<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>尝试总结为一个式子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以将不等式变形为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ol>
<li><span class="markdown-them-math-inline">$i+1\leq j$</span></li>
<li><span class="markdown-them-math-inline">$i+1\leq j-f(j)+1$</span></li>
<li><span class="markdown-them-math-inline">$i+f(i)\leq j$</span></li>
<li><span class="markdown-them-math-inline">$i+f(i)\leq j-f(j)+1$</span></li>
</ol>
<p>可以总结为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$i$</span> 可达 <span class="markdown-them-math-inline">$j$</span> <span class="markdown-them-math-inline">$\Leftrightarrow$</span> <span class="markdown-them-math-inline">$up(i)\leq low(j)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$up(i)=(i\equiv0)?i+1:i+f(i)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>注意这个 <span class="markdown-them-math-inline">$+1$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是因为 <span class="markdown-them-math-inline">$i&lt;j$</span> 不带等号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span><span class="markdown-them-math-inline">$low(j)=(j\equiv0)?j:j-f(j)+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>再次总结这个表达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对任意的 <span class="markdown-them-math-inline">$i, j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当且仅当 <span class="markdown-them-math-inline">$up(i)\leq low(j)$</span> 或 <span class="markdown-them-math-inline">$up(j)\leq low(i)$</span> 时他们之间可达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用区间语言表达就更干净<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$[low(i), up(i))$</span> 与 <span class="markdown-them-math-inline">$[low(j),up(j))$</span> 没有交点时可达<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>注意区间开闭<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是题目变成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>寻找有公共交点的区间族 <span class="markdown-them-math-inline">$\{[low(i), up(i))\mid i\in\mathbb{N}\}$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使得 <span class="markdown-them-math-inline">$\sum_{i}A_i$</span>最大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>随便做<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E9%A2%98%E8%A7%A3/" rel="tag">题解</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ARC135题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="ARC135%E9%A2%98%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-02-14T14:27:52.000Z" itemprop="datePublished">2022-02-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="ARC135%E9%A2%98%E8%A7%A3/">ARC135题解</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>F暂时有个地方没搞明白<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但我会研究题解和正确代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>把它搞会<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="c-- xor to all">C - XOR to All</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc135/tasks/arc135_c">题面</a></p>
<p>关键在于发现若干次操作一定可以等价于一次操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>假设进行了多次操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考察前两次操作<span class="markdown-them-math-inline">$B_0$</span>和<span class="markdown-them-math-inline">$B_1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$B_0$</span>一定是原数组中的一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而<span class="markdown-them-math-inline">$B_1$</span>一定是原数组中的某个数<span class="markdown-them-math-inline">$A$</span>与<span class="markdown-them-math-inline">$B_0$</span>的异或和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为<span class="markdown-them-math-inline">$B_1$</span>取自被<span class="markdown-them-math-inline">$B_0$</span>更新过的数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们发现<span class="markdown-them-math-inline">$B_0,B_1$</span>两次操作的结果等价于直接用<span class="markdown-them-math-inline">$A$</span>进行一次操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>现在操作次数减少了1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以一直使用这个方法直到将多次操作等价为一次操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>现在只需要比较选择每个数对数组元素之和的影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这可以按位统计做到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对每一位<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>最多30位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>统计有多少个数在这一位是1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后选择<span class="markdown-them-math-inline">$A_i$</span>对和的影响就是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$A_i$</span>会对数组中所有的数翻转<span class="markdown-them-math-inline">$A_i$</span>中为1的那些位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>翻转的贡献可以由统计的数据计算出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="e-- sequence of multiples">E - Sequence of Multiples</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc135/tasks/arc135_e">题面</a></p>
<p>赛后自己做出来了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>很高兴<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>下面记题目描述的数列本身为<span class="markdown-them-math-inline">$A_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而不论怎样得到它<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="初见端倪的朴素算法">初见端倪的朴素算法</h3>
<p>观察一个特殊的例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$X=1,N=1e18$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时数列就是<span class="markdown-them-math-inline">$1$</span>到<span class="markdown-them-math-inline">$n$</span>本身<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span>然后考察<span class="markdown-them-math-inline">$X=2,N=1e18$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现数列是<span class="markdown-them-math-inline">$\{2n\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>继续观察<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>会总结出一个规律<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>无论<span class="markdown-them-math-inline">$X$</span>如何<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当<span class="markdown-them-math-inline">$n$</span>充分大时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数列会变成<span class="markdown-them-math-inline">$\{kn\}$</span>的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$k$</span>为常数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>假设第<span class="markdown-them-math-inline">$n$</span>项是<span class="markdown-them-math-inline">$kn$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么第<span class="markdown-them-math-inline">$n+1$</span>项的一个上界是<span class="markdown-them-math-inline">$k(n+1)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这比前一项大了<span class="markdown-them-math-inline">$k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只要<span class="markdown-them-math-inline">$k\leq n+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个上界就会被取到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为更小的<span class="markdown-them-math-inline">$n+1$</span>的倍数已经小于第<span class="markdown-them-math-inline">$n$</span>项了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这不符合题目要求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>于是我们发现这个<span class="markdown-them-math-inline">$k$</span>的变化趋势是很重要的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果我们能搞清楚什么时候<span class="markdown-them-math-inline">$k\leq n+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这之后的内容就可以<span class="markdown-them-math-inline">$O(1)$</span>计算了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>为了研究它<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>构造新的数组<span class="markdown-them-math-inline">$\{B_n\}:B_i=A_i/i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>在特殊例子上构造<span class="markdown-them-math-inline">$\{B_n\}$</span>会给我们一些最基本的认识<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$\{B_n\}$</span>是不增的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>前面的证明过程稍加修改就能证明这个结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>实际上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们感到它以类似于反比函数的速度减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>为了解出<span class="markdown-them-math-inline">$B_i\leq i+1$</span>的时刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们研究<span class="markdown-them-math-inline">$B_i$</span>的变化趋势<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而这可以其定义中的<span class="markdown-them-math-inline">$A_i$</span>入手<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考察<span class="markdown-them-math-inline">$A_i$</span>的变化趋势<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们发现<span class="markdown-them-math-inline">$A_{i+1}-A_i\leq i+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则<span class="markdown-them-math-inline">$A_{i+1}$</span>会被<span class="markdown-them-math-inline">$A_{i+1}-(i+1)$</span>取代<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是<span class="markdown-them-math-inline">$A_i$</span>大致以<span class="markdown-them-math-inline">$O(n^2)$</span>的速度增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$A_i-A_1\leq(\sum_{k=2}^{i} k)=(i+2)(i-1)/2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>得到了<span class="markdown-them-math-inline">$\{A_i\}$</span>的变化趋势<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>两侧同时除以<span class="markdown-them-math-inline">$i$</span>即可得到<span class="markdown-them-math-inline">$\{B_i\}$</span>的变化趋势上界<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$B_i-\frac{X}{i}\leq \frac{(i+2)(i-1)}{2i}\leq i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$B_i\leq \frac{X}{i}+i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个上界是有极小值的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但我们知道<span class="markdown-them-math-inline">$B_i$</span>不增<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以我们可以先增加<span class="markdown-them-math-inline">$i$</span>得到极小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后等待<span class="markdown-them-math-inline">$i+1$</span>追上这个极小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>显然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个极小值在<span class="markdown-them-math-inline">$i=\sqrt{X}$</span>附近取到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而<span class="markdown-them-math-inline">$i=2\sqrt{X}$</span>时就一定有<span class="markdown-them-math-inline">$B_i\leq i+1$</span>了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是我们证明了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果我们暴力计算<span class="markdown-them-math-inline">$\{A_i\}$</span>直到<span class="markdown-them-math-inline">$B_i\leq i+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度是<span class="markdown-them-math-inline">$O(\sqrt{X})$</span>的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>尽管我们没有证明其下界<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但这个算法实际效率也不够高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对<code>1e18 1e18</code>的输入需要计算20秒<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>10组就是200秒<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>远不是常数问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="正解">正解</h3>
<p><span class="markdown-them-math-inline">$B_i$</span>有一个类似于反比函数的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一开始快速下降<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后缓慢下降<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后不变的变化过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对反比函数的取整求和有整除分块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对<span class="markdown-them-math-inline">$B_i$</span>能不能也找到某种分块来合并一些计算呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E9%A2%98%E8%A7%A3/" rel="tag">题解</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-在Linux上使用clash" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="%E5%9C%A8Linux%E4%B8%8A%E4%BD%BF%E7%94%A8clash/" class="article-date">
  <time class="dt-published" datetime="2022-01-21T03:31:11.000Z" itemprop="datePublished">2022-01-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="%E5%9C%A8Linux%E4%B8%8A%E4%BD%BF%E7%94%A8clash/">在Linux上使用clash</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>我火星了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有现成的GUI…请使用<a target="_blank" rel="noopener" href="https://github.com/Fndroid/clash_for_windows_pkg/releases">Clash for Windows</a>的Linux版本<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ol>
<li>在<a target="_blank" rel="noopener" href="https://github.com/Fndroid/clash_for_windows_pkg/releases">release页面</a>下载<code> Clash.for.Windows-0.x.x-x64-linux.tar.gz</code></li>
<li>解压后执行<code>./cfw</code></li>
<li>为了脱离命令行运行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请看<a target="_blank" rel="noopener" href="https://github.com/Fndroid/clash_for_windows_pkg/issues/2107">issue</a></li>
</ol>
<hr>
<p>以下为原文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>以<a target="_blank" rel="noopener" href="https://panel.touhou.tel/auth/register?code=jXeZ">东方网络</a>为例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>按照机场默认的配置使用clash<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果不够满意<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>大概率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>参考<a target="_blank" rel="noopener" href="https://clash.gitbook.io/doc/restful-api">API文档</a>再稍微写一些代码就可以进行规则与节点的配置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>待更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="步骤">步骤</h2>
<ol>
<li>在<a target="_blank" rel="noopener" href="https://github.com/Dreamacro/clash/releases/">releases</a>页面中下载最新版clash内核<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一般的64位机器下载amd64版本即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>解压后为一个可执行文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>重命名为<code>clash</code>后执行<code>chmod +x clash</code>为其加上执行权限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>在机场网站上下载配置文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>命名为<code>config.yaml</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>执行<code>./clash -t -f config.yaml</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果没有问题说明配置文件正确<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>执行<code>./clash -f config.yaml</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>开启代理服务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>配置系统代理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>选择&quot;use manually specified proxy configuration&quot;<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>填入代理日志显示的代理地址+端口号</li>
<li>配置浏览器使用系统代理/配置浏览器代理指向clash<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>现在应该已经可以访问google了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果不行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>检查配置文件的mode<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果是direct<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>改成rule或者global<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>按照<a target="_blank" rel="noopener" href="https://github.com/Dreamacro/clash/wiki/clash-as-a-daemon">官方wiki</a>的步骤将其配置为守护进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ol>
<p>这样就足以支持日常需求了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-页面调度算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2022-01-07T04:31:38.000Z" itemprop="datePublished">2022-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/">页面调度算法</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="最优调度算法为什么最优">最优调度算法为什么最优</h2>
<p>我们发现换页时换入的页总是固定的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们要挑选的是换出的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>优先换出不再被访问的页面是显然的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>首先注意换出的页面在下次访问时是一定会被换入的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只要考虑没被换出的页面有没有离开即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果不用最优调度算法换出A<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而换出一个下次访问更早的页面B<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>如果A在下次访问A前未被调出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么换出A仍能使得下次访问B前B未被调出</li>
<li>如果A在下次访问A前被调出了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么换出A有可能可以使得B不用被调出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为B的下次访问更早</li>
</ul>
<p>于是换出A一定不比换出B差<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无论换出B后采用什么策略<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="堆栈式算法">堆栈式算法</h2>
<p>堆栈式算法是指<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>访问第<span class="markdown-them-math-inline">$t$</span>个页面时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑驻留集大小为<span class="markdown-them-math-inline">$n$</span>时的驻留集<span class="markdown-them-math-inline">$S$</span>和驻留集大小为<span class="markdown-them-math-inline">$n+1$</span>时的驻留集<span class="markdown-them-math-inline">$S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果可以证明在某种调度算法下无论对什么输入下的哪个<span class="markdown-them-math-inline">$t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都有<span class="markdown-them-math-inline">$S\subset S'$</span>成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么这个调度算法就是堆栈式算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="堆栈式算法的好处">堆栈式算法的好处</h3>
<p>这种算法没有Belady现象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>页框增加时缺页中断次数不会增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>页框增加时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于任何时刻<span class="markdown-them-math-inline">$S\subset S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$P\notin S'\Rightarrow P\notin S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即<em>某页在页框多时缺页</em><span class="markdown-them-math-inline">$\Rightarrow$</span><em>该页在页框少时也缺页</em><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>缺页中断次数不会更少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="最优调度算法/lru为什么是堆栈式算法">最优调度算法/LRU为什么是堆栈式算法</h3>
<p>用数学归纳法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>初始时<span class="markdown-them-math-inline">$S=S'=\emptyset$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>假设对某个访问序列满足<span class="markdown-them-math-inline">$S\subset S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现在再访问一页<span class="markdown-them-math-inline">$P$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>若<span class="markdown-them-math-inline">$P\notin S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$P\notin S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时产生缺页中断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设在<span class="markdown-them-math-inline">$S$</span>中换出页<span class="markdown-them-math-inline">$P_1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$S'$</span>中换出<span class="markdown-them-math-inline">$P_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对OPT/LRU中的每一种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么<span class="markdown-them-math-inline">$P_2\in S'-S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么<span class="markdown-them-math-inline">$P_1=P_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无论哪种情形<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>换出页后仍满足<span class="markdown-them-math-inline">$S\subset S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>综上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对任意输入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这两种算法都是堆栈式算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这个证明的核心在于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>要么<span class="markdown-them-math-inline">$P_2\in S'-S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么<span class="markdown-them-math-inline">$P_1=P_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>看到网上的一个理解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>说是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>给驻留集里的页面一个与<span class="markdown-them-math-inline">$n$</span>无关的优先级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>选择优先级最高的那个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是不会选择<span class="markdown-them-math-inline">$S-\{P_1\}$</span>中的元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对FIFO算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个优先级是进入时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后我们会发现这个东西不完全取决于驻留集这个集合本身<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还取决于它进入驻留集的时刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>有可能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>驻留集小时的缺页导致一个页面换出后再次换入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但驻留集大时则总是驻留<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而它在驻留集小时优先级低而驻留集大时优先级高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时有可能<span class="markdown-them-math-inline">$P_2$</span>是那个<span class="markdown-them-math-inline">$S'$</span>中总是驻留的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而<span class="markdown-them-math-inline">$P_1$</span>是其他的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是这个<span class="markdown-them-math-inline">$P_2$</span>现在仍在<span class="markdown-them-math-inline">$S$</span>中而不在<span class="markdown-them-math-inline">$S'$</span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-二分图匹配" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/" class="article-date">
  <time class="dt-published" datetime="2021-10-30T15:37:16.000Z" itemprop="datePublished">2021-10-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/">二分图匹配</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>先通过交错路和增广路的概念建立起处理最大匹配的工具<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>证明匹配最大的充要条件是图中没有增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后证明Hall定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>顺便证明了婚配定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并利用之证明最大匹配与最小点覆盖的对偶性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>最后证明最小边覆盖与最大独立集的对偶性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及这四者之间的关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
        
          <p class="article-more-link">
            <a href="%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/" rel="tag">二分图匹配</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Public-Transport-System" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="Public-Transport-System/" class="article-date">
  <time class="dt-published" datetime="2021-10-14T09:36:16.000Z" itemprop="datePublished">2021-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/%E9%A2%98%E8%A7%A3/">题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="Public-Transport-System/">Public Transport System</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题意">题意</h2>
<p>给定一个有向图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每条边有边权<span class="markdown-them-math-inline">$a_e$</span>和<span class="markdown-them-math-inline">$b_e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$0&lt;a_e,b_e;\;b_e&lt;a_e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记一条路径由<span class="markdown-them-math-inline">$k$</span>条边<span class="markdown-them-math-inline">$e_1,e_2,...,e_k$</span>组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么这条路径中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>边<span class="markdown-them-math-inline">$e_1$</span>的权值为<span class="markdown-them-math-inline">$a_{e_1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$e_i(i&gt;1)$</span>的权值为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\begin{cases}
a_{e_i}&amp;a_{e_i}\leq a_{e_{i-1}},\\
a_{e_{i}}-b_{e_i}&amp;a_{e_i}&gt;a_{e_{i-1}}.
\end{cases}
$$</div><p>这条路径的权值是这条路径上边的权值之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>求从点<span class="markdown-them-math-inline">$1$</span>出发到所有点的最短路长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\begin{align*}
n\leq 1\times10^5,\ m\leq 2\times10^5.
\end{align*}
$$</div>
        
          <p class="article-more-link">
            <a href="Public-Transport-System/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E5%BB%BA%E5%9B%BE/" rel="tag">建图</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E6%80%9D%E7%BB%B4/" rel="tag">思维</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="page/2/">2</a><a class="page-number" href="page/3/">3</a><a class="extend next" rel="next" href="page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        &copy; 2022 Wilson Xia<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a><br>
<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">陕ICP备2021014297号</a>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="index.html" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="js/clipboard.min.js"></script>
<script src="js/jquery-1.4.3.min.js"></script>

<script src="fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="js/script.js"></script>






<script>
  MathJax = {
    options: {
      enableMenu: false
    },
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
    }
  };
</script>
<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
    CommonHTML: {
      linebreaks: false
    }
  });
  </script> -->
<script type="text/javascript" id="MathJax-script" async
  src="mathjax/tex-chtml.js">
</script>
<!-- <script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_CHTML">
</script> -->



  </div>
</body>
</html>