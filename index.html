<!DOCTYPE html><html><head><meta charset="utf-8"><title>Wilson&#39;s blog</title><link rel="stylesheet" href="/css/fonts/Chinese-normal-normal.min.css"><link rel="stylesheet" href="/css/fonts/ChineseMono-normal-normal.min.css"><link rel="stylesheet" href="/css/fonts/Chinese-italic-normal.min.css"><link rel="stylesheet" href="/css/fonts/Chinese-normal-bold.min.css"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="alternate" href="atom.xml" title="Wilson's blog" type="application/atom+xml"><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css"><link rel="stylesheet" href="/katex/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><script defer src="/katex/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script><script defer src="/katex/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="container"><div id="wrap"><div id="nav-outer"><nav id="main-nav" class="outer"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="index.html">Home</a> <a class="main-nav-link" href="/archives/">Archives</a> <a class="main-nav-link" href="/paper_list/">Paper List</a> <a class="main-nav-link" href="/about/">About</a><div class="main-nav-space-between"></div><a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a></nav></div><div id="header-title"><h1 id="logo-wrap"><a href="index.html" id="logo">Wilson&#39;s blog</a></h1></div><div id="content" class="outer"><section id="main"><article id="post-一些经典的系统idea" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E7%9A%84%E7%B3%BB%E7%BB%9Fidea/" class="article-date"><time class="dt-published" datetime="2023-08-02T07:32:37.000Z" itemprop="datePublished">2023-08-02</time></a><div class="article-category"><a class="article-category-link" href="categories/research/">research</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E7%9A%84%E7%B3%BB%E7%BB%9Fidea/">一些经典的系统idea</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>类似于 CS61C 提出的体系结构经典 idea<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我也想在这里总结一下我在学习/读论文过程中看到的可复用的 idea<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>很多文章就是对这些 idea 进行排列组合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用于实现 tradeoff 的一部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实现整体的性能目标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p class="article-more-link"><a href="%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E7%9A%84%E7%B3%BB%E7%BB%9Fidea/#more">Read More</a></p></div><footer class="article-footer"></footer></div></article><section id="isso-thread"><noscript>Javascript needs to be activated to view comments.</noscript></section><article id="post-6-824-Lab2B-Raft" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="6-824-Lab2B-Raft/" class="article-date"><time class="dt-published" datetime="2022-12-18T00:38:59.000Z" itemprop="datePublished">2022-12-18</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="6-824-Lab2B-Raft/">6.824 Lab2B Raft</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>2022.12.18 完成了 Lab2B<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>内容是实现 Raft 的共识算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>经过 200 轮测试的检验没有发现问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我就当作实验完成了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里记录一下过程中发现的比较有意思的 bug<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>它们不一定很难修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>很多也都明确地写在 Raft paper 的 Figure 2 中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是去思考它们为什么会导致错误<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>什么情况会触发这些错误<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是很有意思的一件事<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且能帮助我们更好地理解 Raft 这个系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>想到读 paper 时没有想到的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="livelock">Livelock</h2><p>有时会发生这种情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>系统虽然在线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但不再做有效的工作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>连心跳都不发送<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>打印许多日志后发现集群<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>由3台机器组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>一直在选举<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且永远是同一个机器竞选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而另外两台机器拒绝投票<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为 Candidate 没有通过 up-to-date 检查<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Raft paper 5.4.1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个 bug 错在 RequestVote RPC 的接收方不加判断地更新重新选举定时器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>正确地做法是仅在投票时更新定时器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>拒绝投票时不更新定时器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>来保证自己可以正确地超时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>启动竞选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在这里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Candidate 没有通过任何 Follower 的 up-to-date 检查<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>说明它无法竞选成功<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要使系统继续工作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要另外两台机器之一超时启动竞选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>类似地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>AppendEntry RPC 应当在 RPC term 没有过期时更新定时器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>注意这不要求 RPC 成功<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为 RPC 可能因为 log 不一致而失败<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这时 Leader 会自减 <code>nextIndex[]</code> 并重试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这仍然构成一个 Heartbeat<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>应当更新定时器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="错误地认为-log 冲突导致不必要的删除">错误地认为 log 冲突导致不必要的删除</h2><p>在 Raft Paper Figure 2 中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>AppendEntry Step 3是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><blockquote><p>If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it.</p></blockquote><p>我曾经在比较 term 时出错<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用 existing entry 的 term 与 AppendEntry 的 term 比较了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>正确的做法与 AppendEntry 中新的 Log Entry 的 term 进行比较<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这可能会导致不必要的删除日志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为传输的新 Log Entry 不一定是当前 term 的内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可能是之前 term 的内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>这会导致问题的场景是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>如果 AppendEntry 在网络中经历了较高的延迟<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>RPC 可能已经过期<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>正确做法下两条 log 不会冲突<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以不会删除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而这个错误会导致删除这条以及其后所有的 log<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而我们很可能之前已经告诉了 Leader 我们拥有那条 log<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果集群中拥有这条 log 的机器数刚好过半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Leader commit 并应用到状态机上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这时我们删除了这条 log<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>拥有 log 的机器数就不再过半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果此时 Leader 再离开集群<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>重新选举的 Leader 就不一定包含这条 log 了<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>正常情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>新Leader 包含这条 log 这件事由 5.4.1 的 up-to-date check 保证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>也就是 committed log 被回滚了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>助教的这篇<a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/students-guide-to-raft/#the-importance-of-details">博文</a>也提到了这一问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>这个 bug 是我阅读代码发现的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这可能并不好测试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>根据我的理解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>6.824 的测试用例并没有模拟乱序的网络通信<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="commitindex-的激进更新导致某些机器做出错误 commit">CommitIndex 的激进更新导致某些机器做出错误 commit</h2><p>问题在于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>TestBackup2B 会有很小的概率失败<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>原因是某台机器作出的 commit 和其他机器已经作出的不一致<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个问题困扰了我很久<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到我离开电脑准备睡觉时才想到这个问题可能的原因<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在 Raft Paper Figure 2 中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>AppendEntry Step 5 是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><blockquote><p>If leaderCommit &gt; commitIndex, set commitIndex = min(leaderCommit, index of last <strong>new</strong> entry).</p></blockquote><p>这个 <strong>new</strong> 很重要<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我的错误在于直接用 log 长度更新 commitIndex<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>正确的做法是用 AppendEntry RPC 中携带的最新 Entry 的下标来更新 commitIndex<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这会导致 commitIndex 的更新过于激进<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后面的尚未确认与 Leader 同步的 log 也会被 commit<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这看起来应该经常出错<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为什么在 TestBackup2B 中很少出现呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>因为带有错误 log 的机器在连接到正确集群时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Leader 会不断地自减 <code>nextIndex[]</code> 并重试 AppendEntry RPC<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到在某处 Log 吻合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这时该 Leader 会第一次更新该 Follower 的 commitIndex<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>commitIndex 首次被更新时 AppendEntry RPC 通常携带新的 Entry<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而这个 Entry 和 RPC 接收方的 log 是冲突的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以 log 都在步骤 3 中被清空了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是步骤 5 中 index of last new entry 也就是 log 的长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>那什么时候才会触发这个错误呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>答案是 commitIndex 首次被更新时接收到的是心跳<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>不带 Entry 的 AppendEntry RPC<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它不会清空后面的错误的 log<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且还会更新 commitIndex<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这就要求心跳刚好在 <code>nextIndex[]</code> 减少到正确值的时候发送<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以出现的概率很低<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>要定位这个 bug 还是很困难的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为这个问题出现的概率真的很低<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>跑50次出1次问题左右<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每跑一次都需要等很久<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且每次 commit 都打印一条信息导致输出很长<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>推荐一篇文章<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a target="_blank" rel="noopener" href="https://blog.josejg.com/debugging-pretty/">Debugging by Pretty Printing</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是 6.824 的一名助教写的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>帮助我们更好地用日志调试分布式系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="committing-entries from previous terms">Committing entries from previous terms</h2><p>我在 Leader 上的 CommitIndex 更新采用的方法是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>找 <code>matchIndex[]</code> 中第 <code>n/2+1</code> 大的数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时要注意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>这条 log 还需要属于当前 term<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则无法宣布 commit<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>也就是不能 commit 之前 term 的日志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>原因在 Raft paper 的 5.4.2 节和 Figure 8 中有详细说明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/distributed-system/" rel="tag">distributed system</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/lab/" rel="tag">lab</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/system/" rel="tag">system</a></li></ul></footer></div></article><section id="isso-thread"><noscript>Javascript needs to be activated to view comments.</noscript></section><article id="post-复读大三" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="%E5%A4%8D%E8%AF%BB%E5%A4%A7%E4%B8%89/" class="article-date"><time class="dt-published" datetime="2022-09-12T15:41:44.000Z" itemprop="datePublished">2022-09-12</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="%E5%A4%8D%E8%AF%BB%E5%A4%A7%E4%B8%89/">复读大三</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>开学的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我感到很想完成几门早有耳闻的北美CS课程的实验<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>6.s081<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>MIT操作系统课<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>cs144<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>斯坦福计算机网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>15-213<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>CMU计算机系统结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>6.824<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>MIT分布式系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>构建一个真正 work 的系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时认真把它搞透<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是想到了一个命题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>我大四课这么少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用来复读大三怎么样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>如果大三可以重来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我会做些什么呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p><h2 id="目标">目标</h2><p>考虑到我同时需要科研以及工作效率并不如想象中高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我定下了一个<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>看起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>可行性很高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>实现后也很有收获的目标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>完成 6.s081<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>cs144<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>15-213 三门课程的实验<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>完成质量需要比较高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里提出几点要求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ol><li>严格按照要求完成实验<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>主要关注分数要求<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>所有通过性测试必须通过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跑分性测试达到较高分数线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>和任务点要求<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如 6.s081 的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>两个功能选择一个实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>不能不选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li><li>清楚明白地了解自己在做什么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不能做完实验还感到有哪里含糊<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>不清楚<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果有疑问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>至少需要具体地列出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并在能力范围内尝试解决</li></ol><p>更高的要求包括<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>阅读源码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从零复现系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>不做硬性要求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>视前几周的精力情况决定要不要做6.824<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>第二周需要先尝试起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>把 Raft 的论文读起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="计划">计划</h2><p>目前的计划<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>每周每门课一个lab<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>除 6.824 外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>第一周已经做完了 cs144 Lab0-2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>6.s081 Lab0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>15-213 bomb lab(4/6)<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>data lab以前做过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不再重做<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>6.828 lab1 是以前做过的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>按照第一周的进度来看<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个计划还是很有希望按期执行的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>不过预测后期难度会增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>尤其是 OS…如果出现这种情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以2周/1.5周一个lab<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>如果计划理想进行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>到了中后期 cs144 就做完了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以投入更多精力做 6.824<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>注意到这里没有编译原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有点尴尬…其实我是很想手搓编译器的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且不想用 yacc/bison<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>除开科研可能需要的编译知识之外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它的优先级可能和分布式系统相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>暂时先不列入计划<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>执行一段时间上面的计划再重新考量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个重新考量不晚于第三周周末<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>本文每周一更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><hr><h2 id="进度记录">进度记录</h2><h3 id="20229.20">2022.9.20</h3><p>这周突然特别想手搓OS<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以进度甚至比预想的还慢…cs144和6.s081推进了一个实验没有问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是csapp没有做<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这周目标和上周一样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中csapp的目标是做完bomb lab并再做一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>不过手搓OS进度还挺好的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>快要进入用户态了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="202212.18">2022.12.18</h3><p>成功地复刻了之前的每个学期都没能坚持学完网课的历史…好在这学期不是一事无成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里来总结一下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>手搓 OS 在虚拟机里已经跑得很不错了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有了用户态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>多进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>系统调用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>文件系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>终端<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>下一步工作包括文件系统的写出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>多核调度与内核锁<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>搭建测试框架<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>尝试了 USB 驱动<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是比较困难<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>暂时放下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>bomb lab 做完了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但也就止步于此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>其他 lab 没做<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>6.824 lab 2B 今天刚刚做完<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过了 200 轮测试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>感觉神清气爽啊<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>科研方面在做一个DSL<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>DSL编译后会生成一套网络协议栈的源码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>已经在实现<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>编译后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>的系统原型了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>目前只差定时器和拥塞控制了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>通过阅读 RFC<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对 TCP 的理解比大三上课时高了不少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"></footer></div></article><section id="isso-thread"><noscript>Javascript needs to be activated to view comments.</noscript></section><article id="post-6-824-Lab1-MapReduce" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="6-824-Lab1-MapReduce/" class="article-date"><time class="dt-published" datetime="2022-03-19T16:01:19.000Z" itemprop="datePublished">2022-03-20</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="6-824-Lab1-MapReduce/">6.824 Lab1 MapReduce</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>前前后后做了15个小时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>看到<code>PASSED ALL 30 TESTING TRIALS</code>的那一刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>太爽<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span></p><h2 id="概述">概述</h2><p>这个实验要求实现经典论文MapReduce的模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>MapReduce在Google内部是跑在一个服务器集群里的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这些服务器共享一个分布式文件系统GFS<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个实验只要求实现运行在本机多个进程上的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>本地文件系统上的MapReduce模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>省去了与分布式文件系统的交互<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>要做负载均衡这个很重要<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且应该很麻烦<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="实现过程流水账">实现过程流水账</h2><p>先读论文花了3h左右<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>内心活动<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>这论文真简单<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>然后开始实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我并不会go语言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>官网那个tour我也就做了一点点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>事实证明全做完比较省时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>第一次写的代码全是<code>if-else</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我还没有加入容错机制的时候代码已经复杂到我读不懂了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>内心活动<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>工业界实现这玩意的人是神仙吧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span>然后我把3个小时码的200多行代码全都回滚掉了:-(</p><p>第二次写代码之前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我决定写一个类似于有限状态自动机的东西<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>事实证明这个模型还不错<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>让我的思路变得比较清晰<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且便于拓展<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后花了2h画图+搭框架<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是只写了一堆<code>switch-case</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每种状态对应的转移和转移前需要进行的操作<em>的注释</em><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后就头晕<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>下班了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>今天是第三次碰这个东西<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>今天如果再自闭我可能就要对这实验产生心理阴影了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>好在我上次的DFA没啥大问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只是有些corner case没想到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>缝缝补补搞了一段时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>终于把注释转换成了代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最戏剧性的一刻来了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>开码10小时后我终于进行了第一次编译<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span>我以为会得到巨长无比的报错<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结果报错就八九行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后就是改完一行错再出现一行错<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>改完<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>最后一行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>错之后又蹦出来十几个错误<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>改了若干年……通过编译之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他在起始状态就出错了……然后又改了若干年<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>终于输出了结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><blockquote><p>第一个教训<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>把语言学明白<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>勤编译勤测试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><p>我查看输出文件的前三行<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>共两万行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现与标准输出一样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span>然后高兴地去跑测试脚本<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结果第一个正确性测试点就挂了……</p><blockquote><p>第二个教训<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>测试要认真严谨<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><p>然后又改了若干年<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>期间多次翻阅论文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现人家写进论文的东西都是经过取舍和迭代的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还是非常精华的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>后来就是无限改bug<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>调试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>按下不表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>终于在今天码代码的第8小时通过了所有测试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span></p><h3 id="做的不错的地方">做的不错的地方</h3><ol><li>画DFA</li><li>头脑不清楚的时候出门转转<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以花掉长达20分钟的时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是回来之后你就复活了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span></li></ol><h3 id="想要做得更好的地方">想要做得更好的地方</h3><ol><li>阶段性编译<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>测试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>例如我的DFA设计好了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这时候就可以测试下转移有没有问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后再在转移前后加功能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>有设计测试点的能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于这个实验<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我是用户<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且一定程度上可以说是赶时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以用老师的脚本来测试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>调试没有什么错<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是一旦成为真正意义上的开发者<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>bug都要自己找<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>不提开源社区之类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要有能力设计若干测试来检验自己的代码在各方面的正确性/性能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这确实需要写一些<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>没用的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是它们通常很简单<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且很有用<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如算法竞赛里的对拍程序和暴力程序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>例如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我尽管知道各个操作的时间/空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但还是不知道我这个实现并发性如何<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>究竟有多少CPU时间是overhead<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>证明我的DFA的正确性</li><li>Challenge</li><li>阅读老师的测试脚本<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>学习写脚本</li></ol></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/distributed-system/" rel="tag">distributed system</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/lab/" rel="tag">lab</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/system/" rel="tag">system</a></li></ul></footer></div></article><section id="isso-thread"><noscript>Javascript needs to be activated to view comments.</noscript></section><article id="post-CF-Edu123-题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="CF-Edu123-%E9%A2%98%E8%A7%A3/" class="article-date"><time class="dt-published" datetime="2022-03-07T13:47:25.000Z" itemprop="datePublished">2022-03-07</time></a><div class="article-category"><a class="article-category-link" href="categories/%E9%A2%98%E8%A7%A3/">题解</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="CF-Edu123-%E9%A2%98%E8%A7%A3/">CF Edu123 题解</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><h2 id="f-basis">F. Basis</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1644/problem/F">题面</a></p><p>考虑一群在操作 2 下可以互相变换的数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在其中可以取一个代表元<span class="markdown-them-math-inline">$arr$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假设<span class="markdown-them-math-inline">$arr$</span>由<span class="markdown-them-math-inline">$i$</span>种数字组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>把<span class="markdown-them-math-inline">$arr$</span>中数字<span class="markdown-them-math-inline">$j$</span>所在的下标的集合记作<span class="markdown-them-math-inline">$S_j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则这一群数组可以用集合的集合<span class="markdown-them-math-inline">$\{S_1,S_2,...,S_i\}$</span>来表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>称为一个<em>原型</em><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果只能做操作2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>答案就是第二类斯特林数<span class="markdown-them-math-inline">$\left\{n\atop i\right\}$</span>的前缀和<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>对<span class="markdown-them-math-inline">$i$</span>从1加到<span class="markdown-them-math-inline">$\min(k,n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>出于后面的实现方便<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将对<span class="markdown-them-math-inline">$i$</span>从2加到<span class="markdown-them-math-inline">$\min(k,n)$</span>的前缀和记作<span class="markdown-them-math-inline">$A(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这可以用<span class="markdown-them-math-inline">$O(n\log n)$</span>的复杂度来求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具体见<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/combinatorics/stirling/#_3">oi-wiki</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>接下来考虑操作1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们发现刚才找到的那些代表元当中有些可以经操作1生成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现在来删除它们<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>将原型<span class="markdown-them-math-inline">$arr$</span>改写成<em>连续的相同数个数的数组</em>的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记作<span class="markdown-them-math-inline">$arr'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如将<span class="markdown-them-math-inline">$1,1,2,2,3$</span>改写成<span class="markdown-them-math-inline">$2,2,1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ol><li>如果<span class="markdown-them-math-inline">$arr'$</span>只有一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是说<span class="markdown-them-math-inline">$arr$</span>中全都是相同的数字<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们发现<span class="markdown-them-math-inline">$arr$</span>一定可以由某个<em>改写前有至少两个不同数的原型</em>经一次操作1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$F(a, n)$</span>生成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是不用对<span class="markdown-them-math-inline">$arr$</span>计数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>也就是说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>题目中给的<span class="markdown-them-math-inline">$k&gt;1$</span>时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不用考虑这种情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果<span class="markdown-them-math-inline">$k=1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>输出1即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>如果<span class="markdown-them-math-inline">$arr'$</span>不只有一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>去掉<span class="markdown-them-math-inline">$arr'$</span>的最后一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考察前面的那些数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果它们的<span class="markdown-them-math-inline">$gcd$</span>不为1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则<span class="markdown-them-math-inline">$arr$</span>可以被别的原型由操作1生成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不用对<span class="markdown-them-math-inline">$arr$</span>计数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对一个<span class="markdown-them-math-inline">$gcd$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有<span class="markdown-them-math-inline">$A(\lceil {n\over gcd}\rceil)$</span>个原型可以被别的原型<span class="markdown-them-math-inline">$a$</span>生成<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>将<span class="markdown-them-math-inline">$arr$</span>中每连续<span class="markdown-them-math-inline">$gcd$</span>个数绑定<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再计算原型数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是<span class="markdown-them-math-inline">$A(\lceil {n\over gcd}\rceil)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>注意<span class="markdown-them-math-inline">$A$</span>是从2开始加的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为数字全部相同的原型并不能由操作1生成<span class="markdown-them-math-inline">$arr$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果这个<span class="markdown-them-math-inline">$gcd$</span>是合数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可能这些冗余数组会被它的因子删除多次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要控制这个次数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解决方法是用mobius函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>就是说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对<span class="markdown-them-math-inline">$gcd$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们计<span class="markdown-them-math-inline">$\mu(gcd)$</span>次<span class="markdown-them-math-inline">$A(\lceil {n\over gcd}\rceil)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ol><p>这里的mobius函数就是在对<span class="markdown-them-math-inline">$gcd$</span>的质因子集合<span class="markdown-them-math-inline">$S$</span>做容斥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>质因子集合<span class="markdown-them-math-inline">$S$</span>的子集<span class="markdown-them-math-inline">$S'\subset S$</span>可以与那些<em>各质因子至多出现一次的<span class="markdown-them-math-inline">$gcd$</span>的因子</em>建立一一映射<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个子集中有奇数个因子就取<span class="markdown-them-math-inline">$-1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>偶数个因子就取<span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有质因子出现2次就取0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>子集为空集时<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>对应于因子1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>也取1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对一个给定的<span class="markdown-them-math-inline">$gcd$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那些能经操作1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$F(a, gcd)$</span>生成的原型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可以被<span class="markdown-them-math-inline">$gcd$</span>的因子<span class="markdown-them-math-inline">$d$</span>们经操作1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$F(F(a,d), gcd/d)$</span>生成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每个这样的原型被计了多少次呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>答案是</p><div class="markdown-them-math-block">$$\sum_{d|gcd}\mu(d)=\sum_{S'\subset S}(-1)^{|S'|}=\sum_{i=0}^{|S|}\binom{|S|}{i}(-1)^{i}\times 1^{|S|-i}=(-1+1)^{|S|}=[gcd=1] $$</div><p>也就是实现了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若<span class="markdown-them-math-inline">$arr'$</span>除去最后一块外的所有数互质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$arr$</span>就属于<strong>基</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则不属于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这结束了我们的讨论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>关于<span class="markdown-them-math-inline">$0^0$</span>不等式和<span class="markdown-them-math-inline">$[gcd=1]$</span>的讨论可以和<a href="Trie%E6%A0%91%E7%BB%B4%E6%8A%A4%E9%9B%86%E5%90%88%E7%9B%B8%E4%BA%A4%E6%80%A7/" title="Trie树维护集合相交性">Trie树维护集合相交性</a>相类比<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>最后的答案是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum_{gcd=1}^n\mu(gcd)A\left(\left\lceil\dfrac{n}{gcd}\right\rceil\right) $$</div><p>直接整除分块求这个东西的一个上界是</p><div class="markdown-them-math-block">$$O(\sum_{gcd=1}^n\dfrac{n\log n}{gcd})=O(n\log n\sum_{d=1}^n\dfrac{1}{d})=O(n\log^2 n) $$</div><p>注意不是<span class="markdown-them-math-inline">$O(n\sqrt{n}\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们还可以合并同一个<span class="markdown-them-math-inline">$\left\lceil\dfrac{n}{gcd}\right\rceil$</span>对应的所有<span class="markdown-them-math-inline">$\mu(gcd)$</span>之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>前缀和或者开桶统计一下就行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于后面那个求和只有其中的<span class="markdown-them-math-inline">$\sqrt{n}$</span>项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可能还达不到<span class="markdown-them-math-inline">$\log n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以理解为常数很小的<span class="markdown-them-math-inline">$\log n$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>经测试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对<span class="markdown-them-math-inline">$n=10^5$</span>该和为6.83<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" rel="tag">容斥原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/" rel="tag">斯特林数</a></li></ul></footer></div></article><section id="isso-thread"><noscript>Javascript needs to be activated to view comments.</noscript></section><article id="post-Trie树维护集合相交性" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="Trie%E6%A0%91%E7%BB%B4%E6%8A%A4%E9%9B%86%E5%90%88%E7%9B%B8%E4%BA%A4%E6%80%A7/" class="article-date"><time class="dt-published" datetime="2022-03-03T09:40:59.181Z" itemprop="datePublished">2022-03-03</time></a><div class="article-category"><a class="article-category-link" href="categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/">奇技淫巧</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="Trie%E6%A0%91%E7%BB%B4%E6%8A%A4%E9%9B%86%E5%90%88%E7%9B%B8%E4%BA%A4%E6%80%A7/">Trie树维护集合相交性</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>这篇文章讲一个 trick<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他可以解决如下问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><blockquote><p>维护一个结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以添加和删除集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对询问中给定的新集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结构中有多少集合与之不交<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p></blockquote><p>用这个 trick<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以在 <span class="markdown-them-math-inline">$O(2^{|S|})$</span> 的时间复杂度内添加或询问一个集合 <span class="markdown-them-math-inline">$S$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以在多个小集合的时候比较有用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对两个集合 <span class="markdown-them-math-inline">$A$</span> 和 <span class="markdown-them-math-inline">$B$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑 <span class="markdown-them-math-inline">$B$</span> 的所有子集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>维护一个计数器 <span class="markdown-them-math-inline">$cnt$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对每个子集 <span class="markdown-them-math-inline">$S$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果它也是 <span class="markdown-them-math-inline">$A$</span> 的子集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为 <span class="markdown-them-math-inline">$cnt$</span> 加上 <span class="markdown-them-math-inline">$(-1)^{|S|}$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="markdown-them-math-block">$$cnt=\sum_{S\subset (A\cap B)}(-1)^{|S|}=\sum_{i=0}^{|S|}\binom{|S|}{i}(-1)^i\times 1^{|S|-i}=(1-1)^{|S|} $$</div><p><span class="markdown-them-math-inline">$A\cap B=\emptyset$</span> 时形式上是<span class="markdown-them-math-inline">$0^0$</span>不定式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>根据定义式计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现它有由空集贡献的 1 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是 <span class="markdown-them-math-inline">$cnt$</span> 就标志着 <span class="markdown-them-math-inline">$A\cap B$</span> 是否为空<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>为空时 <span class="markdown-them-math-inline">$cnt=1$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则 <span class="markdown-them-math-inline">$cnt=0$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>现在我们维护一个 Trie 树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个节点代表一个集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当添加集合 <span class="markdown-them-math-inline">$A$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>给它的所有子集对应的节点权值加一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>删除时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就为所有子集对应的节点权值减一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以注意到空集对应节点的权值就代表当前结构中维护的集合个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>然后考虑询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>设在询问 <span class="markdown-them-math-inline">$S$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对所有 <span class="markdown-them-math-inline">$S'\subset S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果 Trie 树中有对应 <span class="markdown-them-math-inline">$S'$</span> 的节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就为计数器加上 <span class="markdown-them-math-inline">$(-1)^{|S'|}\times tr ie[S']$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对结构中维护的每个集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若它和 <span class="markdown-them-math-inline">$S$</span> 不交<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它对计数器的贡献就是 1 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则是 0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是计数器的值就代表了结构中与 <span class="markdown-them-math-inline">$S$</span> 不交的集合个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"></footer></div></article><section id="isso-thread"><noscript>Javascript needs to be activated to view comments.</noscript></section><article id="post-ARC136题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="ARC136%E9%A2%98%E8%A7%A3/" class="article-date"><time class="dt-published" datetime="2022-03-01T13:17:35.000Z" itemprop="datePublished">2022-03-01</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="ARC136%E9%A2%98%E8%A7%A3/">ARC136题解</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>这场 ARC 比较考验观察能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是找到切入点的能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我会尽量在题解里给出一个观察的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>至于证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比猜到结论简单<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这场暴露出来我的容易进死胡同的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可能是人类本质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>就是一种思路做不出来的时候跳不出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>思维僵化了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>以后训练中得注意对想不出来的题尝试<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>跳出思维定势<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>也可能只是 trick 掌握得不够<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>导致跳出来也不知道想啥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以先多积累些思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>毕竟<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>思而不学则殆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="c-- circular addition">C - Circular Addition</h2><p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc136/tasks/arc136_c">题面</a></p><p>收获的思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ol><li>在差分数组上看区间加减</li><li>问最小操作次数时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>找几个下界<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>尝试证明其最大值可以取到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>证明时可以尝试把创造过程逆转为消除过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为消除时的信息更多<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而创造是在<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>创造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ol><p>我看到了第一个切入点<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>用差分数组处理区间加减问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果您对这个题毫无头绪<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以先对着这句话看自己能想到哪一步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>将目标数组看作环并作长为 <span class="markdown-them-math-inline">$n$</span> 的差分数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现这个差分数组和一定为 0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且每次操作一定是使得一个数 +1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个数 -1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>显然我们可以通过每次选择一正一负的一对位置操作来得到目标差分数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>操作次数为<em>差分数组中正值之和</em><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>然后我发现过不了最后一个样例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仔细一看发现其实也没能给出前两个样例的具体操作步骤<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不太对劲<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是可以交换差分数组上的操作顺序来获得额外的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>全体 +1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>buff<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个信息在差分数组里被丢掉了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>从这时开始<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我就开始想着怎么最大化这个 buff<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及是不是最大 buff 和零 buff 之间的所有值都能取到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>陷入了苦战<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>按照题解来讲的话<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们已经观察到了一个操作次数下界<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还有另一个显然的下界<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是数组中的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们猜想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>他们中的最大值是可以被取到的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后反过来想将目标数组变为 0 的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们发现这个思路在近达上一场比赛 ARC135D 中就出现过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要学习一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>实际应用中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种猜想很可能会错<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>尤其是难题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>所以姑且提出一个做题步骤<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ol><li>观察总结此前得到的事实<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>提出猜想</li><li>代入样例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若有误返回1</li><li>尝试证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若证伪返回1</li><li>如果证明或不会证而自信<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>开码</li><li>如果没证出来且不太自信<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>多造点样例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再次手玩或对拍<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若有误返回1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则开码</li></ol><p>按照步骤<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们应当代入样例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>发现没问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>开始尝试证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果我们在每一时刻都能降低<strong>这一时刻的</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>差分数组下界<span class="markdown-them-math-inline">$L_1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>和<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>最大值下界<span class="markdown-them-math-inline">$L_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>中的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就构造性地证明了猜想的正确性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>为了降低最大者<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们需要对<span class="markdown-them-math-inline">$L_1$</span>和<span class="markdown-them-math-inline">$L_2$</span>的大小做出假设来进行进一步推理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ol><li><span class="markdown-them-math-inline">$L_1&lt;L_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>此时数组中不可能有 0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则为了从 0 增加到 <span class="markdown-them-math-inline">$L_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>差分数组中正值部分至少是 <span class="markdown-them-math-inline">$L_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这与 <span class="markdown-them-math-inline">$L_1&lt;L_2$</span> 矛盾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是全体 -1 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样能使 <span class="markdown-them-math-inline">$L_2$</span> 减小 1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li><span class="markdown-them-math-inline">$L_1&gt;L_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>如果数组中有 0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们只要挑选一段包含最大值的极大非零区间来全体 -1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样能使 <span class="markdown-them-math-inline">$L_1$</span> 减小 1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果数组中没有 0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数组中一定有若干<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>山谷<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以一定可以找一段极大的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>连续最大值区间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>要求其左右不再是最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>来减 1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这能使 <span class="markdown-them-math-inline">$L_1$</span> 减小 1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li><span class="markdown-them-math-inline">$L_1=L_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>如果数组中有 0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一定是单调增加到 <span class="markdown-them-math-inline">$L_2$</span> 再单调减小到 0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将非零部分 -1 即可同时减小 <span class="markdown-them-math-inline">$L_1$</span> 和 <span class="markdown-them-math-inline">$L_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果数组中没有0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数组中一定有若干<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>山谷<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果*极大的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>连续最大值区间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>*唯一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么将其减 1 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>否则<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一定可以找到一个区间覆盖所有的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如除去最小值后获得的区间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>将这个区间全体减 1 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ol><p>把这个过程反过来想会变得更难想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>尤其是 <span class="markdown-them-math-inline">$L_1=L_2$</span> 时的操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>所以这个<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>减小双下限最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>的 trick 应该被加入知识库<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="d-- without carry">D - Without Carry</h2><p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc136/tasks/arc136_d">题面</a></p><p>收获<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>SOSdp</p><p>推荐博文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/45223">SOSdp</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/72488">zeta transform</a> 前者为后者前置知识<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>本题只需要学习前者<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是来都来了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为什么不都学一下呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p><p>读完博文直接就会做了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不会就看官方题解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不必多说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="e-- non-coprime dag">E - Non-coprime DAG</h2><p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc136/tasks/arc136_e">题面</a></p><p>收获<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><s>我观察能力低下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></s></p><ol><li>不够耐心<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一条思路还没想透彻就放弃</li><li>可以把结论写出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更容易发现规律<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>形式的不同会影响思考方式</li></ol><p>在看题解之前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>您至少应该发现<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>不可达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>和<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>互质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>并不等价<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如9可以经12和14到达35<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>并且经过了一定的思考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对 <span class="markdown-them-math-inline">$i&lt;j$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考察 <span class="markdown-them-math-inline">$i$</span> 是否可达 <span class="markdown-them-math-inline">$j$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>后文同余符号皆模 2 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$f(i)$</span> 为 <span class="markdown-them-math-inline">$i$</span> 的最小质因子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ol><li><span class="markdown-them-math-inline">$i\equiv 0,\;j\equiv 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时一定可达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li><span class="markdown-them-math-inline">$i\equiv 0,\;j\equiv 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时来到了第一个重要观察<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>可以尝试经过 <span class="markdown-them-math-inline">$j - f(j)$</span> 这一偶数到达 <span class="markdown-them-math-inline">$j$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以不超过 <span class="markdown-them-math-inline">$j-f(j)$</span> 的偶数都 ok <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即要求<span class="markdown-them-math-inline">$i\leq j-f(j)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而比它大的偶数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>和 <span class="markdown-them-math-inline">$j$</span> 的差距已经小于其最小质因子了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>没有机会走到 <span class="markdown-them-math-inline">$j$</span> 了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li><span class="markdown-them-math-inline">$i\equiv 1,\;j\equiv 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>类似于 2 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要求<span class="markdown-them-math-inline">$i+f(i)\leq j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li><span class="markdown-them-math-inline">$i\equiv 1,\; j\equiv 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时来到了第二个重要观察<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也是我卡住的地方<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于我没有将上面的观察列出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我并没有注意经过偶数到达奇数这条路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或者隐约觉得这效率低下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>其实这个类比还是比较明显的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大脑好用时起码可以猜一个结论出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>先写结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$i+f(i)\leq j-f(j)$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>首先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>两者都是奇数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就决定了只加一个<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>一定为奇的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>质因数并不能使 <span class="markdown-them-math-inline">$i$</span> 到达 <span class="markdown-them-math-inline">$j$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>至少要加 2 个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果想由偶数搭桥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然<code>i -&gt; i+f(i) -&gt; j-f(j) -&gt; j</code>的路径就是最优的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果不这样做<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么 <span class="markdown-them-math-inline">$i,j$</span> 有公因子<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>此时 <span class="markdown-them-math-inline">$i+f(i)\leq j-f(j)$</span> 必成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或者仍然可以理解为从偶数搭桥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么还是需要转到 <span class="markdown-them-math-inline">$j-fac(j)$</span> 再转到 <span class="markdown-them-math-inline">$j$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$fac(j)$</span> 是 <span class="markdown-them-math-inline">$j$</span> 的某个因子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而这一个转变最少也要加 <span class="markdown-them-math-inline">$f(i)$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转变后最少也要再加 <span class="markdown-them-math-inline">$f(j)$</span> 到达 <span class="markdown-them-math-inline">$j$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>本质还是从偶数搭桥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ol><p>现在我们获得了<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>可达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>的数学表达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我又卡在这里了<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>我去想 DAG 了并且没跳出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>悲<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>注意到不等号左右的内容都很相似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且右侧可以加1<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>因为模2的限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>两式仍然等价<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>尝试总结为一个式子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以将不等式变形为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ol><li><span class="markdown-them-math-inline">$i+1\leq j$</span></li><li><span class="markdown-them-math-inline">$i+1\leq j-f(j)+1$</span></li><li><span class="markdown-them-math-inline">$i+f(i)\leq j$</span></li><li><span class="markdown-them-math-inline">$i+f(i)\leq j-f(j)+1$</span></li></ol><p>可以总结为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$i$</span> 可达 <span class="markdown-them-math-inline">$j$</span> <span class="markdown-them-math-inline">$\Leftrightarrow$</span> <span class="markdown-them-math-inline">$up(i)\leq low(j)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$up(i)=(i\equiv0)?i+1:i+f(i)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>注意这个 <span class="markdown-them-math-inline">$+1$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是因为 <span class="markdown-them-math-inline">$i&lt;j$</span> 不带等号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span><span class="markdown-them-math-inline">$low(j)=(j\equiv0)?j:j-f(j)+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>再次总结这个表达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对任意的 <span class="markdown-them-math-inline">$i, j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当且仅当 <span class="markdown-them-math-inline">$up(i)\leq low(j)$</span> 或 <span class="markdown-them-math-inline">$up(j)\leq low(i)$</span> 时他们之间可达<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用区间语言表达就更干净<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$[low(i), up(i))$</span> 与 <span class="markdown-them-math-inline">$[low(j),up(j))$</span> 没有交点时可达<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>注意区间开闭<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是题目变成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>寻找有公共交点的区间族 <span class="markdown-them-math-inline">$\{[low(i), up(i))\mid i\in\mathbb{N}\}$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使得 <span class="markdown-them-math-inline">$\sum_{i}A_i$</span>最大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>随便做<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E9%A2%98%E8%A7%A3/" rel="tag">题解</a></li></ul></footer></div></article><section id="isso-thread"><noscript>Javascript needs to be activated to view comments.</noscript></section><article id="post-ARC135题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="ARC135%E9%A2%98%E8%A7%A3/" class="article-date"><time class="dt-published" datetime="2022-02-14T14:27:52.000Z" itemprop="datePublished">2022-02-14</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="ARC135%E9%A2%98%E8%A7%A3/">ARC135题解</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>F暂时有个地方没搞明白<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但我会研究题解和正确代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>把它搞会<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="c-- xor to all">C - XOR to All</h2><p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc135/tasks/arc135_c">题面</a></p><p>关键在于发现若干次操作一定可以等价于一次操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>假设进行了多次操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考察前两次操作<span class="markdown-them-math-inline">$B_0$</span>和<span class="markdown-them-math-inline">$B_1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$B_0$</span>一定是原数组中的一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而<span class="markdown-them-math-inline">$B_1$</span>一定是原数组中的某个数<span class="markdown-them-math-inline">$A$</span>与<span class="markdown-them-math-inline">$B_0$</span>的异或和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为<span class="markdown-them-math-inline">$B_1$</span>取自被<span class="markdown-them-math-inline">$B_0$</span>更新过的数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们发现<span class="markdown-them-math-inline">$B_0,B_1$</span>两次操作的结果等价于直接用<span class="markdown-them-math-inline">$A$</span>进行一次操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>现在操作次数减少了1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以一直使用这个方法直到将多次操作等价为一次操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>现在只需要比较选择每个数对数组元素之和的影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这可以按位统计做到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对每一位<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>最多30位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>统计有多少个数在这一位是1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后选择<span class="markdown-them-math-inline">$A_i$</span>对和的影响就是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$A_i$</span>会对数组中所有的数翻转<span class="markdown-them-math-inline">$A_i$</span>中为1的那些位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>翻转的贡献可以由统计的数据计算出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="e-- sequence of multiples">E - Sequence of Multiples</h2><p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc135/tasks/arc135_e">题面</a></p><p>赛后自己做出来了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>很高兴<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>下面记题目描述的数列本身为<span class="markdown-them-math-inline">$A_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而不论怎样得到它<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="初见端倪的朴素算法">初见端倪的朴素算法</h3><p>观察一个特殊的例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$X=1,N=1e18$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时数列就是<span class="markdown-them-math-inline">$1$</span>到<span class="markdown-them-math-inline">$n$</span>本身<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span>然后考察<span class="markdown-them-math-inline">$X=2,N=1e18$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现数列是<span class="markdown-them-math-inline">$\{2n\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>继续观察<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>会总结出一个规律<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>无论<span class="markdown-them-math-inline">$X$</span>如何<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当<span class="markdown-them-math-inline">$n$</span>充分大时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数列会变成<span class="markdown-them-math-inline">$\{kn\}$</span>的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$k$</span>为常数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>假设第<span class="markdown-them-math-inline">$n$</span>项是<span class="markdown-them-math-inline">$kn$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么第<span class="markdown-them-math-inline">$n+1$</span>项的一个上界是<span class="markdown-them-math-inline">$k(n+1)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这比前一项大了<span class="markdown-them-math-inline">$k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只要<span class="markdown-them-math-inline">$k\leq n+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个上界就会被取到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为更小的<span class="markdown-them-math-inline">$n+1$</span>的倍数已经小于第<span class="markdown-them-math-inline">$n$</span>项了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这不符合题目要求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>于是我们发现这个<span class="markdown-them-math-inline">$k$</span>的变化趋势是很重要的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果我们能搞清楚什么时候<span class="markdown-them-math-inline">$k\leq n+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这之后的内容就可以<span class="markdown-them-math-inline">$O(1)$</span>计算了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>为了研究它<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>构造新的数组<span class="markdown-them-math-inline">$\{B_n\}:B_i=A_i/i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>在特殊例子上构造<span class="markdown-them-math-inline">$\{B_n\}$</span>会给我们一些最基本的认识<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$\{B_n\}$</span>是不增的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>前面的证明过程稍加修改就能证明这个结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>实际上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们感到它以类似于反比函数的速度减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>为了解出<span class="markdown-them-math-inline">$B_i\leq i+1$</span>的时刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们研究<span class="markdown-them-math-inline">$B_i$</span>的变化趋势<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而这可以其定义中的<span class="markdown-them-math-inline">$A_i$</span>入手<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考察<span class="markdown-them-math-inline">$A_i$</span>的变化趋势<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们发现<span class="markdown-them-math-inline">$A_{i+1}-A_i\leq i+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则<span class="markdown-them-math-inline">$A_{i+1}$</span>会被<span class="markdown-them-math-inline">$A_{i+1}-(i+1)$</span>取代<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是<span class="markdown-them-math-inline">$A_i$</span>大致以<span class="markdown-them-math-inline">$O(n^2)$</span>的速度增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$A_i-A_1\leq(\sum_{k=2}^{i} k)=(i+2)(i-1)/2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>得到了<span class="markdown-them-math-inline">$\{A_i\}$</span>的变化趋势<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>两侧同时除以<span class="markdown-them-math-inline">$i$</span>即可得到<span class="markdown-them-math-inline">$\{B_i\}$</span>的变化趋势上界<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$B_i-\frac{X}{i}\leq \frac{(i+2)(i-1)}{2i}\leq i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$B_i\leq \frac{X}{i}+i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个上界是有极小值的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但我们知道<span class="markdown-them-math-inline">$B_i$</span>不增<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以我们可以先增加<span class="markdown-them-math-inline">$i$</span>得到极小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后等待<span class="markdown-them-math-inline">$i+1$</span>追上这个极小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>显然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个极小值在<span class="markdown-them-math-inline">$i=\sqrt{X}$</span>附近取到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而<span class="markdown-them-math-inline">$i=2\sqrt{X}$</span>时就一定有<span class="markdown-them-math-inline">$B_i\leq i+1$</span>了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是我们证明了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果我们暴力计算<span class="markdown-them-math-inline">$\{A_i\}$</span>直到<span class="markdown-them-math-inline">$B_i\leq i+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度是<span class="markdown-them-math-inline">$O(\sqrt{X})$</span>的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>尽管我们没有证明其下界<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但这个算法实际效率也不够高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对<code>1e18 1e18</code>的输入需要计算20秒<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>10组就是200秒<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>远不是常数问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="正解">正解</h3><p><span class="markdown-them-math-inline">$B_i$</span>有一个类似于反比函数的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一开始快速下降<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后缓慢下降<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后不变的变化过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对反比函数的取整求和有整除分块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对<span class="markdown-them-math-inline">$B_i$</span>能不能也找到某种分块来合并一些计算呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E9%A2%98%E8%A7%A3/" rel="tag">题解</a></li></ul></footer></div></article><section id="isso-thread"><noscript>Javascript needs to be activated to view comments.</noscript></section><article id="post-在Linux上使用clash" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="%E5%9C%A8Linux%E4%B8%8A%E4%BD%BF%E7%94%A8clash/" class="article-date"><time class="dt-published" datetime="2022-01-21T03:31:11.000Z" itemprop="datePublished">2022-01-21</time></a><div class="article-category"><a class="article-category-link" href="categories/%E5%B7%A5%E5%85%B7/">工具</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="%E5%9C%A8Linux%E4%B8%8A%E4%BD%BF%E7%94%A8clash/">在Linux上使用clash</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>我火星了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有现成的GUI…请使用<a target="_blank" rel="noopener" href="https://github.com/Fndroid/clash_for_windows_pkg/releases">Clash for Windows</a>的Linux版本<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ol><li>在<a target="_blank" rel="noopener" href="https://github.com/Fndroid/clash_for_windows_pkg/releases">release页面</a>下载<code>Clash.for.Windows-0.x.x-x64-linux.tar.gz</code></li><li>解压后执行<code>./cfw</code></li><li>为了脱离命令行运行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请看<a target="_blank" rel="noopener" href="https://github.com/Fndroid/clash_for_windows_pkg/issues/2107">issue</a></li></ol><hr><p>以下为原文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>以<a target="_blank" rel="noopener" href="https://panel.touhou.tel/auth/register?code=jXeZ">东方网络</a>为例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>按照机场默认的配置使用clash<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果不够满意<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>大概率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>参考<a target="_blank" rel="noopener" href="https://clash.gitbook.io/doc/restful-api">API文档</a>再稍微写一些代码就可以进行规则与节点的配置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>待更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="步骤">步骤</h2><ol><li>在<a target="_blank" rel="noopener" href="https://github.com/Dreamacro/clash/releases/">releases</a>页面中下载最新版clash内核<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一般的64位机器下载amd64版本即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>解压后为一个可执行文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>重命名为<code>clash</code>后执行<code>chmod +x clash</code>为其加上执行权限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>在机场网站上下载配置文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>命名为<code>config.yaml</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>执行<code>./clash -t -f config.yaml</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果没有问题说明配置文件正确<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>执行<code>./clash -f config.yaml</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>开启代理服务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>配置系统代理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>选择&quot;use manually specified proxy configuration&quot;<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>填入代理日志显示的代理地址+端口号</li><li>配置浏览器使用系统代理/配置浏览器代理指向clash<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>现在应该已经可以访问google了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果不行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>检查配置文件的mode<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果是direct<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>改成rule或者global<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>按照<a target="_blank" rel="noopener" href="https://github.com/Dreamacro/clash/wiki/clash-as-a-daemon">官方wiki</a>的步骤将其配置为守护进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ol><p>这样就足以支持日常需求了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"></footer></div></article><section id="isso-thread"><noscript>Javascript needs to be activated to view comments.</noscript></section><article id="post-页面调度算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" class="article-date"><time class="dt-published" datetime="2022-01-07T04:31:38.000Z" itemprop="datePublished">2022-01-07</time></a><div class="article-category"><a class="article-category-link" href="categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/">页面调度算法</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><h2 id="最优调度算法为什么最优">最优调度算法为什么最优</h2><p>我们发现换页时换入的页总是固定的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们要挑选的是换出的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>优先换出不再被访问的页面是显然的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>首先注意换出的页面在下次访问时是一定会被换入的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只要考虑没被换出的页面有没有离开即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果不用最优调度算法换出A<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而换出一个下次访问更早的页面B<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>如果A在下次访问A前未被调出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么换出A仍能使得下次访问B前B未被调出</li><li>如果A在下次访问A前被调出了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么换出A有可能可以使得B不用被调出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为B的下次访问更早</li></ul><p>于是换出A一定不比换出B差<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无论换出B后采用什么策略<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="堆栈式算法">堆栈式算法</h2><p>堆栈式算法是指<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>访问第<span class="markdown-them-math-inline">$t$</span>个页面时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑驻留集大小为<span class="markdown-them-math-inline">$n$</span>时的驻留集<span class="markdown-them-math-inline">$S$</span>和驻留集大小为<span class="markdown-them-math-inline">$n+1$</span>时的驻留集<span class="markdown-them-math-inline">$S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果可以证明在某种调度算法下无论对什么输入下的哪个<span class="markdown-them-math-inline">$t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都有<span class="markdown-them-math-inline">$S\subset S'$</span>成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么这个调度算法就是堆栈式算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="堆栈式算法的好处">堆栈式算法的好处</h3><p>这种算法没有Belady现象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>页框增加时缺页中断次数不会增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>页框增加时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于任何时刻<span class="markdown-them-math-inline">$S\subset S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$P\notin S'\Rightarrow P\notin S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即<em>某页在页框多时缺页</em><span class="markdown-them-math-inline">$\Rightarrow$</span><em>该页在页框少时也缺页</em><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>缺页中断次数不会更少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="最优调度算法/lru为什么是堆栈式算法">最优调度算法/LRU为什么是堆栈式算法</h3><p>用数学归纳法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>初始时<span class="markdown-them-math-inline">$S=S'=\emptyset$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>假设对某个访问序列满足<span class="markdown-them-math-inline">$S\subset S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现在再访问一页<span class="markdown-them-math-inline">$P$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>若<span class="markdown-them-math-inline">$P\notin S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$P\notin S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时产生缺页中断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设在<span class="markdown-them-math-inline">$S$</span>中换出页<span class="markdown-them-math-inline">$P_1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$S'$</span>中换出<span class="markdown-them-math-inline">$P_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对OPT/LRU中的每一种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么<span class="markdown-them-math-inline">$P_2\in S'-S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么<span class="markdown-them-math-inline">$P_1=P_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无论哪种情形<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>换出页后仍满足<span class="markdown-them-math-inline">$S\subset S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>综上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对任意输入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这两种算法都是堆栈式算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>这个证明的核心在于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>要么<span class="markdown-them-math-inline">$P_2\in S'-S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么<span class="markdown-them-math-inline">$P_1=P_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>看到网上的一个理解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>说是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>给驻留集里的页面一个与<span class="markdown-them-math-inline">$n$</span>无关的优先级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>选择优先级最高的那个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是不会选择<span class="markdown-them-math-inline">$S-\{P_1\}$</span>中的元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对FIFO算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个优先级是进入时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后我们会发现这个东西不完全取决于驻留集这个集合本身<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还取决于它进入驻留集的时刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>有可能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>驻留集小时的缺页导致一个页面换出后再次换入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但驻留集大时则总是驻留<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而它在驻留集小时优先级低而驻留集大时优先级高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时有可能<span class="markdown-them-math-inline">$P_2$</span>是那个<span class="markdown-them-math-inline">$S'$</span>中总是驻留的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而<span class="markdown-them-math-inline">$P_1$</span>是其他的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是这个<span class="markdown-them-math-inline">$P_2$</span>现在仍在<span class="markdown-them-math-inline">$S$</span>中而不在<span class="markdown-them-math-inline">$S'$</span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"></footer></div></article><section id="isso-thread"><noscript>Javascript needs to be activated to view comments.</noscript></section><nav id="page-nav"><span class="page-number current">1</span><a class="page-number" href="page/2/">2</a><a class="page-number" href="page/3/">3</a><a class="page-number" href="page/4/">4</a><a class="extend next" rel="next" href="page/2/">下一页 &raquo;</a></nav></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2024 Wilson Xia<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/bill-xia/hexo-theme-mashiro" target="_blank">Mashiro</a><br></div></div></footer></div><nav id="mobile-nav"><a href="index.html" class="mobile-nav-link">Home</a> <a href="/archives/" class="mobile-nav-link">Archives</a> <a href="/paper_list/" class="mobile-nav-link">Paper List</a> <a href="/about/" class="mobile-nav-link">About</a></nav><script src="js/clipboard.min.js"></script><script src="js/jquery-1.4.3.min.js"></script><script src="fancybox/jquery.fancybox-1.3.4.pack.js"></script><script src="js/script.js"></script><script data-isso="https://isso.wilsonxia.cn" src="https://isso.wilsonxia.cn/js/embed.min.js"></script></div></body></html>