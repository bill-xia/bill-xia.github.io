<!DOCTYPE html><html><head><meta charset="utf-8"><title>页面调度算法 | Wilson&#39;s blog</title><link rel="stylesheet" href="/css/fonts/Chinese-normal-normal.min.css"><link rel="stylesheet" href="/css/fonts/ChineseMono-normal-normal.min.css"><link rel="stylesheet" href="/css/fonts/Chinese-italic-normal.min.css"><link rel="stylesheet" href="/css/fonts/Chinese-normal-bold.min.css"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="最优调度算法为什么最优
我们发现换页时换入的页总是固定的，我们要挑选的是换出的页面。优先换出不再被访问的页面是显然的。首先注意换出的页面在下次访问时是一定会被换入的。只要考虑没被换出的页面有没有离开即可。如果不用最优调度算法换出A，而换出一个下次访问更早的页面B，那么：

如果A在下次访问A前未被调"><link rel="alternate" href="../atom.xml" title="Wilson's blog" type="application/atom+xml"><link rel="shortcut icon" href="../favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css"><link rel="stylesheet" href="/katex/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><script defer src="/katex/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script><script defer src="/katex/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="container"><div id="wrap"><div id="nav-outer"><nav id="main-nav" class="outer"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="../index.html">Home</a> <a class="main-nav-link" href="../archives/">Archives</a> <a class="main-nav-link" href="../paper_list/">Paper List</a> <a class="main-nav-link" href="../about/">About</a><div class="main-nav-space-between"></div><a id="nav-rss-link" class="nav-icon" href="../atom.xml" title="RSS 订阅"></a></nav></div><div id="header-title"><h1 id="logo-wrap"><a href="../index.html" id="logo">Wilson&#39;s blog</a></h1></div><div id="content" class="outer"><section id="main"><article id="post-页面调度算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="" class="article-date"><time class="dt-published" datetime="2022-01-07T04:31:38.000Z" itemprop="datePublished">2022-01-07</time></a><div class="article-category"><a class="article-category-link" href="../categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div></div><div class="article-inner"><header class="article-header"><h1 class="p-name article-title" itemprop="headline name">页面调度算法</h1></header><div class="e-content article-entry" itemprop="articleBody"><h2 id="最优调度算法为什么最优">最优调度算法为什么最优</h2><p>我们发现换页时换入的页总是固定的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们要挑选的是换出的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>优先换出不再被访问的页面是显然的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>首先注意换出的页面在下次访问时是一定会被换入的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只要考虑没被换出的页面有没有离开即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果不用最优调度算法换出A<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而换出一个下次访问更早的页面B<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>如果A在下次访问A前未被调出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么换出A仍能使得下次访问B前B未被调出</li><li>如果A在下次访问A前被调出了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么换出A有可能可以使得B不用被调出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为B的下次访问更早</li></ul><p>于是换出A一定不比换出B差<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无论换出B后采用什么策略<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="堆栈式算法">堆栈式算法</h2><p>堆栈式算法是指<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>访问第<span class="markdown-them-math-inline">$t$</span>个页面时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑驻留集大小为<span class="markdown-them-math-inline">$n$</span>时的驻留集<span class="markdown-them-math-inline">$S$</span>和驻留集大小为<span class="markdown-them-math-inline">$n+1$</span>时的驻留集<span class="markdown-them-math-inline">$S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果可以证明在某种调度算法下无论对什么输入下的哪个<span class="markdown-them-math-inline">$t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都有<span class="markdown-them-math-inline">$S\subset S'$</span>成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么这个调度算法就是堆栈式算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="堆栈式算法的好处">堆栈式算法的好处</h3><p>这种算法没有Belady现象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>页框增加时缺页中断次数不会增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>页框增加时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于任何时刻<span class="markdown-them-math-inline">$S\subset S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$P\notin S'\Rightarrow P\notin S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即<em>某页在页框多时缺页</em><span class="markdown-them-math-inline">$\Rightarrow$</span><em>该页在页框少时也缺页</em><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>缺页中断次数不会更少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="最优调度算法/lru为什么是堆栈式算法">最优调度算法/LRU为什么是堆栈式算法</h3><p>用数学归纳法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>初始时<span class="markdown-them-math-inline">$S=S'=\emptyset$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>假设对某个访问序列满足<span class="markdown-them-math-inline">$S\subset S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现在再访问一页<span class="markdown-them-math-inline">$P$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>若<span class="markdown-them-math-inline">$P\notin S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$P\notin S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时产生缺页中断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设在<span class="markdown-them-math-inline">$S$</span>中换出页<span class="markdown-them-math-inline">$P_1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$S'$</span>中换出<span class="markdown-them-math-inline">$P_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对OPT/LRU中的每一种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么<span class="markdown-them-math-inline">$P_2\in S'-S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么<span class="markdown-them-math-inline">$P_1=P_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无论哪种情形<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>换出页后仍满足<span class="markdown-them-math-inline">$S\subset S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>综上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对任意输入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这两种算法都是堆栈式算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>这个证明的核心在于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>要么<span class="markdown-them-math-inline">$P_2\in S'-S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么<span class="markdown-them-math-inline">$P_1=P_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>看到网上的一个理解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>说是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>给驻留集里的页面一个与<span class="markdown-them-math-inline">$n$</span>无关的优先级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>选择优先级最高的那个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是不会选择<span class="markdown-them-math-inline">$S-\{P_1\}$</span>中的元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对FIFO算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个优先级是进入时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后我们会发现这个东西不完全取决于驻留集这个集合本身<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还取决于它进入驻留集的时刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>有可能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>驻留集小时的缺页导致一个页面换出后再次换入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但驻留集大时则总是驻留<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而它在驻留集小时优先级低而驻留集大时优先级高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时有可能<span class="markdown-them-math-inline">$P_2$</span>是那个<span class="markdown-them-math-inline">$S'$</span>中总是驻留的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而<span class="markdown-them-math-inline">$P_1$</span>是其他的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是这个<span class="markdown-them-math-inline">$P_2$</span>现在仍在<span class="markdown-them-math-inline">$S$</span>中而不在<span class="markdown-them-math-inline">$S'$</span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"><section id="isso-thread"><noscript>Javascript needs to be activated to view comments.</noscript></section></footer></div><nav id="article-nav"><a href="../%E5%9C%A8Linux%E4%B8%8A%E4%BD%BF%E7%94%A8clash/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">在Linux上使用clash</div></a><a href="../%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">二分图匹配</div></a></nav></article></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2024 Wilson Xia<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/bill-xia/hexo-theme-mashiro" target="_blank">Mashiro</a><br></div></div></footer></div><nav id="mobile-nav"><a href="../index.html" class="mobile-nav-link">Home</a> <a href="../archives/" class="mobile-nav-link">Archives</a> <a href="../paper_list/" class="mobile-nav-link">Paper List</a> <a href="../about/" class="mobile-nav-link">About</a></nav><script src="../js/clipboard.min.js"></script><script src="../js/jquery-1.4.3.min.js"></script><script src="../fancybox/jquery.fancybox-1.3.4.pack.js"></script><script src="../js/script.js"></script><script data-isso="https://isso.wilsonxia.cn" src="https://isso.wilsonxia.cn/js/embed.min.js"></script></div></body></html>