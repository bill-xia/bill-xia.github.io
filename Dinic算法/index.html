<!DOCTYPE html><html><head><meta charset="utf-8"><title>Dinic算法 | Wilson&#39;s blog</title><link rel="stylesheet" href="/css/fonts/Chinese-normal-normal.min.css"><link rel="stylesheet" href="/css/fonts/ChineseMono-normal-normal.min.css"><link rel="stylesheet" href="/css/fonts/Chinese-italic-normal.min.css"><link rel="stylesheet" href="/css/fonts/Chinese-normal-bold.min.css"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="本文讲解Dinic算法的思路，算法本身与证明。
关于残余网络和增广路等概念的说明，请看Ford-Fulkerson算法这篇文章。这里只致力于改进Ford-Fulkerson算法，得到一个与$F$无关的算法。
问题
当$F$较大时，影响Ford-Folkerson算法效率的主要因素在于：每次dfs可能"><link rel="alternate" href="../atom.xml" title="Wilson's blog" type="application/atom+xml"><link rel="shortcut icon" href="../favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css"><link rel="stylesheet" href="/katex/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><script defer src="/katex/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script><script defer src="/katex/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="container"><div id="wrap"><div id="nav-outer"><nav id="main-nav" class="outer"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="../index.html">Home</a> <a class="main-nav-link" href="../archives/">Archives</a> <a class="main-nav-link" href="../paper_list/">Paper List</a> <a class="main-nav-link" href="../about/">About</a><div class="main-nav-space-between"></div><a id="nav-rss-link" class="nav-icon" href="../atom.xml" title="RSS 订阅"></a></nav></div><div id="header-title"><h1 id="logo-wrap"><a href="../index.html" id="logo">Wilson&#39;s blog</a></h1></div><div id="content" class="outer"><section id="main"><article id="post-Dinic算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="" class="article-date"><time class="dt-published" datetime="2020-04-26T06:24:27.000Z" itemprop="datePublished">2020-04-26</time></a><div class="article-category"><a class="article-category-link" href="../categories/%E7%AE%97%E6%B3%95/">算法</a></div></div><div class="article-inner"><header class="article-header"><h1 class="p-name article-title" itemprop="headline name">Dinic算法</h1></header><div class="e-content article-entry" itemprop="articleBody"><p>本文讲解Dinic算法的思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>算法本身与证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>关于<strong>残余网络</strong>和<strong>增广路</strong>等概念的说明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请看<a href="Ford-Fulkerson%E7%AE%97%E6%B3%95/" title="Ford-Fulkerson算法">Ford-Fulkerson算法</a>这篇文章<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里只致力于改进Ford-Fulkerson算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到一个与<span class="markdown-them-math-inline">$F$</span>无关的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="问题">问题</h2><p>当<span class="markdown-them-math-inline">$F$</span>较大时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>影响Ford-Folkerson算法效率的主要因素在于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>每次dfs可能可以找到许多条路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是该算法中每次dfs只进行一次增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就导致增广次数与<span class="markdown-them-math-inline">$F$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>可能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>相关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一种想法是一次dfs多次增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但这样做能否成功是取决于dfs顺序的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>dfs顺序如何时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>效率较高呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p><h2 id="思路">思路</h2><p>Dinic算法的核心是每次寻找最短的增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并进行增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样做的理由<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>既是依据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也是好处<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次<strong>沿最短增广路</strong>增广后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><em>最短增广路的长度</em>一定不会减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>稍后会给出证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假如有了这一结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次找到最短增广路的长度时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将该长度的增广路[全部增广]<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后重新寻找最短增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其长度至少增1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而增广路长度不会超过<span class="markdown-them-math-inline">$|V|$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>因为增广路是简单路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而增广次数上界<span class="markdown-them-math-inline">$O(|V|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="证明">证明</h2><p>下面证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次<strong>沿最短增广路</strong>增广后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><em>最短增广路的长度</em>一定不会减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在原图上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为寻找最短增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从<span class="markdown-them-math-inline">$s$</span>出发bfs<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设第一次到达点<span class="markdown-them-math-inline">$v$</span>的边为<span class="markdown-them-math-inline">$\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为点<span class="markdown-them-math-inline">$v$</span>编号<span class="markdown-them-math-inline">$n_v=n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由bfs的特性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><em>每条边增量</em><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>指该边终点与起点编号差<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可为负值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后均同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>不超过1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>特别地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$n_s=0,s$</span>为源点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>称这个图为<strong>分层图</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>此时有结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>若<span class="markdown-them-math-inline">$n_t$</span>被更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么最短增广路的长度为<span class="markdown-them-math-inline">$n_t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>为了证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以寻找为<span class="markdown-them-math-inline">$n_t$</span>标号的边的出发点<span class="markdown-them-math-inline">$i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再寻找为<span class="markdown-them-math-inline">$i$</span>标号的边的出发点<span class="markdown-them-math-inline">$j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>…<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最终会回到<span class="markdown-them-math-inline">$s$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且沿每条边标号增1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于每条边增量不超过1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每条边都增1是从0到<span class="markdown-them-math-inline">$n_t$</span>最快的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而我们找到了<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>一条<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>最短增广路<span class="markdown-them-math-inline">$l_{min}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且每个最短增广路中的每条边<span class="markdown-them-math-inline">$\langle u,v\rangle$</span>都满足<span class="markdown-them-math-inline">$n_v=n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>下面使用数学归纳法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>在<strong>分层图</strong>上沿最短增广路增广1次后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>新图中可能出现一些新的反向边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若新图中有增广路<span class="markdown-them-math-inline">$l'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中的边的来源有两种可能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>1边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>原分层图中的边<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>bfs时经历过的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span><span class="markdown-them-math-inline">$\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足<span class="markdown-them-math-inline">$n_v\leq n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></p><p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>2边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>增广时出现的反向边<span class="markdown-them-math-inline">$\langle v,u\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记原边为<span class="markdown-them-math-inline">$\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么由于原边在最短增广路中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一定满足<span class="markdown-them-math-inline">$n_v=n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>那么<em>沿该路径中任何一条边编号增加</em>不超过1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为了从<span class="markdown-them-math-inline">$0$</span>到达<span class="markdown-them-math-inline">$n_t$</span>仍然至少需要<span class="markdown-them-math-inline">$n_t$</span>条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>长度没有变短<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以最短增广路长度没有减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且所有边都仍满足<span class="markdown-them-math-inline">$n_v\leq n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>假设沿最短增广路增广n次后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最短增广路长度不减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当增广<span class="markdown-them-math-inline">$(n+1)$</span>次后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若图中无增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结论成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若图中仍有增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中的边可能是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>1边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>增广n次后的图中的边<span class="markdown-them-math-inline">$\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足<span class="markdown-them-math-inline">$n_v\leq n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></p><p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>2边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>第<span class="markdown-them-math-inline">$(n+1)$</span>次增广时出现的反向边<span class="markdown-them-math-inline">$\langle v,u\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记原边为<span class="markdown-them-math-inline">$\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么由于原边在最短增广路中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一定满足<span class="markdown-them-math-inline">$n_v=n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>类似于上面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以证明沿最短增广路增广<span class="markdown-them-math-inline">$(n+1)$</span>次后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最短增广路长度仍不减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且所有边都仍满足<span class="markdown-them-math-inline">$n_v\leq n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>综上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>沿最短增广路增广后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><em>最短增广路长度</em>不会减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="优化">优化</h2><p>首先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在证明中我们知道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>最短增广路中的每条边<span class="markdown-them-math-inline">$\langle u,v\rangle$</span>都满足<span class="markdown-them-math-inline">$n_v=n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而我们只考虑<em>递增的边</em>不会出现错误<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>实际上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次分层完后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只要找到增广路就可以增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不必局限在最短增广路中增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是自缚手脚<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只考虑递增的边的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>情况立刻不同了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>图成为了DAG<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span>从而<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>边<span class="markdown-them-math-inline">$\langle u,v\rangle$</span>能否使用只与<span class="markdown-them-math-inline">$v$</span>可达的点<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>记符合条件的点集为<span class="markdown-them-math-inline">$V$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$\forall g \in V$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$n_g&gt;n_v$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的情况有关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而与<span class="markdown-them-math-inline">$s$</span>如何到达<span class="markdown-them-math-inline">$u$</span>无关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果某一时刻发现一条边不能使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么在重新bfs<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即重新标号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>之前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无论其他地方如何增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其后的边流量只会减少不会增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这条边都仍然不能用来增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是可以记录这些边使之只遍历一次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次分层至多访问它们<span class="markdown-them-math-inline">$O(|E|)$</span>次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="算法描述">算法描述</h2><p>下面的算法只是大致的描述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>没有伪代码那么明确<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>重在讲清楚过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>希望我做到了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><blockquote><p><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Dinic算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>输入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>网络<span class="markdown-them-math-inline">$G(V,E)$</span> 输出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>最大流<span class="markdown-them-math-inline">$max\_flow$</span></p><p>步骤0. [准备]建立数组<span class="markdown-them-math-inline">$iter[V]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义<span class="markdown-them-math-inline">$max\_flow\gets0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用邻接表<span class="markdown-them-math-inline">$G[V]$</span>存储网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></p><p>步骤1. [建立分层图]bfs(s,0)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当bfs(u,n)时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若<span class="markdown-them-math-inline">$n_u$</span>已定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>返回<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>否则记<span class="markdown-them-math-inline">$n_u=n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并对<span class="markdown-them-math-inline">$G[u]$</span>中的所有元素<span class="markdown-them-math-inline">$v$</span>进行bfs(v, n+1)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>清零<span class="markdown-them-math-inline">$iter[]$</span>数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>步骤2. [有增广路吗<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>]若<span class="markdown-them-math-inline">$n_t$</span>未定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>退出算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>返回<span class="markdown-them-math-inline">$max\_flow$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>步骤3. [寻找增广路]在<span class="markdown-them-math-inline">$G$</span>上DFS<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>寻找从<span class="markdown-them-math-inline">$s$</span>到<span class="markdown-them-math-inline">$t$</span>的简单路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要求该路径上每条边<span class="markdown-them-math-inline">$e\langle u,v\rangle$</span>可用权值<span class="markdown-them-math-inline">$(w_e-f_e)$</span>大于0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且<span class="markdown-them-math-inline">$n_v&gt;n_u$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若找到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记该路径上的权值最小的边权值为<span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则<span class="markdown-them-math-inline">$f\gets0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>DFS(u)时按顺序遍历<span class="markdown-them-math-inline">$G[u]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若<span class="markdown-them-math-inline">$G[u][i]$</span>不可用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$iter[u]\gets iter[u]+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>步骤4. [找到了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新残余网络]如果<span class="markdown-them-math-inline">$f&gt;0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置<span class="markdown-them-math-inline">$max\_flow\gets max\_flow+f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对路径上的每条边<span class="markdown-them-math-inline">$e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置<span class="markdown-them-math-inline">$f_e\gets f_e+f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记其反向边为<span class="markdown-them-math-inline">$e'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置<span class="markdown-them-math-inline">$w_{e'}\gets w_{e'}+f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>返回步骤3<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>步骤5. [没有找到]如果<span class="markdown-them-math-inline">$f=0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>返回步骤1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><h2 id="复杂度">复杂度</h2><p>由于每次dfs都至少使一条边满流<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>从而使之无法使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>dfs次数上界为<span class="markdown-them-math-inline">$O(|E|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在当前弧优化后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次dfs经过的边有两种可能性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>是无用边<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>在增广路里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>无用边在一次分层内总共访问<span class="markdown-them-math-inline">$O(|E|)$</span>次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>成功增广的情况中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>增广路长度不超过<span class="markdown-them-math-inline">$|V|$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次分层中情况<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的总复杂度上界为<span class="markdown-them-math-inline">$O(|E||V|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而每次分层的复杂度上界为<span class="markdown-them-math-inline">$O(|E||V|+|E|)=O(|E||V|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而Dinic算法总的时间复杂度为<span class="markdown-them-math-inline">$O(|E||V|^2)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="模板">模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V 5005 <span class="comment">//V为顶点最大个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>视数据范围而定</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffffffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    ll to, w, rev;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; G[V];</span><br><span class="line"><span class="type">int</span> num[V], iter[V];</span><br><span class="line"><span class="type">int</span> s, t;<span class="comment">//源点和汇点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">max_flow</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll u, ll f)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(ll from, ll to, ll w)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">max_flow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll f = <span class="number">0</span>, flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(iter, <span class="number">0</span>, <span class="built_in">sizeof</span>(iter));</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">        <span class="keyword">if</span>(num[t] == <span class="number">-1</span>) <span class="keyword">return</span> flow;</span><br><span class="line">        <span class="keyword">while</span>(f = <span class="built_in">dfs</span>(s, INF)) &#123;</span><br><span class="line">            flow += f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll u, ll f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == t) <span class="keyword">return</span> f;</span><br><span class="line">    ll flow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp;i = iter[u]; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        edge &amp;e = G[u][i];<span class="comment">//注意是引用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要直接修改原图</span></span><br><span class="line">        <span class="keyword">if</span>(e.w &gt; <span class="number">0</span> &amp;&amp; num[u] &lt; num[e.to]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flow = <span class="built_in">dfs</span>(e.to, (f &gt; e.w ? e.w : f))) &#123;</span><br><span class="line">                <span class="comment">//min函数有些编译器不给过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以用三目</span></span><br><span class="line">                e.w -= flow;</span><br><span class="line">                <span class="comment">//直接修改容量而非同时记录f和w<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只是为了方便</span></span><br><span class="line">                G[e.to][e.rev].w += flow;</span><br><span class="line">                <span class="keyword">return</span> flow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">-1</span>, <span class="built_in">sizeof</span>(num));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(s);</span><br><span class="line">    num[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            edge &amp;e = G[u][i];</span><br><span class="line">            <span class="keyword">if</span>(e.w &gt; <span class="number">0</span> &amp;&amp; num[e.to] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                num[e.to] = num[u] + <span class="number">1</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(ll from, ll to, ll w)</span> </span>&#123;</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(edge&#123;to, w, G[to].<span class="built_in">size</span>()&#125;);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(edge&#123;from, <span class="number">0</span>, G[from].<span class="built_in">size</span>() - <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有发现模板的错误请联系我指正<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我将不胜感激<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/Dinic%E7%AE%97%E6%B3%95/" rel="tag">Dinic算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/%E6%9C%80%E5%A4%A7%E6%B5%81-%E6%9C%80%E5%B0%8F%E5%89%B2/" rel="tag">最大流&#x2F;最小割</a></li></ul></footer></div><nav id="article-nav"><a href="../CF620D2E/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">CF620D2E</div></a><a href="../%E7%BD%91%E7%BB%9C%E6%B5%81/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">网络流</div></a></nav></article><section id="isso-thread"><noscript>Javascript needs to be activated to view comments.</noscript></section></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2024 Wilson Xia<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/bill-xia/hexo-theme-mashiro" target="_blank">Mashiro</a><br></div></div></footer></div><nav id="mobile-nav"><a href="../index.html" class="mobile-nav-link">Home</a> <a href="../archives/" class="mobile-nav-link">Archives</a> <a href="../paper_list/" class="mobile-nav-link">Paper List</a> <a href="../about/" class="mobile-nav-link">About</a></nav><script src="../js/clipboard.min.js"></script><script src="../js/jquery-1.4.3.min.js"></script><script src="../fancybox/jquery.fancybox-1.3.4.pack.js"></script><script src="../js/script.js"></script><script data-isso="https://isso.wilsonxia.cn" src="https://isso.wilsonxia.cn/js/embed.min.js"></script></div></body></html>