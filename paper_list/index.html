<!DOCTYPE html><html><head><meta charset="utf-8"><title>Paper List | Wilson&#39;s blog</title><link rel="stylesheet" href="/css/fonts/Chinese-normal-normal.min.css"><link rel="stylesheet" href="/css/fonts/ChineseMono-normal-normal.min.css"><link rel="stylesheet" href="/css/fonts/Chinese-italic-normal.min.css"><link rel="stylesheet" href="/css/fonts/Chinese-normal-bold.min.css"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="这里收集一些我喜欢的 paper。按照 topic 分类，大概只会简单评价一下我觉得这篇文章有意思的原因，而不是尝试写读后感。
Congestion Control

Restructuring Endpoint Congestion Control (pdf) 把所有拥塞控制算法归纳为 1) 收集"><link rel="alternate" href="../atom.xml" title="Wilson's blog" type="application/atom+xml"><link rel="shortcut icon" href="../favicon.ico"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="container"><div id="wrap"><div id="nav-outer"><nav id="main-nav" class="outer"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="../index.html">Home</a> <a class="main-nav-link" href="../archives/">Archives</a> <a class="main-nav-link" href="../paper_list/">Paper List</a> <a class="main-nav-link" href="../about/">About</a><div class="main-nav-space-between"></div><a id="nav-rss-link" class="nav-icon" href="../atom.xml" title="RSS 订阅"></a></nav></div><div id="header-title"><h1 id="logo-wrap"><a href="../index.html" id="logo">Wilson&#39;s blog</a></h1></div><div id="content" class="outer"><section id="main"><article id="page-" class="h-entry article article-type-page" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="" class="article-date"><time class="dt-published" datetime="2024-08-11T08:23:18.686Z" itemprop="datePublished">2024-08-11</time></a></div><div class="article-inner"><header class="article-header"><h1 class="p-name article-title" itemprop="headline name">Paper List</h1></header><div class="e-content article-entry" itemprop="articleBody"><p>这里收集一些我喜欢的 paper<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>按照 topic 分类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大概只会简单评价一下我觉得这篇文章有意思的原因<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而不是尝试写读后感<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="congestion-control">Congestion Control</h2><ul><li>Restructuring Endpoint Congestion Control (<a target="_blank" rel="noopener" href="https://people.csail.mit.edu/alizadeh/papers/ccp-sigcomm18.pdf">pdf</a>) 把所有拥塞控制算法归纳为 1) 收集 signal<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>2) 进行决策<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>3) 修改发送速率的统一 workflow<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并尝试实现拥塞控制算法的 write-once, run anywhere<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>目标和方法看起来都非常美好<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实现方式上我感觉硬拉到用户态进程去做有点没必要<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>以及 congeston signal cover 的还是不够全<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如 swift 要求的细粒度 RTT<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不过 CCP 的框架结构定义得很好<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>扩展 signal 应该比较容易<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>Towards provably performant congestion control (<a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/nsdi24-agarwal-anup.pdf">pdf</a>) 尝试用一个带若干参数的网络模型描述网络的行为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后将拥塞控制算法描述为<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>缩小网络模型的参数空间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>很有意思的思考角度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>并且做出了一个综合系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过网络模型的 spec 生成帕累托最优的拥塞控制算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>还没仔细读<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不知道效果如何<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但听起来就很 promising<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>感觉主要的限制<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如果有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>应该是网络模型不够真实<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但我很喜欢这个方法论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>Toward Formally Verifying Congestion Control Behavior (<a target="_blank" rel="noopener" href="https://mina.arashloo.net/docs/ccac.pdf">pdf</a>) 挖坑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>上面的文章引用的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>应该有一部分 insight 来自这里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><h2 id="host-congestion">Host Congestion</h2><ul><li>Host Congestion Control (<a target="_blank" rel="noopener" href="https://www.cs.cornell.edu/~ragarwal/pubs/hostcc.pdf">pdf</a>) 将主板上的总线也看作一个网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且用拥塞控制的视角来看待总线带宽利用不足的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>指出了非常 insightful 的理解与解决主机拥塞的方向<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这篇文章指出 IIO buffer 占用是主机拥塞的一个拥塞信号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且可以简单地通过 ECN 控制网络应用发送速率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或者通过 memory backpressure 控制其他<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>非网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>应用的访存速率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个框架看起来比较初步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且只在简单的 workload 下测试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但可以进一步扩展其他的拥塞信号和控制手段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>看起来方向非常 promising<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>Understanding the Host Network (<a target="_blank" rel="noopener" href="https://www.cs.cornell.edu/~ragarwal/pubs/understanding-the-host-network.pdf">pdf</a>) 同一个组的工作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对主机网络<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>主板上的总线构成的网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>进行更细粒度的建模<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且发现了两种全新的主机拥塞模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>有意思的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>某种意义上他们先<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>解决<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>了问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>理解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>了问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><h2 id="network-os">Network OS</h2><ul><li><p>NetKernel: Making Network Stack Part of the Virtualized Infrastructure (<a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/atc20-niu_0.pdf">pdf</a>) 通过 patch guest OS 来将 socket 调用传给 host<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并通过 host 上另外的 kernel-bypass network stack<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>例如 mTCP<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>来处理这些调用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>提升性能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个劫持的位置很好<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不用修改上层应用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>Demikernel (<a target="_blank" rel="noopener" href="https://irenezhang.net/papers/demikernel-sosp21.pdf">pdf</a>) 这篇文章指出 kernel-bypass I/O 库的现状缺少很多操作系统该做的事情<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>提供统一接口<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>提供应用间调度手段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此需要一个 kernel-bypass OS 来解决 kernel-bypass I/O 库<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如 DPDK/SPDK<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的几个痛点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>1) I/O 代码与设备强绑定<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>难以用统一接口操作异构设备<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>2) 没有易用的 zero-copy 接口和 3) 没有提供合理的调度手段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如 DPDK 要求应用独占内核<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>感觉干的事很重要<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是迁移已有应用的开销有点大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为整个 I/O 接口都变了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要重写应用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></li><li><p>Making Kernel Bypass Practical for the Cloud with Junction (<a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/nsdi24-fried.pdf">pdf</a>) 扎实到恐怖的工作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无论是解决的问题还是解决的方法都是顶级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>目标是支持单机起 4000 个未修改的 Linux 二进制应用而不带来性能下降<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>另有一篇 arXiv (<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2403.03377">pdf</a>) 基于 Junction 实现 containerd 的原位替代<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这篇文章最震撼我的部分就是它无需修改二进制文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>让我相信他能得到部署<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>方法是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>1) 普通容器技术中多个进程在主机看来也是多个进程并且与主机共享 kernel<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而 Junction 做了一个 loader<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将同一个 Instance<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>类似于一个容器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的所有程序加载到同一地址空间内<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个 Instance 在 Host 看来只有一个进程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>但可以有多个线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以利用多核 CPU<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>2) 这一 Instance 内跑了一个用户态 kernel 用来管理网卡和调度 Instance 内的多个程序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且重写了 libc 来将所有的 syscall 重定向到这个用户态 kernel<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>3) 做了一系列调度的优化和 NIC buffer 的优化来解决 scale 到多 Instance 过程中遇到的挑战<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>还有一些安全方面的考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里就不赘述了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>最终测试了多个未经修改的 Linux 二进制文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>真是太酷了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span></p><blockquote><p>一个有意思的问题是比较 Junction 和 NetKernel 的优劣<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>它们都实现了二进制兼容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且都假设二进制文件的编译目标是 Linux 内核<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我简单思考的结论是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>两者的区别还是落在了容器和虚拟机的区别上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>Junction 更像容器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只要求用户提供要执行的程序的二进制文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而 NetKernel 针对虚拟机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即用户提供一个完整 kernel 的场景<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此带机量上 Junction 应该能更多<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>实际上 NetKernel 并没有针对带机量做优化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>直觉上 NetKernel 需要过硬件虚拟化因此更慢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而 Junction 甚至因为同一 Instance 内的程序共享地址空间能省一些 context switch 时的 TLB miss<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>并且 Junction 对应用语义了解得更全面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此能做更细粒度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>更高效的调度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但同时也可能有 noisy neighbor 问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>总之隔离力度比虚拟机方法弱一些<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote></li></ul></div><footer class="article-footer"></footer></div></article></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2024 Wilson Xia<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/bill-xia/hexo-theme-mashiro" target="_blank">Mashiro</a><br></div></div></footer></div><nav id="mobile-nav"><a href="../index.html" class="mobile-nav-link">Home</a> <a href="../archives/" class="mobile-nav-link">Archives</a> <a href="../paper_list/" class="mobile-nav-link">Paper List</a> <a href="../about/" class="mobile-nav-link">About</a></nav><script defer src="../js/clipboard.min.js"></script><script defer src="../js/jquery-1.4.3.min.js"></script><script defer src="../fancybox/jquery.fancybox-1.3.4.pack.js"></script><script defer src="../js/script.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css" media="none" onload='"all"!=media&&(media="all")'><link rel="stylesheet" href="/katex/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous" media="none" onload='"all"!=media&&(media="all")'><script defer src="/katex/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script><script defer src="/katex/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script></div></body></html>