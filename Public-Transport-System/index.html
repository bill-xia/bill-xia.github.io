<!DOCTYPE html><html><head><meta charset="utf-8"><title>Public Transport System | Wilson&#39;s blog</title><link rel="stylesheet" href="../css/fonts/Chinese-normal-normal.min.css"><link rel="stylesheet" href="../css/fonts/ChineseMono-normal-normal.min.css"><link rel="stylesheet" href="../css/fonts/Chinese-italic-normal.min.css"><link rel="stylesheet" href="../css/fonts/Chinese-normal-bold.min.css"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="题意
给定一个有向图，每条边有边权$a_e$和$b_e$，$0&amp;lt;a_e,b_e;\;b_e&amp;lt;a_e$。记一条路径由$k$条边$e_1,e_2,...,e_k$组成，那么这条路径中，边$e_1$的权值为$a_{e_1}$，$e_i(i&amp;gt;1)$的权值为：
$$\begin{cases}
a_{e_i}&amp;amp;a_{e_i}\leq a_{e_{i-1}},\\
a_{e_{i}}-b_{e_i}&amp;amp;a_{e_i}&amp;gt;a_{e_{i-1}}.
\end{cases}
$$这条路径的权值是这条路径上边的权值之和。求从点$1$出发到所有点的最短路长度。
$$\begin{align*}
n\leq 1\times10^5,\ m\leq 2\times10^5.
\end{align*}
$$"><link rel="alternate" href="../atom.xml" title="Wilson's blog" type="application/atom+xml"><link rel="shortcut icon" href="../favicon.ico"><link rel="stylesheet" href="../css/style.css"><link rel="stylesheet" href="../fancybox/jquery.fancybox-1.3.4.css"><link rel="stylesheet" href="../katex/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><script defer src="../katex/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script><script defer src="../katex/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="container"><div id="wrap"><div id="nav-outer"><nav id="main-nav" class="outer"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/">Home</a> <a class="main-nav-link" href="/archives/">Archives</a> <a class="main-nav-link" href="/paper_list/">Paper List</a> <a class="main-nav-link" href="/about/">About</a><div class="main-nav-space-between"></div><a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a></nav></div><div id="header-title"><h1 id="logo-wrap"><a href="../index.html" id="logo">Wilson&#39;s blog</a></h1></div><div id="content" class="outer"><section id="main"><article id="post-Public-Transport-System" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="" class="article-date"><time class="dt-published" datetime="2021-10-14T09:36:16.000Z" itemprop="datePublished">2021-10-14</time></a><div class="article-category"><a class="article-category-link" href="../categories/%E9%A2%98%E8%A7%A3/">题解</a></div></div><div class="article-inner"><header class="article-header"><h1 class="p-name article-title" itemprop="headline name">Public Transport System</h1></header><div class="e-content article-entry" itemprop="articleBody"><h2 id="题意">题意</h2><p>给定一个有向图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每条边有边权<span class="markdown-them-math-inline">$a_e$</span>和<span class="markdown-them-math-inline">$b_e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$0&lt;a_e,b_e;\;b_e&lt;a_e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记一条路径由<span class="markdown-them-math-inline">$k$</span>条边<span class="markdown-them-math-inline">$e_1,e_2,...,e_k$</span>组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么这条路径中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>边<span class="markdown-them-math-inline">$e_1$</span>的权值为<span class="markdown-them-math-inline">$a_{e_1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$e_i(i&gt;1)$</span>的权值为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{cases} a_{e_i}&amp;a_{e_i}\leq a_{e_{i-1}},\\ a_{e_{i}}-b_{e_i}&amp;a_{e_i}&gt;a_{e_{i-1}}. \end{cases} $$</div><p>这条路径的权值是这条路径上边的权值之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>求从点<span class="markdown-them-math-inline">$1$</span>出发到所有点的最短路长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{align*} n\leq 1\times10^5,\ m\leq 2\times10^5. \end{align*} $$</div><span id="more"></span><h2 id="思路">思路</h2><p>思路有两种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一种是修改图使得新图的朴素最短路等价于旧图上定义的最短路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一种是修改单源最短路算法使之能够解决本题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="总结一点经验">总结一点经验</h3><p>正解是第一种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而我队赛中花了很多时间在第二种思路上想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且如果没有某人与牛逼队伍大声白嫖思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我队会在第二种思路上想到比赛结束<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>感觉对于这种<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>前景不甚光明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>的题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>应该在具体的思考之前考虑有几种路线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或者<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>进行高层次的思考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或者在思考没有进展的时候及时拓展思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我队实际上思路被蒙蔽了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>队友读完题立刻口胡了一个魔改<code>dijkstra</code>的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后我们直接开始大力思考细节<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后钻进了这个死胡同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>感觉正确的做法是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>打算开这个题的人<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个人读完题都先厘清几条路线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后两个人交流一下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再决定仔细想哪个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>其实两种思路的边界似乎也没有这么清晰<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>做不出来的本质原因还是笨吧<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span></p><h3 id="修改最短路算法">修改最短路算法</h3><p>对每个节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义若干个状态<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>入边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实际上这些状态和入边是一一对应的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即全图所有状态和全图所有边能一一对应<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对每个状态维护由<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>入边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>来到这个<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>的最短路径长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后试图在这些状态上跑dijkstra<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其实是对原图的节点做dp<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>假定现在已知原图中某个节点的全部状态的值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>尝试通过出边更新其他状态的值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对该节点的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>们分析发现这是个单调栈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>路径距离又长<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>入边边权又大的状态是没用的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后就可以将状态组织成一个入边边权递增<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>路径距离递减的序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后对每条出边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在这个序列里二分查找第一个入边边权小于出边边权的状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用这一个和最后一个状态<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>不使出边边权减少的入边中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>路径距离最短的那个状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>一起更新出边指向的状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>时间复杂度两个<span class="markdown-them-math-inline">$\log$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>只差一步了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是转移的顺序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是这个图不是DAG<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而每次转移都要用到所有入边的信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在我的认知范围内不太好搞出转移的顺序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>事实上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我认为每个点经历一次是无法转移出正确答案的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为最优路径可能会经过一个圈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span>例如一个图</p><div class="highlight"><pre class="code"><code><span class="hljs-attribute">1</span>-&gt;<span class="hljs-number">2</span> a:<span class="hljs-number">100</span> b:<span class="hljs-number">99</span>
<span class="hljs-attribute">1</span>-&gt;<span class="hljs-number">3</span> a:<span class="hljs-number">1</span> b:<span class="hljs-number">0</span>
<span class="hljs-attribute">3</span>-&gt;<span class="hljs-number">1</span> a:<span class="hljs-number">1</span> b:<span class="hljs-number">0</span>
</code></pre></div><p>从1到2的最优路径是<code>1-&gt;3-&gt;1-&gt;2</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>感觉上讲<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可能有某种<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>松弛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>操作可以完成这个事<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是感觉复杂度不太有保证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>都是感觉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p><p>这就是我们思考的终点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="修改图">修改图</h3><p>修改图的意思就是修改图使得原问题变成新图上裸的单源最短路问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>修改图的目的是消去计算边权时的判断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>其实我们的思考也没有结束<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们尝试把这些状态作为点来建图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这应该离正解很近了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>赛中也确实注意到了单调栈这件事<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但我们赛中所想的建图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是对入边的起点和出边的终点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跨过中间的点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>连一个新的边权的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>认为这个建图一定是<span class="markdown-them-math-inline">$O(m^2)$</span>的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其实不然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>需要注意到这样一件事<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>能用于更新某条出边的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也能用于更新边权更大的出边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果注意到了这一点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就不难将上面的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>伪算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>优化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>到一个<span class="markdown-them-math-inline">$\log$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即双指针分别遍历入边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>出边序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>我赛中思考了新图应有的特征<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>可能会通过一些辅助节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过在辅助节点处的分支来消灭边权的<code>if</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取而代之以两条<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>权限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>不同的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>大概是没意识到单调对这个做法的优化作用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且不太清楚这个分支怎么实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以赛中没有把它转化为可用的东西<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只是抽象的概念<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>实际上它们是连在一起的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>单调性成就了这个分支的实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>现在说正解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>正解的做法就是对原图中的每个点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>建立一些<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>特权节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它们<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>的出边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>走的是减去了<span class="markdown-them-math-inline">$b$</span>以后的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后只把有这个权限的入边连向这个特权节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>根据上面的单调性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>感到应该为<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>特权节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而排序的依据是出边的<span class="markdown-them-math-inline">$a$</span>值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$a$</span>值越小权限越高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>所以每个特权节点应当只有一条出边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这才便于排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>按照<span class="markdown-them-math-inline">$a$</span>值从小到大排序之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为每个特权节点向排名其后的点连一条0边<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>感觉我实际上卡在了这里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果能有0边的灵感应该是能想出来的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>排名最后的特权节点指向原图中的点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>最后给原图的点加上边权为<span class="markdown-them-math-inline">$a$</span>值的那些出边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>总结一下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对每个原图点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>建若干特权节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>与出边一一对应<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每个特权节点只有一条边权为<span class="markdown-them-math-inline">$a-b$</span>的出边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>原图中的点有所有边权为<span class="markdown-them-math-inline">$a$</span>的出边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>它们指向哪里呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>对给定的一条出边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>答案是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>这条出边的终点的<em>特权节点+原图点</em>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它刚好有权限的那个点<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>特权节点或原图节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即给定出边的边权恰好小于<em>出边终点的出边</em>的边权<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>要完成这件事应当将一个节点的特权节点按其出边的<span class="markdown-them-math-inline">$a$</span>从小到大排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再在结尾添上一个原图节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在这个序列中二分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>令特权节点与入边一一对应看起来有一定的单调性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但应该是不可做的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为它并没有解决出边边权的分支问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="ac代码">AC代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 100005</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3fLL</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span>
    ll from, to, a, b;
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> edge&amp; e_) <span class="hljs-keyword">const</span> &#123;
        <span class="hljs-keyword">return</span> a &lt; e_.a;
    &#125;
&#125;;
<span class="hljs-keyword">typedef</span> vector&lt;edge&gt; ve;
<span class="hljs-keyword">typedef</span> pair&lt;ll, ll&gt; pll;
ve nodeList[maxn];
ve G[maxn * <span class="hljs-number">3</span>];
ll cnt;
ll d[maxn * <span class="hljs-number">3</span>], ans[maxn];
ll demap[maxn * <span class="hljs-number">3</span>];
priority_queue&lt;pll, vector&lt;pll&gt;, greater&lt;pll&gt; &gt; pq;
<span class="hljs-keyword">bool</span> vis[maxn * <span class="hljs-number">3</span>];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);
    ll T, n, m;
    cin &gt;&gt; T;
    <span class="hljs-keyword">while</span> (T-- &gt; <span class="hljs-number">0</span>) &#123;
        cin &gt;&gt; n &gt;&gt; m;
        <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;
            nodeList[i].<span class="hljs-built_in">clear</span>();
            ans[i] = INF;
            demap[i] = i;
        &#125;
        <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n + m; ++i) &#123;
            G[i].<span class="hljs-built_in">clear</span>();
            vis[i] = <span class="hljs-literal">false</span>;
            d[i] = INF;
        &#125;
        cnt = n;
        <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;
            ll u, v, a, b;
            cin &gt;&gt; u &gt;&gt; v &gt;&gt; a &gt;&gt; b;
            cnt += <span class="hljs-number">1</span>;
            demap[cnt] = u;
            nodeList[u].<span class="hljs-built_in">push_back</span>(edge&#123;cnt, v, a, b&#125;);
        &#125;
        <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;
            <span class="hljs-built_in">sort</span>(nodeList[i].<span class="hljs-built_in">begin</span>(), nodeList[i].<span class="hljs-built_in">end</span>());
        &#125;
        <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;
            <span class="hljs-keyword">for</span> (ll j = <span class="hljs-number">0</span>; j &lt; nodeList[i].<span class="hljs-built_in">size</span>(); ++j) &#123;
                edge &amp;e = nodeList[i][j];
                <span class="hljs-keyword">auto</span> iter = <span class="hljs-built_in">upper_bound</span>(nodeList[e.to].<span class="hljs-built_in">begin</span>(), nodeList[e.to].<span class="hljs-built_in">end</span>(), e);
                <span class="hljs-keyword">if</span> (iter == nodeList[e.to].<span class="hljs-built_in">end</span>()) &#123;
                    G[i].<span class="hljs-built_in">push_back</span>(edge&#123;i, e.to, e.a, <span class="hljs-number">-1</span>&#125;); <span class="hljs-comment">// -1 in this new edge is useless</span>
                &#125; <span class="hljs-keyword">else</span> &#123;
                    G[i].<span class="hljs-built_in">push_back</span>(edge&#123;i, iter-&gt;from, e.a, <span class="hljs-number">-1</span>&#125;);
                &#125;
                e.a -= e.b;
                <span class="hljs-keyword">if</span> (iter == nodeList[e.to].<span class="hljs-built_in">end</span>()) &#123;
                    G[e.from].<span class="hljs-built_in">push_back</span>(edge&#123;e.from, e.to, e.a, <span class="hljs-number">-1</span>&#125;); <span class="hljs-comment">// -1 in this new edge is useless</span>
                &#125; <span class="hljs-keyword">else</span> &#123;
                    G[e.from].<span class="hljs-built_in">push_back</span>(edge&#123;e.from, iter-&gt;from, e.a, <span class="hljs-number">-1</span>&#125;);
                &#125;
                <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> != nodeList[i].<span class="hljs-built_in">size</span>()) &#123;
                    G[e.from].<span class="hljs-built_in">push_back</span>(edge&#123;e.from, nodeList[i][j + <span class="hljs-number">1</span>].from, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    G[e.from].<span class="hljs-built_in">push_back</span>(edge&#123;e.from, i, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;);
                &#125;
                e.a += e.b;
            &#125;
        &#125;
        d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
        pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pll</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));
        <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;
            pll top = pq.<span class="hljs-built_in">top</span>(); pq.<span class="hljs-built_in">pop</span>();
            ll u = top.second, dis = top.first;
            <span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">continue</span>;
            vis[u] = <span class="hljs-literal">true</span>;
            d[u] = dis;
            ans[demap[u]] = <span class="hljs-built_in">min</span>(ans[demap[u]], dis);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : G[u]) &#123;
                ll v = e.to;
                <span class="hljs-keyword">if</span> (dis + e.a &lt; d[v]) &#123;
                    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pll</span>(dis + e.a, v));
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;
            cout &lt;&lt; (ans[i] == INF ? <span class="hljs-number">-1</span> : ans[i]) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;
        &#125;
        cout &lt;&lt; (ans[n] == INF ? <span class="hljs-number">-1</span> : ans[n]) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre></div></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/%E5%BB%BA%E5%9B%BE/" rel="tag">建图</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/%E6%80%9D%E7%BB%B4/" rel="tag">思维</a></li></ul></footer></div><nav id="article-nav"><a href="../%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">二分图匹配</div></a><a href="../Charged-Tree/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">Charged Tree</div></a></nav></article></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2024 Wilson Xia<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/bill-xia/hexo-theme-mashiro" target="_blank">Mashiro</a><br></div></div></footer></div><nav id="mobile-nav"><a href="/" class="mobile-nav-link">Home</a> <a href="/archives/" class="mobile-nav-link">Archives</a> <a href="/paper_list/" class="mobile-nav-link">Paper List</a> <a href="/about/" class="mobile-nav-link">About</a></nav><script src="../js/clipboard.min.js"></script><script src="../js/jquery-1.4.3.min.js"></script><script src="../fancybox/jquery.fancybox-1.3.4.pack.js"></script><script src="../js/script.js"></script></div></body></html>