<!DOCTYPE html><html><head><meta charset="utf-8"><title>CF Edu123 题解 | Wilson&#39;s blog</title><link rel="stylesheet" href="/css/fonts/Chinese-normal-normal.min.css"><link rel="stylesheet" href="/css/fonts/ChineseMono-normal-normal.min.css"><link rel="stylesheet" href="/css/fonts/Chinese-italic-normal.min.css"><link rel="stylesheet" href="/css/fonts/Chinese-normal-bold.min.css"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="F. Basis
题面
考虑一群在操作 2 下可以互相变换的数组，在其中可以取一个代表元$arr$。假设$arr$由$i$种数字组成，把$arr$中数字$j$所在的下标的集合记作$S_j$，则这一群数组可以用集合的集合$\{S_1,S_2,...,S_i\}$来表示，称为一个原型。如果只能做操作2，"><link rel="alternate" href="../atom.xml" title="Wilson's blog" type="application/atom+xml"><link rel="shortcut icon" href="../favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css"><link rel="stylesheet" href="/katex/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><script defer src="/katex/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script><script defer src="/katex/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="container"><div id="wrap"><div id="nav-outer"><nav id="main-nav" class="outer"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="../index.html">Home</a> <a class="main-nav-link" href="../archives/">Archives</a> <a class="main-nav-link" href="../paper_list/">Paper List</a> <a class="main-nav-link" href="../about/">About</a><div class="main-nav-space-between"></div><a id="nav-rss-link" class="nav-icon" href="../atom.xml" title="RSS 订阅"></a></nav></div><div id="header-title"><h1 id="logo-wrap"><a href="../index.html" id="logo">Wilson&#39;s blog</a></h1></div><div id="content" class="outer"><section id="main"><article id="post-CF-Edu123-题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="" class="article-date"><time class="dt-published" datetime="2022-03-07T13:47:25.000Z" itemprop="datePublished">2022-03-07</time></a><div class="article-category"><a class="article-category-link" href="../categories/%E9%A2%98%E8%A7%A3/">题解</a></div></div><div class="article-inner"><header class="article-header"><h1 class="p-name article-title" itemprop="headline name">CF Edu123 题解</h1></header><div class="e-content article-entry" itemprop="articleBody"><h2 id="f-basis">F. Basis</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1644/problem/F">题面</a></p><p>考虑一群在操作 2 下可以互相变换的数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在其中可以取一个代表元<span class="markdown-them-math-inline">$arr$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假设<span class="markdown-them-math-inline">$arr$</span>由<span class="markdown-them-math-inline">$i$</span>种数字组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>把<span class="markdown-them-math-inline">$arr$</span>中数字<span class="markdown-them-math-inline">$j$</span>所在的下标的集合记作<span class="markdown-them-math-inline">$S_j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则这一群数组可以用集合的集合<span class="markdown-them-math-inline">$\{S_1,S_2,...,S_i\}$</span>来表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>称为一个<em>原型</em><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果只能做操作2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>答案就是第二类斯特林数<span class="markdown-them-math-inline">$\left\{n\atop i\right\}$</span>的前缀和<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>对<span class="markdown-them-math-inline">$i$</span>从1加到<span class="markdown-them-math-inline">$\min(k,n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>出于后面的实现方便<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将对<span class="markdown-them-math-inline">$i$</span>从2加到<span class="markdown-them-math-inline">$\min(k,n)$</span>的前缀和记作<span class="markdown-them-math-inline">$A(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这可以用<span class="markdown-them-math-inline">$O(n\log n)$</span>的复杂度来求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具体见<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/combinatorics/stirling/#_3">oi-wiki</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>接下来考虑操作1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们发现刚才找到的那些代表元当中有些可以经操作1生成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现在来删除它们<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>将原型<span class="markdown-them-math-inline">$arr$</span>改写成<em>连续的相同数个数的数组</em>的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记作<span class="markdown-them-math-inline">$arr'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如将<span class="markdown-them-math-inline">$1,1,2,2,3$</span>改写成<span class="markdown-them-math-inline">$2,2,1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ol><li>如果<span class="markdown-them-math-inline">$arr'$</span>只有一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是说<span class="markdown-them-math-inline">$arr$</span>中全都是相同的数字<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们发现<span class="markdown-them-math-inline">$arr$</span>一定可以由某个<em>改写前有至少两个不同数的原型</em>经一次操作1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$F(a, n)$</span>生成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是不用对<span class="markdown-them-math-inline">$arr$</span>计数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>也就是说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>题目中给的<span class="markdown-them-math-inline">$k&gt;1$</span>时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不用考虑这种情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果<span class="markdown-them-math-inline">$k=1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>输出1即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>如果<span class="markdown-them-math-inline">$arr'$</span>不只有一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>去掉<span class="markdown-them-math-inline">$arr'$</span>的最后一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考察前面的那些数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果它们的<span class="markdown-them-math-inline">$gcd$</span>不为1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则<span class="markdown-them-math-inline">$arr$</span>可以被别的原型由操作1生成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不用对<span class="markdown-them-math-inline">$arr$</span>计数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对一个<span class="markdown-them-math-inline">$gcd$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有<span class="markdown-them-math-inline">$A(\lceil {n\over gcd}\rceil)$</span>个原型可以被别的原型<span class="markdown-them-math-inline">$a$</span>生成<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>将<span class="markdown-them-math-inline">$arr$</span>中每连续<span class="markdown-them-math-inline">$gcd$</span>个数绑定<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再计算原型数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是<span class="markdown-them-math-inline">$A(\lceil {n\over gcd}\rceil)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>注意<span class="markdown-them-math-inline">$A$</span>是从2开始加的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为数字全部相同的原型并不能由操作1生成<span class="markdown-them-math-inline">$arr$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果这个<span class="markdown-them-math-inline">$gcd$</span>是合数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可能这些冗余数组会被它的因子删除多次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要控制这个次数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解决方法是用mobius函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>就是说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对<span class="markdown-them-math-inline">$gcd$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们计<span class="markdown-them-math-inline">$\mu(gcd)$</span>次<span class="markdown-them-math-inline">$A(\lceil {n\over gcd}\rceil)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ol><p>这里的mobius函数就是在对<span class="markdown-them-math-inline">$gcd$</span>的质因子集合<span class="markdown-them-math-inline">$S$</span>做容斥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>质因子集合<span class="markdown-them-math-inline">$S$</span>的子集<span class="markdown-them-math-inline">$S'\subset S$</span>可以与那些<em>各质因子至多出现一次的<span class="markdown-them-math-inline">$gcd$</span>的因子</em>建立一一映射<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个子集中有奇数个因子就取<span class="markdown-them-math-inline">$-1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>偶数个因子就取<span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有质因子出现2次就取0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>子集为空集时<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>对应于因子1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>也取1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对一个给定的<span class="markdown-them-math-inline">$gcd$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那些能经操作1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$F(a, gcd)$</span>生成的原型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可以被<span class="markdown-them-math-inline">$gcd$</span>的因子<span class="markdown-them-math-inline">$d$</span>们经操作1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$F(F(a,d), gcd/d)$</span>生成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每个这样的原型被计了多少次呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>答案是</p><div class="markdown-them-math-block">$$\sum_{d|gcd}\mu(d)=\sum_{S'\subset S}(-1)^{|S'|}=\sum_{i=0}^{|S|}\binom{|S|}{i}(-1)^{i}\times 1^{|S|-i}=(-1+1)^{|S|}=[gcd=1] $$</div><p>也就是实现了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若<span class="markdown-them-math-inline">$arr'$</span>除去最后一块外的所有数互质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$arr$</span>就属于<strong>基</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则不属于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这结束了我们的讨论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>关于<span class="markdown-them-math-inline">$0^0$</span>不等式和<span class="markdown-them-math-inline">$[gcd=1]$</span>的讨论可以和<a href="Trie%E6%A0%91%E7%BB%B4%E6%8A%A4%E9%9B%86%E5%90%88%E7%9B%B8%E4%BA%A4%E6%80%A7/" title="Trie树维护集合相交性">Trie树维护集合相交性</a>相类比<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>最后的答案是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\sum_{gcd=1}^n\mu(gcd)A\left(\left\lceil\dfrac{n}{gcd}\right\rceil\right) $$</div><p>直接整除分块求这个东西的一个上界是</p><div class="markdown-them-math-block">$$O(\sum_{gcd=1}^n\dfrac{n\log n}{gcd})=O(n\log n\sum_{d=1}^n\dfrac{1}{d})=O(n\log^2 n) $$</div><p>注意不是<span class="markdown-them-math-inline">$O(n\sqrt{n}\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们还可以合并同一个<span class="markdown-them-math-inline">$\left\lceil\dfrac{n}{gcd}\right\rceil$</span>对应的所有<span class="markdown-them-math-inline">$\mu(gcd)$</span>之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>前缀和或者开桶统计一下就行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于后面那个求和只有其中的<span class="markdown-them-math-inline">$\sqrt{n}$</span>项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可能还达不到<span class="markdown-them-math-inline">$\log n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以理解为常数很小的<span class="markdown-them-math-inline">$\log n$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>经测试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对<span class="markdown-them-math-inline">$n=10^5$</span>该和为6.83<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"><section id="isso-thread"><noscript>Javascript needs to be activated to view comments.</noscript></section><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" rel="tag">容斥原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/" rel="tag">斯特林数</a></li></ul></footer></div><nav id="article-nav"><a href="../6-824-Lab1-MapReduce/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">6.824 Lab1 MapReduce</div></a><a href="../Trie%E6%A0%91%E7%BB%B4%E6%8A%A4%E9%9B%86%E5%90%88%E7%9B%B8%E4%BA%A4%E6%80%A7/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">Trie树维护集合相交性</div></a></nav></article></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2024 Wilson Xia<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/bill-xia/hexo-theme-mashiro" target="_blank">Mashiro</a><br></div></div></footer></div><nav id="mobile-nav"><a href="../index.html" class="mobile-nav-link">Home</a> <a href="../archives/" class="mobile-nav-link">Archives</a> <a href="../paper_list/" class="mobile-nav-link">Paper List</a> <a href="../about/" class="mobile-nav-link">About</a></nav><script src="../js/clipboard.min.js"></script><script src="../js/jquery-1.4.3.min.js"></script><script src="../fancybox/jquery.fancybox-1.3.4.pack.js"></script><script src="../js/script.js"></script><script data-isso="https://isso.wilsonxia.cn" src="https://isso.wilsonxia.cn/js/embed.min.js"></script></div></body></html>