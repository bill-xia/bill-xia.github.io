<!DOCTYPE html><html><head><meta charset="utf-8"><title>Wilson&#39;s blog</title><link rel="stylesheet" href="../../css/fonts/Chinese-normal-normal.min.css"><link rel="stylesheet" href="../../css/fonts/ChineseMono-normal-normal.min.css"><link rel="stylesheet" href="../../css/fonts/Chinese-italic-normal.min.css"><link rel="stylesheet" href="../../css/fonts/Chinese-normal-bold.min.css"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="alternate" href="../../atom.xml" title="Wilson's blog" type="application/atom+xml"><link rel="shortcut icon" href="../../favicon.ico"><link rel="stylesheet" href="../../css/style.css"><link rel="stylesheet" href="../../fancybox/jquery.fancybox-1.3.4.css"><link rel="stylesheet" href="../../katex/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><script defer src="../../katex/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script><script defer src="../../katex/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="container"><div id="wrap"><div id="nav-outer"><nav id="main-nav" class="outer"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/">Home</a> <a class="main-nav-link" href="/archives/">Archives</a> <a class="main-nav-link" href="/paper_list/">Paper List</a> <a class="main-nav-link" href="/about/">About</a><div class="main-nav-space-between"></div><a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a></nav></div><div id="header-title"><h1 id="logo-wrap"><a href="../../index.html" id="logo">Wilson&#39;s blog</a></h1></div><div id="content" class="outer"><section id="main"><article id="post-在Linux上使用clash" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../%E5%9C%A8Linux%E4%B8%8A%E4%BD%BF%E7%94%A8clash/" class="article-date"><time class="dt-published" datetime="2022-01-21T03:31:11.000Z" itemprop="datePublished">2022-01-21</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E5%B7%A5%E5%85%B7/">工具</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../%E5%9C%A8Linux%E4%B8%8A%E4%BD%BF%E7%94%A8clash/">在Linux上使用clash</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>我火星了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有现成的GUI…请使用<a target="_blank" rel="noopener" href="https://github.com/Fndroid/clash_for_windows_pkg/releases">Clash for Windows</a>的Linux版本<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><ol><li>在<a target="_blank" rel="noopener" href="https://github.com/Fndroid/clash_for_windows_pkg/releases">release页面</a>下载<code>Clash.for.Windows-0.x.x-x64-linux.tar.gz</code></li><li>解压后执行<code>./cfw</code></li><li>为了脱离命令行运行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请看<a target="_blank" rel="noopener" href="https://github.com/Fndroid/clash_for_windows_pkg/issues/2107">issue</a></li></ol><hr><p>以下为原文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>以<a target="_blank" rel="noopener" href="https://panel.touhou.tel/auth/register?code=jXeZ">东方网络</a>为例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>按照机场默认的配置使用clash<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果不够满意<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>大概率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>参考<a target="_blank" rel="noopener" href="https://clash.gitbook.io/doc/restful-api">API文档</a>再稍微写一些代码就可以进行规则与节点的配置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>待更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="步骤">步骤</h2><ol><li>在<a target="_blank" rel="noopener" href="https://github.com/Dreamacro/clash/releases/">releases</a>页面中下载最新版clash内核<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一般的64位机器下载amd64版本即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>解压后为一个可执行文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>重命名为<code>clash</code>后执行<code>chmod +x clash</code>为其加上执行权限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>在机场网站上下载配置文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>命名为<code>config.yaml</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>执行<code>./clash -t -f config.yaml</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果没有问题说明配置文件正确<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>执行<code>./clash -f config.yaml</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>开启代理服务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>配置系统代理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>选择&quot;use manually specified proxy configuration&quot;<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>填入代理日志显示的代理地址+端口号</li><li>配置浏览器使用系统代理/配置浏览器代理指向clash<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>现在应该已经可以访问google了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果不行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>检查配置文件的mode<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果是direct<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>改成rule或者global<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>按照<a target="_blank" rel="noopener" href="https://github.com/Dreamacro/clash/wiki/clash-as-a-daemon">官方wiki</a>的步骤将其配置为守护进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ol><p>这样就足以支持日常需求了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"></footer></div></article><article id="post-页面调度算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" class="article-date"><time class="dt-published" datetime="2022-01-07T04:31:38.000Z" itemprop="datePublished">2022-01-07</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/">页面调度算法</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><h2 id="最优调度算法为什么最优">最优调度算法为什么最优</h2><p>我们发现换页时换入的页总是固定的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们要挑选的是换出的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>优先换出不再被访问的页面是显然的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>首先注意换出的页面在下次访问时是一定会被换入的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只要考虑没被换出的页面有没有离开即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果不用最优调度算法换出A<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而换出一个下次访问更早的页面B<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>如果A在下次访问A前未被调出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么换出A仍能使得下次访问B前B未被调出</li><li>如果A在下次访问A前被调出了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么换出A有可能可以使得B不用被调出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为B的下次访问更早</li></ul><p>于是换出A一定不比换出B差<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无论换出B后采用什么策略<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="堆栈式算法">堆栈式算法</h2><p>堆栈式算法是指<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>访问第<span class="markdown-them-math-inline">$t$</span>个页面时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑驻留集大小为<span class="markdown-them-math-inline">$n$</span>时的驻留集<span class="markdown-them-math-inline">$S$</span>和驻留集大小为<span class="markdown-them-math-inline">$n+1$</span>时的驻留集<span class="markdown-them-math-inline">$S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果可以证明在某种调度算法下无论对什么输入下的哪个<span class="markdown-them-math-inline">$t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都有<span class="markdown-them-math-inline">$S\subset S'$</span>成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么这个调度算法就是堆栈式算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="堆栈式算法的好处">堆栈式算法的好处</h3><p>这种算法没有Belady现象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>页框增加时缺页中断次数不会增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>页框增加时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于任何时刻<span class="markdown-them-math-inline">$S\subset S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$P\notin S'\Rightarrow P\notin S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即<em>某页在页框多时缺页</em><span class="markdown-them-math-inline">$\Rightarrow$</span><em>该页在页框少时也缺页</em><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>缺页中断次数不会更少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="最优调度算法/lru为什么是堆栈式算法">最优调度算法/LRU为什么是堆栈式算法</h3><p>用数学归纳法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>初始时<span class="markdown-them-math-inline">$S=S'=\emptyset$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>假设对某个访问序列满足<span class="markdown-them-math-inline">$S\subset S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现在再访问一页<span class="markdown-them-math-inline">$P$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>若<span class="markdown-them-math-inline">$P\notin S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$P\notin S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时产生缺页中断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设在<span class="markdown-them-math-inline">$S$</span>中换出页<span class="markdown-them-math-inline">$P_1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$S'$</span>中换出<span class="markdown-them-math-inline">$P_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对OPT/LRU中的每一种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么<span class="markdown-them-math-inline">$P_2\in S'-S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么<span class="markdown-them-math-inline">$P_1=P_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无论哪种情形<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>换出页后仍满足<span class="markdown-them-math-inline">$S\subset S'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>综上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对任意输入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这两种算法都是堆栈式算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>这个证明的核心在于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>要么<span class="markdown-them-math-inline">$P_2\in S'-S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么<span class="markdown-them-math-inline">$P_1=P_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>看到网上的一个理解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>说是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>给驻留集里的页面一个与<span class="markdown-them-math-inline">$n$</span>无关的优先级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>选择优先级最高的那个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是不会选择<span class="markdown-them-math-inline">$S-\{P_1\}$</span>中的元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对FIFO算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个优先级是进入时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后我们会发现这个东西不完全取决于驻留集这个集合本身<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还取决于它进入驻留集的时刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>有可能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>驻留集小时的缺页导致一个页面换出后再次换入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但驻留集大时则总是驻留<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而它在驻留集小时优先级低而驻留集大时优先级高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时有可能<span class="markdown-them-math-inline">$P_2$</span>是那个<span class="markdown-them-math-inline">$S'$</span>中总是驻留的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而<span class="markdown-them-math-inline">$P_1$</span>是其他的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是这个<span class="markdown-them-math-inline">$P_2$</span>现在仍在<span class="markdown-them-math-inline">$S$</span>中而不在<span class="markdown-them-math-inline">$S'$</span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"></footer></div></article><article id="post-二分图匹配" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/" class="article-date"><time class="dt-published" datetime="2021-10-30T15:37:16.000Z" itemprop="datePublished">2021-10-30</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E7%AE%97%E6%B3%95/">算法</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/">二分图匹配</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>先通过交错路和增广路的概念建立起处理最大匹配的工具<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>证明匹配最大的充要条件是图中没有增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后证明Hall定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>顺便证明了婚配定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并利用之证明最大匹配与最小点覆盖的对偶性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>最后证明最小边覆盖与最大独立集的对偶性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及这四者之间的关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p class="article-more-link"><a href="../../%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/#more">Read More</a></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/" rel="tag">二分图匹配</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li></ul></footer></div></article><article id="post-Public-Transport-System" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../Public-Transport-System/" class="article-date"><time class="dt-published" datetime="2021-10-14T09:36:16.000Z" itemprop="datePublished">2021-10-14</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E9%A2%98%E8%A7%A3/">题解</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../Public-Transport-System/">Public Transport System</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><h2 id="题意">题意</h2><p>给定一个有向图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每条边有边权<span class="markdown-them-math-inline">$a_e$</span>和<span class="markdown-them-math-inline">$b_e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$0&lt;a_e,b_e;\;b_e&lt;a_e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记一条路径由<span class="markdown-them-math-inline">$k$</span>条边<span class="markdown-them-math-inline">$e_1,e_2,...,e_k$</span>组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么这条路径中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>边<span class="markdown-them-math-inline">$e_1$</span>的权值为<span class="markdown-them-math-inline">$a_{e_1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$e_i(i&gt;1)$</span>的权值为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{cases} a_{e_i}&amp;a_{e_i}\leq a_{e_{i-1}},\\ a_{e_{i}}-b_{e_i}&amp;a_{e_i}&gt;a_{e_{i-1}}. \end{cases} $$</div><p>这条路径的权值是这条路径上边的权值之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>求从点<span class="markdown-them-math-inline">$1$</span>出发到所有点的最短路长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><div class="markdown-them-math-block">$$\begin{align*} n\leq 1\times10^5,\ m\leq 2\times10^5. \end{align*} $$</div><p class="article-more-link"><a href="../../Public-Transport-System/#more">Read More</a></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%BB%BA%E5%9B%BE/" rel="tag">建图</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%80%9D%E7%BB%B4/" rel="tag">思维</a></li></ul></footer></div></article><article id="post-Charged-Tree" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../Charged-Tree/" class="article-date"><time class="dt-published" datetime="2021-09-21T08:17:39.076Z" itemprop="datePublished">2021-09-21</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E9%A2%98%E8%A7%A3/">题解</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../Charged-Tree/">Charged Tree</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>题意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>给定一棵有根带权树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>有两种操作下移和上移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>下移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即每个节点将自己的权值均分给各个儿子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>假设叶子结点有一个无限长的儿子链<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即叶子结点每次下移都会把自己和整条儿子链下移一位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每个节点的新值就是它从父亲得到的那个值<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>他自己原来的值已经分给了儿子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>特别地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一次下移操作后根变成0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>上移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即对每个节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将所有儿子的权值加起来赋给自己<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p class="article-more-link"><a href="../../Charged-Tree/#more">Read More</a></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%80%9D%E7%BB%B4/" rel="tag">思维</a></li></ul></footer></div></article><article id="post-tarjan算法（求最近公共祖先）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../tarjan%E7%AE%97%E6%B3%95%EF%BC%88%E6%B1%82%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%89/" class="article-date"><time class="dt-published" datetime="2021-09-18T09:33:11.008Z" itemprop="datePublished">2021-09-18</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E7%AE%97%E6%B3%95/">算法</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../tarjan%E7%AE%97%E6%B3%95%EF%BC%88%E6%B1%82%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%89/">tarjan算法（求最近公共祖先）</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>本文讲解用于求解最近公共祖先<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Least Common Ancestor, LCA<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的tarjan算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先看最近公共祖先问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对一棵给定的有根树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为了得知两点之间最短的路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然应当先从一点运动到它们的最近公共祖先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再直接运动到另一点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果每条边只能经过一次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么这就是唯一的路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时就需要确定这两点的最近公共祖先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对小规模的数据可以使用暴力算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比如对一个点的所有祖先进行dfs<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>找到最近的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>能到达另一点的那个祖先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是这个算法本身效率就很低下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更不用提大规模数据的情形<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>解决这一类问题有多种算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可分为在线算法和离线算法两种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>在线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>和<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>离线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>是针对大规模数据的说法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在线算法是指对每个询问<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即节点对<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>即时处理的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>离线算法是指将所有询问存储起来以后统一处理的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在线和离线会造成复杂度的很大差异<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通常来讲离线算法应当更快一些<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为离线情形掌握了更多的信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里要讲的tarjan算法是一种离线算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>复杂度为<span class="markdown-them-math-inline">$O(n+p)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中<span class="markdown-them-math-inline">$n$</span>为树的节点数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$p$</span>为询问数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>考虑优化上述的dfs<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>上述的dfs显然有许多浪费<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为上述过程中的所有节点只需要一次dfs就可以遍历完<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而上述过程中dfs的次数却与深度成正比<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这显然是没有很好地利用dfs的信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>仔细考虑dfs的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现遍历在最近祖先处是一棵一棵子树进行的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是先遍历了含有节点1的子树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再遍历含有节点2的子树<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>假设1比2先遍历到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们需要找到这两棵子树<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>分叉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>的地方<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而不考虑分叉处上面的情形<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>那么可以考虑这样做<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>针对当前的状态v<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为遍历过的每个节点u打上一个标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记录u和v从哪里开始<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>分叉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果这一操作可以在遍历到u时就做到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么问题就解决了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>显然初始值<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>刚遍历到u时的标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>是这个节点直接的父亲<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当遍历完他父亲的所有子树后仍没有找到节点2时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>应当返回它父亲的父亲继续搜索<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么该节点的标记也都应当变成他的父亲的父亲<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这看起来需要再进行一次dfs从而效率和刚才一样低<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是可以用并查集解决这一问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>现在的过程变成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>遍历到某一结点时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将他和他父亲合并<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>在并查集中成为父亲的子树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>当他父亲遍历完所有子树之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将他父亲和他父亲的父亲合并…为了知道某个节点的标记<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>分叉处<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只需要查找该节点在并查集中的根节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" rel="tag">最近公共祖先</a></li></ul></footer></div></article><article id="post-PWTC day4补题记录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../PWTC%20day4%E8%A1%A5%E9%A2%98%E8%AE%B0%E5%BD%95/" class="article-date"><time class="dt-published" datetime="2021-08-20T13:51:24.687Z" itemprop="datePublished">2021-08-20</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E9%A2%98%E8%A7%A3/">题解</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../PWTC%20day4%E8%A1%A5%E9%A2%98%E8%AE%B0%E5%BD%95/">PWTC day4补题记录</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><h2 id="f">F</h2><p>题意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>求树链mex<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$n,q\leq 100,000$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>树上莫队<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>考虑一个棋子在树上从根开始dfs的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>棋子每移动一次都停下来记录一次时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>注意返回父亲时也要停下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每两个时刻之间就由一个边连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>把<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>对按时刻排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次询问<span class="markdown-them-math-inline">$(u,v)$</span>即为询问来到<span class="markdown-them-math-inline">$u$</span>的时刻<span class="markdown-them-math-inline">$t_u$</span>到<span class="markdown-them-math-inline">$v$</span>的时刻<span class="markdown-them-math-inline">$t_v$</span>之间的序列的一个量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>这个序列中出现过两次的边都不计入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只计入出现过一次的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求mex<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样就恰好只计入了<span class="markdown-them-math-inline">$u$</span>到<span class="markdown-them-math-inline">$v$</span>的链上的所有边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后是维护mex<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个题每次修改都带上<span class="markdown-them-math-inline">$\log$</span>就是<span class="markdown-them-math-inline">$O(n\sqrt{n}\log n)$</span>会T<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以要线性修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于询问mex只有<span class="markdown-them-math-inline">$q$</span>次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以可以容忍<span class="markdown-them-math-inline">$O(\sqrt{n})$</span>的询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是对边权分块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即用<span class="markdown-them-math-inline">$cnt[i]$</span>记录<span class="markdown-them-math-inline">$i$</span>的出现次数的同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用<span class="markdown-them-math-inline">$cnt\_bl[i]$</span>记录<span class="markdown-them-math-inline">$[i * bl, (i + 1) * bl - 1]$</span>中数的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>找到第一个数的个数没有填满的块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再遍历该块找到第一个缺席的数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即为mex<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="ac代码">AC代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 100005</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;
vector&lt;pii&gt; G[maxn];
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">query</span> &#123;</span>
    <span class="hljs-keyword">int</span> first, second, id;
&#125;;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span>
    <span class="hljs-keyword">int</span> w, id;
&#125;;
vector&lt;query&gt; qs;
vector&lt;pii&gt; ans;
<span class="hljs-keyword">int</span> n, q, len, t, tt, bl;
<span class="hljs-keyword">int</span> el[maxn], er[maxn];
edge L[<span class="hljs-number">2</span> * maxn], R[<span class="hljs-number">2</span> * maxn];
<span class="hljs-keyword">bool</span> vis[maxn];
<span class="hljs-keyword">int</span> cnt[maxn], cnt_block[maxn];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa, <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> ww)</span> </span>&#123;
    el[u] = ++t;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : G[u]) &#123;
        <span class="hljs-keyword">int</span> v = e.first, w = e.second;
        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;
        R[t] = edge&#123;w, ++tt&#125;;
        L[t + <span class="hljs-number">1</span>] = edge&#123;w, tt&#125;;
        <span class="hljs-built_in">dfs</span>(v, u, tt, w);
    &#125;
    R[t] = edge&#123;ww, id&#125;;
    er[u] = ++t;
    L[t] = edge&#123;ww, id&#125;;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;
    cnt[a]++;
    <span class="hljs-keyword">if</span> (cnt[a] == <span class="hljs-number">1</span>) cnt_block[a / bl]++;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;
    cnt[a]--;
    <span class="hljs-keyword">if</span> (cnt[a] == <span class="hljs-number">0</span>) cnt_block[a / bl]--;
&#125;
<span class="hljs-comment">// ql + n^2/l min, q - n^2/l^2=0, l = n / sqrt(q)</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> query&amp; a, <span class="hljs-keyword">const</span> query&amp; b)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (a.first / len != b.first / len) <span class="hljs-keyword">return</span> a.first / len &lt; b.first / len;
    <span class="hljs-keyword">return</span> a.second &lt; b.second;
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);
    cin &gt;&gt; n &gt;&gt; q;
    len = <span class="hljs-number">2</span> * n / <span class="hljs-built_in">sqrt</span>(q);
    bl = <span class="hljs-built_in">sqrt</span>(maxn);
    <span class="hljs-keyword">int</span> u, v, w;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        w = <span class="hljs-built_in">min</span>(w, n);
        G[u].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pii</span>(v, w));
        G[v].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pii</span>(u, w));
        vis[i] = <span class="hljs-literal">false</span>;
    &#125;
    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100005</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) &#123;
        cin &gt;&gt; u &gt;&gt; v;
        <span class="hljs-keyword">int</span> a = el[u], b = el[v];
        <span class="hljs-keyword">if</span> (a &gt; b) &#123;<span class="hljs-keyword">int</span> tmp = a; a = b; b = tmp;&#125;
        qs.<span class="hljs-built_in">push_back</span>(query&#123;a, b, i&#125;);
    &#125;
    <span class="hljs-comment">// 分块</span>
    <span class="hljs-built_in">sort</span>(qs.<span class="hljs-built_in">begin</span>(), qs.<span class="hljs-built_in">end</span>(), cmp);
    <span class="hljs-comment">// 莫队</span>
    <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : qs) &#123;
        <span class="hljs-keyword">int</span> &amp;ql = p.first, &amp;qr = p.second;
        <span class="hljs-keyword">while</span> (l &gt; ql) &#123; <span class="hljs-comment">//  先尽量延长</span>
            <span class="hljs-keyword">if</span> (!vis[L[l].id]) &#123;
                <span class="hljs-built_in">add</span>(L[l].w);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-built_in">del</span>(L[l].w);
            &#125;
            vis[L[l].id] = !vis[L[l].id];
            l--;
        &#125;
        <span class="hljs-keyword">while</span> (r &lt; qr) &#123; <span class="hljs-comment">//  先尽量延长</span>
            <span class="hljs-keyword">if</span> (!vis[R[r].id]) &#123;
                <span class="hljs-built_in">add</span>(R[r].w);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-built_in">del</span>(R[r].w);
            &#125;
            vis[R[r].id] = !vis[R[r].id];
            r++;
        &#125;
        <span class="hljs-keyword">while</span> (l &lt; ql) &#123;
            <span class="hljs-keyword">if</span> (!vis[R[l].id]) &#123;
                <span class="hljs-built_in">add</span>(R[l].w);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-built_in">del</span>(R[l].w);
            &#125;
            vis[R[l].id] = !vis[R[l].id];
            l++;
        &#125;
        <span class="hljs-keyword">while</span> (r &gt; qr) &#123;
            <span class="hljs-keyword">if</span> (!vis[L[r].id]) &#123;
                <span class="hljs-built_in">add</span>(L[r].w);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-built_in">del</span>(L[r].w);
            &#125;
            vis[L[r].id] = !vis[L[r].id];
            r--;
        &#125;
        <span class="hljs-keyword">int</span> i, j;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100000</span> / bl; i++) &#123;
            <span class="hljs-keyword">if</span> (cnt_block[i] != bl) <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-keyword">for</span> (j = i * bl; j &lt; (i + <span class="hljs-number">1</span>) * bl; j++) &#123;
            <span class="hljs-keyword">if</span> (cnt[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
        &#125;
        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pii</span>(p.id, j));
    &#125;
    <span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : ans) &#123;
        cout &lt;&lt; p.second &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre></div></div><footer class="article-footer"></footer></div></article><article id="post-FFT" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../FFT/" class="article-date"><time class="dt-published" datetime="2021-07-18T03:51:49.629Z" itemprop="datePublished">2021-07-18</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E7%AE%97%E6%B3%95/">算法</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../FFT/">FFT</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>FFT可以在<span class="markdown-them-math-inline">$O(n\log n)$</span>的时间内在多项式的点值表示法和系数表示法之间相互转换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而可以加速多项式乘法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p class="article-more-link"><a href="../../FFT/#more">Read More</a></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/FFT/" rel="tag">FFT</a></li></ul></footer></div></article><article id="post-SB树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../SB%E6%A0%91/" class="article-date"><time class="dt-published" datetime="2021-06-10T19:11:22.884Z" itemprop="datePublished">2021-06-11</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../SB%E6%A0%91/">SB树</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>这棵二叉树中包含了所有的非负有理数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>首先看它的构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>左侧有一个点<span class="markdown-them-math-inline">$0/1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>右侧有一个点<span class="markdown-them-math-inline">$1/0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在中间创建一个点<span class="markdown-them-math-inline">$0+1/1+0=1/1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就是SB树的根<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>接下来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$1/1$</span>的左儿子是它和<span class="markdown-them-math-inline">$0/1$</span>的分子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>分母分别相加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$1+0/1+1=1/2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>右儿子是与<span class="markdown-them-math-inline">$1/0$</span>做这个操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$1+1/1+0=2/1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>接下来的节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其左儿子为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>该节点与左兄弟的分子分母分别相加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>特别地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>没有左兄弟时<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即它在左链上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>认为左兄弟为<span class="markdown-them-math-inline">$0/1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>右儿子为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>该节点与右兄弟的分子分母分别相加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>特别地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>没有右兄弟时<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即它在右链上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>认为右兄弟为<span class="markdown-them-math-inline">$1/0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><blockquote><p>SB树中每个数都满足<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>分子分母互质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即每个非负有理数至多出现一次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><p>证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>我们来证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对每个节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑其加入时刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>假如此时构造它使用了<span class="markdown-them-math-inline">$m/n$</span>和<span class="markdown-them-math-inline">$m'/n'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>那么必有<span class="markdown-them-math-inline">$m'n-mn'=1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先这对根节点成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>现在假设对<span class="markdown-them-math-inline">$m+m'/n+n'$</span>的构造时刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$m/n$</span>和<span class="markdown-them-math-inline">$m'/n'$</span>有<span class="markdown-them-math-inline">$m'n-mn'=1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现在只要证明</p><ol><li><span class="markdown-them-math-inline">$(m+m')n-m(n+n')=1$</span></li><li><span class="markdown-them-math-inline">$m'(n+n')-(m+m')n=1$</span></li></ol><p>而这两个等式都与原等式相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是对每个<span class="markdown-them-math-inline">$m/n$</span>存在<span class="markdown-them-math-inline">$a,b$</span>使<span class="markdown-them-math-inline">$am+bn=1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而<span class="markdown-them-math-inline">$m,n$</span>互质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"></footer></div></article><article id="post-CF708D2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../CF708D2/" class="article-date"><time class="dt-published" datetime="2021-04-29T03:03:50.328Z" itemprop="datePublished">2021-04-29</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E9%A2%98%E8%A7%A3/">题解</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../CF708D2/">CF708D2</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><h2 id="d题">D题</h2><p>题很好<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>感觉思维得到了升华<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>把整个题考虑成一个图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对每对<span class="markdown-them-math-inline">$\{i, j\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只要<code>tag[i] != tag[j]</code>他们之间就要连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>边权为<span class="markdown-them-math-inline">$|2^i-2^j|$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>按照题意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要找一条边权不断上升的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><span class="markdown-them-math-inline">$\sum|s_i-s_j|$</span>最大的路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于边权不断上升<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以将边按边权排序<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>外层<span class="markdown-them-math-inline">$i$</span>从小到大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>内层<span class="markdown-them-math-inline">$j$</span>从大到小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后使用动态规划<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><code>dp[i][t]</code>维护只使用前<span class="markdown-them-math-inline">$t$</span>条边时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>终点为<span class="markdown-them-math-inline">$i$</span>的路的路径权值最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>考虑转移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现<span class="markdown-them-math-inline">$t$</span>增加<span class="markdown-them-math-inline">$1$</span>时只有至多两个dp值会发生变化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为一步只引入了一条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且它只能被加在已经考虑过的路径的末尾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以舍弃<span class="markdown-them-math-inline">$t$</span>维度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而代之以时间维度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$dp$</span>数组只有一维<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>dp[i]</code>维护当前时刻以<span class="markdown-them-math-inline">$i$</span>结尾的路的路径权值最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每当时刻前进1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就新考虑一条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新一下<code>dp[i]</code>和<code>dp[j]</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$dp_i = \max(dp_i, dp_j + |s_i - s_j|)$</span>和<span class="markdown-them-math-inline">$dp_j=\max(dp_j, dp_i+|s_i-s_j|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"></footer></div></article><nav id="page-nav"><a class="extend prev" rel="prev" href="../../">&laquo; 上一页</a><a class="page-number" href="../../">1</a><span class="page-number current">2</span><a class="page-number" href="../3/">3</a><a class="page-number" href="../4/">4</a><a class="extend next" rel="next" href="../3/">下一页 &raquo;</a></nav></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2024 Wilson Xia<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/bill-xia/hexo-theme-mashiro" target="_blank">Mashiro</a><br></div></div></footer></div><nav id="mobile-nav"><a href="/" class="mobile-nav-link">Home</a> <a href="/archives/" class="mobile-nav-link">Archives</a> <a href="/paper_list/" class="mobile-nav-link">Paper List</a> <a href="/about/" class="mobile-nav-link">About</a></nav><script src="../../js/clipboard.min.js"></script><script src="../../js/jquery-1.4.3.min.js"></script><script src="../../fancybox/jquery.fancybox-1.3.4.pack.js"></script><script src="../../js/script.js"></script></div></body></html>