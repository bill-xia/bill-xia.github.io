<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Wilson&#39;s blog</title>
  <link rel="stylesheet" href="/css/fonts/Chinese-normal-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/ChineseMono-normal-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/Chinese-italic-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/Chinese-normal-bold.min.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  
    <link rel="alternate" href="../.././atom.xml" title="Wilson's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="../.././favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="../.././index.html">Home</a>
    
      <a class="main-nav-link" href="../.././archives/">Archives</a>
    
      <a class="main-nav-link" href="../.././about/">About</a>
    
    <div class="main-nav-space-between"></div>
    
      <a id="nav-rss-link" class="nav-icon" href="../.././atom.xml" title="RSS 订阅"></a>
    
  </nav>
</div>
<div id="header-title">
  <h1 id="logo-wrap">
    <a href="../.././index.html" id="logo">Wilson&#39;s blog</a>
  </h1>
  
</div>

      <div id="content" class="outer">
        <section id="main">
  
    <article id="post-二分图匹配" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../.././%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/" class="article-date">
  <time class="dt-published" datetime="2021-10-30T15:37:16.000Z" itemprop="datePublished">2021-10-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../.././categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../.././%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/">二分图匹配</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>先通过交错路和增广路的概念建立起处理最大匹配的工具<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>证明匹配最大的充要条件是图中没有增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后证明Hall定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>顺便证明了婚配定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并利用之证明最大匹配与最小点覆盖的对偶性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>最后证明最小边覆盖与最大独立集的对偶性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及这四者之间的关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
        
          <p class="article-more-link">
            <a href="../.././%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../.././tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/" rel="tag">二分图匹配</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../.././tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Public-Transport-System" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../.././Public-Transport-System/" class="article-date">
  <time class="dt-published" datetime="2021-10-14T09:36:16.000Z" itemprop="datePublished">2021-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../.././categories/%E9%A2%98%E8%A7%A3/">题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../.././Public-Transport-System/">Public Transport System</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题意">题意</h2>
<p>给定一个有向图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每条边有边权<span class="markdown-them-math-inline">$a_e$</span>和<span class="markdown-them-math-inline">$b_e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$0&lt;a_e,b_e;\;b_e&lt;a_e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记一条路径由<span class="markdown-them-math-inline">$k$</span>条边<span class="markdown-them-math-inline">$e_1,e_2,...,e_k$</span>组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么这条路径中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>边<span class="markdown-them-math-inline">$e_1$</span>的权值为<span class="markdown-them-math-inline">$a_{e_1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$e_i(i&gt;1)$</span>的权值为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\begin{cases}
a_{e_i}&amp;a_{e_i}\leq a_{e_{i-1}},\\
a_{e_{i}}-b_{e_i}&amp;a_{e_i}&gt;a_{e_{i-1}}.
\end{cases}
$$</div><p>这条路径的权值是这条路径上边的权值之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>求从点<span class="markdown-them-math-inline">$1$</span>出发到所有点的最短路长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\begin{align*}
n\leq 1\times10^5,\ m\leq 2\times10^5.
\end{align*}
$$</div>
        
          <p class="article-more-link">
            <a href="../.././Public-Transport-System/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../.././tags/%E5%BB%BA%E5%9B%BE/" rel="tag">建图</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../.././tags/%E6%80%9D%E7%BB%B4/" rel="tag">思维</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Charged-Tree" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../.././Charged-Tree/" class="article-date">
  <time class="dt-published" datetime="2021-09-21T08:17:39.076Z" itemprop="datePublished">2021-09-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../.././categories/%E9%A2%98%E8%A7%A3/">题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../.././Charged-Tree/">Charged Tree</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>题意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>给定一棵有根带权树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>有两种操作下移和上移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>下移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即每个节点将自己的权值均分给各个儿子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>假设叶子结点有一个无限长的儿子链<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即叶子结点每次下移都会把自己和整条儿子链下移一位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每个节点的新值就是它从父亲得到的那个值<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>他自己原来的值已经分给了儿子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>特别地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一次下移操作后根变成0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>上移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即对每个节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将所有儿子的权值加起来赋给自己<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
        
          <p class="article-more-link">
            <a href="../.././Charged-Tree/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../.././tags/%E6%80%9D%E7%BB%B4/" rel="tag">思维</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-tarjan算法（求最近公共祖先）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../.././tarjan%E7%AE%97%E6%B3%95%EF%BC%88%E6%B1%82%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2021-09-18T09:33:11.008Z" itemprop="datePublished">2021-09-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../.././categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../.././tarjan%E7%AE%97%E6%B3%95%EF%BC%88%E6%B1%82%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%89/">tarjan算法（求最近公共祖先）</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文讲解用于求解最近公共祖先<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Least Common Ancestor, LCA<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的tarjan算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>首先看最近公共祖先问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对一棵给定的有根树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为了得知两点之间最短的路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然应当先从一点运动到它们的最近公共祖先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再直接运动到另一点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果每条边只能经过一次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么这就是唯一的路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时就需要确定这两点的最近公共祖先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对小规模的数据可以使用暴力算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比如对一个点的所有祖先进行dfs<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>找到最近的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>能到达另一点的那个祖先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是这个算法本身效率就很低下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更不用提大规模数据的情形<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>解决这一类问题有多种算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可分为在线算法和离线算法两种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>在线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>和<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>离线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>是针对大规模数据的说法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在线算法是指对每个询问<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即节点对<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>即时处理的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>离线算法是指将所有询问存储起来以后统一处理的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在线和离线会造成复杂度的很大差异<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通常来讲离线算法应当更快一些<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为离线情形掌握了更多的信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里要讲的tarjan算法是一种离线算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>复杂度为<span class="markdown-them-math-inline">$O(n+p)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中<span class="markdown-them-math-inline">$n$</span>为树的节点数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$p$</span>为询问数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>考虑优化上述的dfs<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>上述的dfs显然有许多浪费<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为上述过程中的所有节点只需要一次dfs就可以遍历完<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而上述过程中dfs的次数却与深度成正比<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这显然是没有很好地利用dfs的信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>仔细考虑dfs的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现遍历在最近祖先处是一棵一棵子树进行的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是先遍历了含有节点1的子树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再遍历含有节点2的子树<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>假设1比2先遍历到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们需要找到这两棵子树<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>分叉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>的地方<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而不考虑分叉处上面的情形<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>那么可以考虑这样做<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>针对当前的状态v<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为遍历过的每个节点u打上一个标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记录u和v从哪里开始<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>分叉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果这一操作可以在遍历到u时就做到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么问题就解决了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>显然初始值<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>刚遍历到u时的标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>是这个节点直接的父亲<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当遍历完他父亲的所有子树后仍没有找到节点2时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>应当返回它父亲的父亲继续搜索<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么该节点的标记也都应当变成他的父亲的父亲<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这看起来需要再进行一次dfs从而效率和刚才一样低<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是可以用并查集解决这一问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>现在的过程变成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>遍历到某一结点时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将他和他父亲合并<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>在并查集中成为父亲的子树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>当他父亲遍历完所有子树之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将他父亲和他父亲的父亲合并…为了知道某个节点的标记<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>分叉处<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只需要查找该节点在并查集中的根节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../.././tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../.././tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" rel="tag">最近公共祖先</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-PWTC day4补题记录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../.././PWTC%20day4%E8%A1%A5%E9%A2%98%E8%AE%B0%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2021-08-20T13:51:24.687Z" itemprop="datePublished">2021-08-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../.././categories/%E9%A2%98%E8%A7%A3/">题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../.././PWTC%20day4%E8%A1%A5%E9%A2%98%E8%AE%B0%E5%BD%95/">PWTC day4补题记录</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="f">F</h2>
<p>题意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>求树链mex<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$n,q\leq 100,000$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>树上莫队<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>考虑一个棋子在树上从根开始dfs的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>棋子每移动一次都停下来记录一次时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>注意返回父亲时也要停下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每两个时刻之间就由一个边连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>把<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>对按时刻排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次询问<span class="markdown-them-math-inline">$(u,v)$</span>即为询问来到<span class="markdown-them-math-inline">$u$</span>的时刻<span class="markdown-them-math-inline">$t_u$</span>到<span class="markdown-them-math-inline">$v$</span>的时刻<span class="markdown-them-math-inline">$t_v$</span>之间的序列的一个量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>这个序列中出现过两次的边都不计入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只计入出现过一次的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求mex<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样就恰好只计入了<span class="markdown-them-math-inline">$u$</span>到<span class="markdown-them-math-inline">$v$</span>的链上的所有边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后是维护mex<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个题每次修改都带上<span class="markdown-them-math-inline">$\log$</span>就是<span class="markdown-them-math-inline">$O(n\sqrt{n}\log n)$</span>会T<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以要线性修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于询问mex只有<span class="markdown-them-math-inline">$q$</span>次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以可以容忍<span class="markdown-them-math-inline">$O(\sqrt{n})$</span>的询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是对边权分块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即用<span class="markdown-them-math-inline">$cnt[i]$</span>记录<span class="markdown-them-math-inline">$i$</span>的出现次数的同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用<span class="markdown-them-math-inline">$cnt\_bl[i]$</span>记录<span class="markdown-them-math-inline">$[i * bl, (i + 1) * bl - 1]$</span>中数的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>找到第一个数的个数没有填满的块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再遍历该块找到第一个缺席的数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即为mex<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="ac代码">AC代码</h2>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 100005</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;
vector&lt;pii&gt; G[maxn];
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">query</span> &#123;</span>
    <span class="hljs-keyword">int</span> first, second, id;
&#125;;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span>
    <span class="hljs-keyword">int</span> w, id;
&#125;;
vector&lt;query&gt; qs;
vector&lt;pii&gt; ans;
<span class="hljs-keyword">int</span> n, q, len, t, tt, bl;
<span class="hljs-keyword">int</span> el[maxn], er[maxn];
edge L[<span class="hljs-number">2</span> * maxn], R[<span class="hljs-number">2</span> * maxn];
<span class="hljs-keyword">bool</span> vis[maxn];
<span class="hljs-keyword">int</span> cnt[maxn], cnt_block[maxn];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa, <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> ww)</span> </span>&#123;
    el[u] = ++t;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : G[u]) &#123;
        <span class="hljs-keyword">int</span> v = e.first, w = e.second;
        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;
        R[t] = edge&#123;w, ++tt&#125;;
        L[t + <span class="hljs-number">1</span>] = edge&#123;w, tt&#125;;
        <span class="hljs-built_in">dfs</span>(v, u, tt, w);
    &#125;
    R[t] = edge&#123;ww, id&#125;;
    er[u] = ++t;
    L[t] = edge&#123;ww, id&#125;;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;
    cnt[a]++;
    <span class="hljs-keyword">if</span> (cnt[a] == <span class="hljs-number">1</span>) cnt_block[a / bl]++;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;
    cnt[a]--;
    <span class="hljs-keyword">if</span> (cnt[a] == <span class="hljs-number">0</span>) cnt_block[a / bl]--;
&#125;
<span class="hljs-comment">// ql + n^2/l min, q - n^2/l^2=0, l = n / sqrt(q)</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> query&amp; a, <span class="hljs-keyword">const</span> query&amp; b)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (a.first / len != b.first / len) <span class="hljs-keyword">return</span> a.first / len &lt; b.first / len;
    <span class="hljs-keyword">return</span> a.second &lt; b.second;
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);
    cin &gt;&gt; n &gt;&gt; q;
    len = <span class="hljs-number">2</span> * n / <span class="hljs-built_in">sqrt</span>(q);
    bl = <span class="hljs-built_in">sqrt</span>(maxn);
    <span class="hljs-keyword">int</span> u, v, w;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        w = <span class="hljs-built_in">min</span>(w, n);
        G[u].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pii</span>(v, w));
        G[v].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pii</span>(u, w));
        vis[i] = <span class="hljs-literal">false</span>;
    &#125;
    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100005</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) &#123;
        cin &gt;&gt; u &gt;&gt; v;
        <span class="hljs-keyword">int</span> a = el[u], b = el[v];
        <span class="hljs-keyword">if</span> (a &gt; b) &#123;<span class="hljs-keyword">int</span> tmp = a; a = b; b = tmp;&#125;
        qs.<span class="hljs-built_in">push_back</span>(query&#123;a, b, i&#125;);
    &#125;
    <span class="hljs-comment">// 分块</span>
    <span class="hljs-built_in">sort</span>(qs.<span class="hljs-built_in">begin</span>(), qs.<span class="hljs-built_in">end</span>(), cmp);
    <span class="hljs-comment">// 莫队</span>
    <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : qs) &#123;
        <span class="hljs-keyword">int</span> &amp;ql = p.first, &amp;qr = p.second;
        <span class="hljs-keyword">while</span> (l &gt; ql) &#123; <span class="hljs-comment">//  先尽量延长</span>
            <span class="hljs-keyword">if</span> (!vis[L[l].id]) &#123;
                <span class="hljs-built_in">add</span>(L[l].w);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-built_in">del</span>(L[l].w);
            &#125;
            vis[L[l].id] = !vis[L[l].id];
            l--;
        &#125;
        <span class="hljs-keyword">while</span> (r &lt; qr) &#123; <span class="hljs-comment">//  先尽量延长</span>
            <span class="hljs-keyword">if</span> (!vis[R[r].id]) &#123;
                <span class="hljs-built_in">add</span>(R[r].w);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-built_in">del</span>(R[r].w);
            &#125;
            vis[R[r].id] = !vis[R[r].id];
            r++;
        &#125;
        <span class="hljs-keyword">while</span> (l &lt; ql) &#123;
            <span class="hljs-keyword">if</span> (!vis[R[l].id]) &#123;
                <span class="hljs-built_in">add</span>(R[l].w);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-built_in">del</span>(R[l].w);
            &#125;
            vis[R[l].id] = !vis[R[l].id];
            l++;
        &#125;
        <span class="hljs-keyword">while</span> (r &gt; qr) &#123;
            <span class="hljs-keyword">if</span> (!vis[L[r].id]) &#123;
                <span class="hljs-built_in">add</span>(L[r].w);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-built_in">del</span>(L[r].w);
            &#125;
            vis[L[r].id] = !vis[L[r].id];
            r--;
        &#125;
        <span class="hljs-keyword">int</span> i, j;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100000</span> / bl; i++) &#123;
            <span class="hljs-keyword">if</span> (cnt_block[i] != bl) <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-keyword">for</span> (j = i * bl; j &lt; (i + <span class="hljs-number">1</span>) * bl; j++) &#123;
            <span class="hljs-keyword">if</span> (cnt[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
        &#125;
        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pii</span>(p.id, j));
    &#125;
    <span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : ans) &#123;
        cout &lt;&lt; p.second &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre></div>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-FFT" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../.././FFT/" class="article-date">
  <time class="dt-published" datetime="2021-07-18T03:51:49.629Z" itemprop="datePublished">2021-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../.././categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../.././FFT/">FFT</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>FFT可以在<span class="markdown-them-math-inline">$O(n\log n)$</span>的时间内在多项式的点值表示法和系数表示法之间相互转换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而可以加速多项式乘法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
        
          <p class="article-more-link">
            <a href="../.././FFT/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../.././tags/FFT/" rel="tag">FFT</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-SB树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../.././SB%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2021-06-10T19:11:22.884Z" itemprop="datePublished">2021-06-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../.././categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../.././SB%E6%A0%91/">SB树</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这棵二叉树中包含了所有的非负有理数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>首先看它的构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p>左侧有一个点<span class="markdown-them-math-inline">$0/1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>右侧有一个点<span class="markdown-them-math-inline">$1/0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在中间创建一个点<span class="markdown-them-math-inline">$0+1/1+0=1/1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就是SB树的根<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>接下来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$1/1$</span>的左儿子是它和<span class="markdown-them-math-inline">$0/1$</span>的分子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>分母分别相加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$1+0/1+1=1/2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>右儿子是与<span class="markdown-them-math-inline">$1/0$</span>做这个操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$1+1/1+0=2/1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>接下来的节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其左儿子为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>该节点与左兄弟的分子分母分别相加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>特别地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>没有左兄弟时<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即它在左链上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>认为左兄弟为<span class="markdown-them-math-inline">$0/1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>右儿子为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>该节点与右兄弟的分子分母分别相加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>特别地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>没有右兄弟时<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即它在右链上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>认为右兄弟为<span class="markdown-them-math-inline">$1/0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>首先证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<blockquote>
<p>SB树中每个数都满足<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>分子分母互质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即每个非负有理数至多出现一次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>我们来证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对每个节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑其加入时刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>假如此时构造它使用了<span class="markdown-them-math-inline">$m/n$</span>和<span class="markdown-them-math-inline">$m'/n'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>那么必有<span class="markdown-them-math-inline">$m'n-mn'=1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>首先这对根节点成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>现在假设对<span class="markdown-them-math-inline">$m+m'/n+n'$</span>的构造时刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$m/n$</span>和<span class="markdown-them-math-inline">$m'/n'$</span>有<span class="markdown-them-math-inline">$m'n-mn'=1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现在只要证明</p>
<ol>
<li><span class="markdown-them-math-inline">$(m+m')n-m(n+n')=1$</span></li>
<li><span class="markdown-them-math-inline">$m'(n+n')-(m+m')n=1$</span></li>
</ol>
<p>而这两个等式都与原等式相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是对每个<span class="markdown-them-math-inline">$m/n$</span>存在<span class="markdown-them-math-inline">$a,b$</span>使<span class="markdown-them-math-inline">$am+bn=1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而<span class="markdown-them-math-inline">$m,n$</span>互质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CF708D2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../.././CF708D2/" class="article-date">
  <time class="dt-published" datetime="2021-04-29T03:03:50.328Z" itemprop="datePublished">2021-04-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../.././categories/%E9%A2%98%E8%A7%A3/">题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../.././CF708D2/">CF708D2</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="d题">D题</h2>
<p>题很好<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>感觉思维得到了升华<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>把整个题考虑成一个图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对每对<span class="markdown-them-math-inline">$\{i, j\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只要<code>tag[i] != tag[j]</code>他们之间就要连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>边权为<span class="markdown-them-math-inline">$|2^i-2^j|$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>按照题意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要找一条边权不断上升的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><span class="markdown-them-math-inline">$\sum|s_i-s_j|$</span>最大的路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于边权不断上升<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以将边按边权排序<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>外层<span class="markdown-them-math-inline">$i$</span>从小到大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>内层<span class="markdown-them-math-inline">$j$</span>从大到小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后使用动态规划<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><code>dp[i][t]</code>维护只使用前<span class="markdown-them-math-inline">$t$</span>条边时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>终点为<span class="markdown-them-math-inline">$i$</span>的路的路径权值最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>考虑转移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现<span class="markdown-them-math-inline">$t$</span>增加<span class="markdown-them-math-inline">$1$</span>时只有至多两个dp值会发生变化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为一步只引入了一条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且它只能被加在已经考虑过的路径的末尾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以舍弃<span class="markdown-them-math-inline">$t$</span>维度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而代之以时间维度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$dp$</span>数组只有一维<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>dp[i]</code>维护当前时刻以<span class="markdown-them-math-inline">$i$</span>结尾的路的路径权值最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每当时刻前进1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就新考虑一条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新一下<code>dp[i]</code>和<code>dp[j]</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$dp_i = \max(dp_i, dp_j + |s_i - s_j|)$</span>和<span class="markdown-them-math-inline">$dp_j=\max(dp_j, dp_i+|s_i-s_j|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-区间众数" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../.././%E5%8C%BA%E9%97%B4%E4%BC%97%E6%95%B0/" class="article-date">
  <time class="dt-published" datetime="2021-04-20T05:20:43.094Z" itemprop="datePublished">2021-04-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../.././categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../.././%E5%8C%BA%E9%97%B4%E4%BC%97%E6%95%B0/">区间众数</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>通用求众数离线做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>离散化之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>开线段树维护数出现的频率的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>带单点修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后再用莫队<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>移动区间时就跑一个单点修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>复杂度是<span class="markdown-them-math-inline">$O(n\sqrt{n}\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>当只需要找频数超过一半的区间众数的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以这样考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>众数频数如果超过区间长度的一半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么任意划分区间为两段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它必然要么在左半边超过一半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么在右边超过一半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后就可以用线段树维护了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个结点维护当前区间的众数及其频数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当合并时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>找左儿子和右儿子的众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果众数频数超过一半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么众数一定是二者之一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>离散化后对每个数开一个<code>pos</code>数组维护出现位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在这个数组中二分得到这两者<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>左右儿子的众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>在当前区间中出现的频数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取最大者即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样维护出来不一定是真区间众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是如果众数超过区间长度一半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那他一定维护这个众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个复杂度是每次查询<span class="markdown-them-math-inline">$O(\log^2n)$</span>的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>上面的论述中<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>一半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>大概也可以改为其他比例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这带来的问题是满足其他比例的众数可能有多个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而这个比例超过一半时可以保证这样的众数唯一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>还有一种做法是随机化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在待查询区间里找30个数作为候选众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对每个数检查它是否满足频数超过区间长度一半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用上段的方法可以做到<span class="markdown-them-math-inline">$O(\log n)$</span>查询<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果一个数频数超过区间长度一半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么在区间内任取30个数<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>带放回<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>找不到该众数的概率不超过<span class="markdown-them-math-inline">$2^{-30}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个做法完全可以扩展到其他比例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比例变小时只需提高30这个常数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如要求众数频数超过<span class="markdown-them-math-inline">$1/5$</span>时可以取100个候选众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即可做到<span class="markdown-them-math-inline">$({4\over 5})^{100}\approx2\times10^{-10}$</span>概率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这是选不到真众数的概率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为超过1/5的众数可能有多个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>似乎有点迷惑<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>选不到假众数的概率也是一样的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他们互不影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是没关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于候选众数中几乎必有真众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即使找到了假众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还需要和真众数比频数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以这种算法几乎必然找到真众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>CF716Div2 D   AC代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 300000</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;
<span class="hljs-keyword">int</span> n, m, maxn, a[N + <span class="hljs-number">5</span>];
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span>
    <span class="hljs-keyword">int</span> l, r, mx, aa;
&#125;;
node xds[<span class="hljs-number">4</span> * N+<span class="hljs-number">5</span>];
vector&lt;<span class="hljs-keyword">int</span>&gt; pos[N+<span class="hljs-number">5</span>];

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;
    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">upper_bound</span>(pos[x].<span class="hljs-built_in">begin</span>(), pos[x].<span class="hljs-built_in">end</span>(), r) - <span class="hljs-built_in">lower_bound</span>(pos[x].<span class="hljs-built_in">begin</span>(), pos[x].<span class="hljs-built_in">end</span>(), l);
    <span class="hljs-keyword">return</span> ret;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(l == r) &#123;
        xds[id].l = xds[id].r = l;
        xds[id].mx = <span class="hljs-number">1</span>;
        xds[id].aa = a[l];
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
    <span class="hljs-built_in">build</span>(id * <span class="hljs-number">2</span>, l, mid);
    <span class="hljs-built_in">build</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);
    xds[id].l = l; xds[id].r = r;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cnt</span>(xds[id * <span class="hljs-number">2</span>].aa, l, r) &gt; <span class="hljs-built_in">cnt</span>(xds[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].aa, l, r)) &#123;
        xds[id].mx = <span class="hljs-built_in">cnt</span>(xds[id * <span class="hljs-number">2</span>].aa, l, r);
        xds[id].aa=  xds[id * <span class="hljs-number">2</span>].aa;
    &#125; <span class="hljs-keyword">else</span> &#123;
        xds[id].mx = <span class="hljs-built_in">cnt</span>(xds[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].aa, l, r);
        xds[id].aa=  xds[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].aa;
    &#125;
&#125;

<span class="hljs-function">pii <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;
    <span class="hljs-comment">// (frequency, value)</span>
    pii ret, ret2;
    <span class="hljs-keyword">int</span> f1 = <span class="hljs-number">0</span>, f2 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (l &lt;= xds[id].l &amp;&amp; xds[id].r &lt;= r) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pii</span>(xds[id].mx, xds[id].aa);
    &#125;
    <span class="hljs-keyword">int</span> mid = (xds[id].l + xds[id].r) &gt;&gt; <span class="hljs-number">1</span>, rl = <span class="hljs-built_in">max</span>(l, xds[id].l), rr = <span class="hljs-built_in">min</span>(r, xds[id].r);
    <span class="hljs-keyword">if</span> (l &lt;= mid) &#123;
        ret = <span class="hljs-built_in">get</span>(id * <span class="hljs-number">2</span>, l, r);
        f1 = <span class="hljs-built_in">cnt</span>(ret.second, rl, rr);
    &#125;
    <span class="hljs-keyword">if</span> (r &gt; mid) &#123;
        ret2 =  <span class="hljs-built_in">get</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, l, r);
        f2 = <span class="hljs-built_in">cnt</span>(ret2.second, rl, rr);
    &#125;
    <span class="hljs-keyword">if</span> (f1 &gt; f2) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pii</span>(f1, ret.second);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pii</span>(f2, ret2.second);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> l, r;
    cin.<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);
    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
        cin &gt;&gt; a[i];
        pos[a[i]].<span class="hljs-built_in">push_back</span>(i);
    &#125;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
        pos[i].<span class="hljs-built_in">push_back</span>(n + <span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;
        cin &gt;&gt; l &gt;&gt; r;
        pii most = <span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>, l, r);
        cout &lt;&lt; <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> * most.first - (r - l + <span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre></div>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-筛选法建堆" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../.././%E7%AD%9B%E9%80%89%E6%B3%95%E5%BB%BA%E5%A0%86/" class="article-date">
  <time class="dt-published" datetime="2021-02-05T04:07:28.000Z" itemprop="datePublished">2021-02-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../.././categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/">奇技淫巧</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../.././%E7%AD%9B%E9%80%89%E6%B3%95%E5%BB%BA%E5%A0%86/">筛选法建堆</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这可能是本学期学习数据结构与算法课的最大收获<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是知道了还有线性建堆的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>线性建堆可能也是有应用场景的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比如用<span class="markdown-them-math-inline">$O(n)$</span>的空间及时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取出前<span class="markdown-them-math-inline">$n/\log n$</span>大的所有数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>
        
          <p class="article-more-link">
            <a href="../.././%E7%AD%9B%E9%80%89%E6%B3%95%E5%BB%BA%E5%A0%86/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../.././tags/%E7%AD%9B%E9%80%89%E6%B3%95%E5%BB%BA%E5%A0%86/" rel="tag">筛选法建堆</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="../.././">&laquo; 上一页</a><a class="page-number" href="../.././">1</a><span class="page-number current">2</span><a class="page-number" href=".././3/">3</a><a class="extend next" rel="next" href=".././3/">下一页 &raquo;</a>
  </nav>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        &copy; 2022 Wilson Xia<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a><br>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="../.././index.html" class="mobile-nav-link">Home</a>
  
    <a href="../.././archives/" class="mobile-nav-link">Archives</a>
  
    <a href="../.././about/" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="../.././js/clipboard.min.js"></script>
<script src="../.././js/jquery-1.4.3.min.js"></script>

<script src="../.././fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="../.././js/script.js"></script>








  <link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css">


  <link rel="stylesheet" href="/katex/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">

  <!-- The loading of KaTeX is deferred to speed up page rendering -->
  <script defer src="/katex/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>

  <!-- To automatically render math in text elements, include the auto-render extension: -->
  <script defer src="/katex/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
      onload="renderMathInElement(document.body);"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ],
        throwOnError : false
      });
    });
  </script>

  </div>
</body>
</html>