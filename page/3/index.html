<!DOCTYPE html><html><head><meta charset="utf-8"><title>Wilson&#39;s blog</title><link rel="stylesheet" href="../../css/fonts/Chinese-normal-normal.min.css"><link rel="stylesheet" href="../../css/fonts/ChineseMono-normal-normal.min.css"><link rel="stylesheet" href="../../css/fonts/Chinese-italic-normal.min.css"><link rel="stylesheet" href="../../css/fonts/Chinese-normal-bold.min.css"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="alternate" href="../../atom.xml" title="Wilson's blog" type="application/atom+xml"><link rel="shortcut icon" href="../../favicon.ico"><link rel="stylesheet" href="../../css/style.css"><link rel="stylesheet" href="../../fancybox/jquery.fancybox-1.3.4.css"><link rel="stylesheet" href="../../katex/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><script defer src="../../katex/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script><script defer src="../../katex/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="container"><div id="wrap"><div id="nav-outer"><nav id="main-nav" class="outer"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/blog/">Home</a> <a class="main-nav-link" href="/blog/archives/">Archives</a> <a class="main-nav-link" href="/blog/paper_list/">Paper List</a> <a class="main-nav-link" href="/blog/about/">About</a><div class="main-nav-space-between"></div><a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS 订阅"></a></nav></div><div id="header-title"><h1 id="logo-wrap"><a href="../../index.html" id="logo">Wilson&#39;s blog</a></h1></div><div id="content" class="outer"><section id="main"><article id="post-区间众数" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../%E5%8C%BA%E9%97%B4%E4%BC%97%E6%95%B0/" class="article-date"><time class="dt-published" datetime="2021-04-20T05:20:43.094Z" itemprop="datePublished">2021-04-20</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E7%AE%97%E6%B3%95/">算法</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../%E5%8C%BA%E9%97%B4%E4%BC%97%E6%95%B0/">区间众数</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>通用求众数离线做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>离散化之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>开线段树维护数出现的频率的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>带单点修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后再用莫队<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>移动区间时就跑一个单点修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>复杂度是<span class="markdown-them-math-inline">$O(n\sqrt{n}\log n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>当只需要找频数超过一半的区间众数的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以这样考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>众数频数如果超过区间长度的一半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么任意划分区间为两段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它必然要么在左半边超过一半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么在右边超过一半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后就可以用线段树维护了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个结点维护当前区间的众数及其频数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当合并时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>找左儿子和右儿子的众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果众数频数超过一半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么众数一定是二者之一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>离散化后对每个数开一个<code>pos</code>数组维护出现位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在这个数组中二分得到这两者<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>左右儿子的众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>在当前区间中出现的频数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取最大者即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样维护出来不一定是真区间众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是如果众数超过区间长度一半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那他一定维护这个众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个复杂度是每次查询<span class="markdown-them-math-inline">$O(\log^2n)$</span>的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>上面的论述中<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>一半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>大概也可以改为其他比例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这带来的问题是满足其他比例的众数可能有多个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而这个比例超过一半时可以保证这样的众数唯一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>还有一种做法是随机化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在待查询区间里找30个数作为候选众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对每个数检查它是否满足频数超过区间长度一半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用上段的方法可以做到<span class="markdown-them-math-inline">$O(\log n)$</span>查询<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果一个数频数超过区间长度一半<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么在区间内任取30个数<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>带放回<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>找不到该众数的概率不超过<span class="markdown-them-math-inline">$2^{-30}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个做法完全可以扩展到其他比例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比例变小时只需提高30这个常数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如要求众数频数超过<span class="markdown-them-math-inline">$1/5$</span>时可以取100个候选众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即可做到<span class="markdown-them-math-inline">$({4\over 5})^{100}\approx2\times10^{-10}$</span>概率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这是选不到真众数的概率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为超过1/5的众数可能有多个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>似乎有点迷惑<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>选不到假众数的概率也是一样的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他们互不影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是没关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于候选众数中几乎必有真众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即使找到了假众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还需要和真众数比频数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以这种算法几乎必然找到真众数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>CF716Div2 D AC代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 300000</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;
<span class="hljs-keyword">int</span> n, m, maxn, a[N + <span class="hljs-number">5</span>];
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span>
    <span class="hljs-keyword">int</span> l, r, mx, aa;
&#125;;
node xds[<span class="hljs-number">4</span> * N+<span class="hljs-number">5</span>];
vector&lt;<span class="hljs-keyword">int</span>&gt; pos[N+<span class="hljs-number">5</span>];

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;
    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">upper_bound</span>(pos[x].<span class="hljs-built_in">begin</span>(), pos[x].<span class="hljs-built_in">end</span>(), r) - <span class="hljs-built_in">lower_bound</span>(pos[x].<span class="hljs-built_in">begin</span>(), pos[x].<span class="hljs-built_in">end</span>(), l);
    <span class="hljs-keyword">return</span> ret;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(l == r) &#123;
        xds[id].l = xds[id].r = l;
        xds[id].mx = <span class="hljs-number">1</span>;
        xds[id].aa = a[l];
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
    <span class="hljs-built_in">build</span>(id * <span class="hljs-number">2</span>, l, mid);
    <span class="hljs-built_in">build</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);
    xds[id].l = l; xds[id].r = r;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cnt</span>(xds[id * <span class="hljs-number">2</span>].aa, l, r) &gt; <span class="hljs-built_in">cnt</span>(xds[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].aa, l, r)) &#123;
        xds[id].mx = <span class="hljs-built_in">cnt</span>(xds[id * <span class="hljs-number">2</span>].aa, l, r);
        xds[id].aa=  xds[id * <span class="hljs-number">2</span>].aa;
    &#125; <span class="hljs-keyword">else</span> &#123;
        xds[id].mx = <span class="hljs-built_in">cnt</span>(xds[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].aa, l, r);
        xds[id].aa=  xds[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].aa;
    &#125;
&#125;

<span class="hljs-function">pii <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;
    <span class="hljs-comment">// (frequency, value)</span>
    pii ret, ret2;
    <span class="hljs-keyword">int</span> f1 = <span class="hljs-number">0</span>, f2 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (l &lt;= xds[id].l &amp;&amp; xds[id].r &lt;= r) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pii</span>(xds[id].mx, xds[id].aa);
    &#125;
    <span class="hljs-keyword">int</span> mid = (xds[id].l + xds[id].r) &gt;&gt; <span class="hljs-number">1</span>, rl = <span class="hljs-built_in">max</span>(l, xds[id].l), rr = <span class="hljs-built_in">min</span>(r, xds[id].r);
    <span class="hljs-keyword">if</span> (l &lt;= mid) &#123;
        ret = <span class="hljs-built_in">get</span>(id * <span class="hljs-number">2</span>, l, r);
        f1 = <span class="hljs-built_in">cnt</span>(ret.second, rl, rr);
    &#125;
    <span class="hljs-keyword">if</span> (r &gt; mid) &#123;
        ret2 =  <span class="hljs-built_in">get</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, l, r);
        f2 = <span class="hljs-built_in">cnt</span>(ret2.second, rl, rr);
    &#125;
    <span class="hljs-keyword">if</span> (f1 &gt; f2) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pii</span>(f1, ret.second);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pii</span>(f2, ret2.second);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> l, r;
    cin.<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);
    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
        cin &gt;&gt; a[i];
        pos[a[i]].<span class="hljs-built_in">push_back</span>(i);
    &#125;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
        pos[i].<span class="hljs-built_in">push_back</span>(n + <span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;
        cin &gt;&gt; l &gt;&gt; r;
        pii most = <span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>, l, r);
        cout &lt;&lt; <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> * most.first - (r - l + <span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre></div></div><footer class="article-footer"></footer></div></article><article id="post-筛选法建堆" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../%E7%AD%9B%E9%80%89%E6%B3%95%E5%BB%BA%E5%A0%86/" class="article-date"><time class="dt-published" datetime="2021-02-05T04:07:28.000Z" itemprop="datePublished">2021-02-05</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/">奇技淫巧</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../%E7%AD%9B%E9%80%89%E6%B3%95%E5%BB%BA%E5%A0%86/">筛选法建堆</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>这可能是本学期学习数据结构与算法课的最大收获<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是知道了还有线性建堆的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>线性建堆可能也是有应用场景的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比如用<span class="markdown-them-math-inline">$O(n)$</span>的空间及时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取出前<span class="markdown-them-math-inline">$n/\log n$</span>大的所有数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p><p class="article-more-link"><a href="../../%E7%AD%9B%E9%80%89%E6%B3%95%E5%BB%BA%E5%A0%86/#more">Read More</a></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E7%AD%9B%E9%80%89%E6%B3%95%E5%BB%BA%E5%A0%86/" rel="tag">筛选法建堆</a></li></ul></footer></div></article><article id="post-ICPC2020济南站" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../ICPC2020%E6%B5%8E%E5%8D%97%E7%AB%99/" class="article-date"><time class="dt-published" datetime="2020-12-27T16:09:10.000Z" itemprop="datePublished">2020-12-28</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E6%B8%B8%E8%AE%B0/">游记</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../ICPC2020%E6%B5%8E%E5%8D%97%E7%AB%99/">ICPC2020济南站</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>话说线上赛有啥游记好写的…但是作为惯例还是写一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p class="article-more-link"><a href="../../ICPC2020%E6%B5%8E%E5%8D%97%E7%AB%99/#more">Read More</a></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%B8%B8%E8%AE%B0/" rel="tag">游记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E9%A2%98%E8%A7%A3/" rel="tag">题解</a></li></ul></footer></div></article><article id="post-BIT在线求第k大数" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../BIT%E5%9C%A8%E7%BA%BF%E6%B1%82%E7%AC%ACk%E5%A4%A7%E6%95%B0/" class="article-date"><time class="dt-published" datetime="2020-07-18T11:43:35.000Z" itemprop="datePublished">2020-07-18</time></a><div class="article-category"><a class="article-category-link" href="../../categories/Algorithm/">Algorithm</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../BIT%E5%9C%A8%E7%BA%BF%E6%B1%82%E7%AC%ACk%E5%A4%A7%E6%95%B0/">BIT在线求第k大数</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>在做小学期<a target="_blank" rel="noopener" href="https://oj.skyair.org/contest/47/problem/3">Day5C题</a><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>在线维护中位数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于我没有做过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也没有想到正解<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>对顶堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>卡了很久<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后用一个奇怪的方法做出来了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>发现这个奇怪的做法复杂度稍高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是可以扩展<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对顶堆只能维护中位数或固定k的第k大数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而奇怪做法可以<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>伪<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>在线查找第k大数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>k可变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>代价是<span class="markdown-them-math-inline">$O(\log^2 n)$</span>的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$n$</span>为数列长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p class="article-more-link"><a href="../../BIT%E5%9C%A8%E7%BA%BF%E6%B1%82%E7%AC%ACk%E5%A4%A7%E6%95%B0/#more">Read More</a></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/BIT/" rel="tag">BIT</a></li></ul></footer></div></article><article id="post-day6E" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../day6E/" class="article-date"><time class="dt-published" datetime="2020-07-18T11:43:35.000Z" itemprop="datePublished">2020-07-18</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E9%A2%98%E8%A7%A3/">题解</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../day6E/">day6E</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><h2 id="题意">题意</h2><p>正权无向图<span class="markdown-them-math-inline">$G$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有<span class="markdown-them-math-inline">$n$</span>个点与<span class="markdown-them-math-inline">$m$</span>条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>你要回答<span class="markdown-them-math-inline">$q$</span>次询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次询问<span class="markdown-them-math-inline">$u,v$</span>两点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>回答对于<span class="markdown-them-math-inline">$u,v$</span>两点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这张图上有多少条边在它们任意一条最短路上出现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p class="article-more-link"><a href="../../day6E/#more">Read More</a></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li></ul></footer></div></article><article id="post-popcount原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../popcount%E5%8E%9F%E7%90%86/" class="article-date"><time class="dt-published" datetime="2020-06-30T04:47:39.000Z" itemprop="datePublished">2020-06-30</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/">奇技淫巧</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../popcount%E5%8E%9F%E7%90%86/">__builtin_popcount原理</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>小学期题用了这个函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>觉得十分高级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>学习一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>这个函数用来数二进制数中1的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>正常的操作是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>看<code>unsigned int</code>二进制表示下最右端是不是1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>若是1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则计数器+1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再右移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>重复32次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样的操作需要进行32次int运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>效率不够高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个问题可以二分解决<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p class="article-more-link"><a href="../../popcount%E5%8E%9F%E7%90%86/#more">Read More</a></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="tag">位运算</a></li></ul></footer></div></article><article id="post-CF630D2F" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../CF630D2F/" class="article-date"><time class="dt-published" datetime="2020-05-08T01:55:40.000Z" itemprop="datePublished">2020-05-08</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E9%A2%98%E8%A7%A3/">题解</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../CF630D2F/">CF630D2F</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>将每个独立集<span class="markdown-them-math-inline">$V$</span>考虑为原图中被染色的一些顶点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而在原图中加边后<span class="markdown-them-math-inline">$E'$</span>可以得到一个子图<span class="markdown-them-math-inline">$G'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个子图如果满足一些条件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$V$</span>就是<span class="markdown-them-math-inline">$E'$</span>生成的子图<span class="markdown-them-math-inline">$G'$</span>中的一个独立集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这些条件为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ol><li>一条边的两端不同时被染色<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>或<span class="markdown-them-math-inline">$V$</span>中任意两点间没有边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li><li>没有孤立顶点被染色<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><span class="markdown-them-math-inline">$V$</span>中的每个点都应当与<span class="markdown-them-math-inline">$E'$</span>中的一条边相连<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li></ol><p class="article-more-link"><a href="../../CF630D2F/#more">Read More</a></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%A0%91%E5%BD%A2dp/" rel="tag">树形dp</a></li></ul></footer></div></article><article id="post-CF620D2E" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../CF620D2E/" class="article-date"><time class="dt-published" datetime="2020-04-29T01:44:42.000Z" itemprop="datePublished">2020-04-29</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E9%A2%98%E8%A7%A3/">题解</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../CF620D2E/">CF620D2E</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>由于一条路径可以包含一条边多次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以如果<span class="markdown-them-math-inline">$a$</span>能经历<span class="markdown-them-math-inline">$k$</span>条边到达<span class="markdown-them-math-inline">$b$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那就可以经过<span class="markdown-them-math-inline">$k+2n$</span>条边到达<span class="markdown-them-math-inline">$b$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只需要在路径中随便找一条边不停折返即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是考虑对树黑白染色<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>注意结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即<strong>树是二分图</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而可以dfs染成黑白两色<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>方便考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p class="article-more-link"><a href="../../CF620D2E/#more">Read More</a></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/tarjan%E7%AE%97%E6%B3%95/" rel="tag">tarjan算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" rel="tag">最近公共祖先</a></li></ul></footer></div></article><article id="post-Dinic算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../Dinic%E7%AE%97%E6%B3%95/" class="article-date"><time class="dt-published" datetime="2020-04-26T06:24:27.000Z" itemprop="datePublished">2020-04-26</time></a><div class="article-category"><a class="article-category-link" href="../../categories/%E7%AE%97%E6%B3%95/">算法</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../Dinic%E7%AE%97%E6%B3%95/">Dinic算法</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><p>本文讲解Dinic算法的思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>算法本身与证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>关于<strong>残余网络</strong>和<strong>增广路</strong>等概念的说明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请看<a href="Ford-Fulkerson%E7%AE%97%E6%B3%95/" title="Ford-Fulkerson算法">Ford-Fulkerson算法</a>这篇文章<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里只致力于改进Ford-Fulkerson算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到一个与<span class="markdown-them-math-inline">$F$</span>无关的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="问题">问题</h2><p>当<span class="markdown-them-math-inline">$F$</span>较大时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>影响Ford-Folkerson算法效率的主要因素在于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>每次dfs可能可以找到许多条路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是该算法中每次dfs只进行一次增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就导致增广次数与<span class="markdown-them-math-inline">$F$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>可能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>相关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一种想法是一次dfs多次增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但这样做能否成功是取决于dfs顺序的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>dfs顺序如何时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>效率较高呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p><h2 id="思路">思路</h2><p>Dinic算法的核心是每次寻找最短的增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并进行增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样做的理由<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>既是依据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也是好处<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次<strong>沿最短增广路</strong>增广后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><em>最短增广路的长度</em>一定不会减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>稍后会给出证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假如有了这一结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次找到最短增广路的长度时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将该长度的增广路[全部增广]<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后重新寻找最短增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其长度至少增1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而增广路长度不会超过<span class="markdown-them-math-inline">$|V|$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>因为增广路是简单路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而增广次数上界<span class="markdown-them-math-inline">$O(|V|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="证明">证明</h2><p>下面证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次<strong>沿最短增广路</strong>增广后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><em>最短增广路的长度</em>一定不会减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在原图上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为寻找最短增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从<span class="markdown-them-math-inline">$s$</span>出发bfs<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设第一次到达点<span class="markdown-them-math-inline">$v$</span>的边为<span class="markdown-them-math-inline">$\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为点<span class="markdown-them-math-inline">$v$</span>编号<span class="markdown-them-math-inline">$n_v=n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由bfs的特性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><em>每条边增量</em><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>指该边终点与起点编号差<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可为负值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后均同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>不超过1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>特别地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$n_s=0,s$</span>为源点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>称这个图为<strong>分层图</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>此时有结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>若<span class="markdown-them-math-inline">$n_t$</span>被更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么最短增广路的长度为<span class="markdown-them-math-inline">$n_t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>为了证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以寻找为<span class="markdown-them-math-inline">$n_t$</span>标号的边的出发点<span class="markdown-them-math-inline">$i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再寻找为<span class="markdown-them-math-inline">$i$</span>标号的边的出发点<span class="markdown-them-math-inline">$j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>…<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最终会回到<span class="markdown-them-math-inline">$s$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且沿每条边标号增1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于每条边增量不超过1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每条边都增1是从0到<span class="markdown-them-math-inline">$n_t$</span>最快的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而我们找到了<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>一条<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>最短增广路<span class="markdown-them-math-inline">$l_{min}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且每个最短增广路中的每条边<span class="markdown-them-math-inline">$\langle u,v\rangle$</span>都满足<span class="markdown-them-math-inline">$n_v=n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>下面使用数学归纳法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>在<strong>分层图</strong>上沿最短增广路增广1次后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>新图中可能出现一些新的反向边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若新图中有增广路<span class="markdown-them-math-inline">$l'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中的边的来源有两种可能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>1边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>原分层图中的边<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>bfs时经历过的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span><span class="markdown-them-math-inline">$\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足<span class="markdown-them-math-inline">$n_v\leq n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></p><p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>2边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>增广时出现的反向边<span class="markdown-them-math-inline">$\langle v,u\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记原边为<span class="markdown-them-math-inline">$\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么由于原边在最短增广路中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一定满足<span class="markdown-them-math-inline">$n_v=n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>那么<em>沿该路径中任何一条边编号增加</em>不超过1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为了从<span class="markdown-them-math-inline">$0$</span>到达<span class="markdown-them-math-inline">$n_t$</span>仍然至少需要<span class="markdown-them-math-inline">$n_t$</span>条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>长度没有变短<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以最短增广路长度没有减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且所有边都仍满足<span class="markdown-them-math-inline">$n_v\leq n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>假设沿最短增广路增广n次后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最短增广路长度不减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当增广<span class="markdown-them-math-inline">$(n+1)$</span>次后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若图中无增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结论成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若图中仍有增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中的边可能是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>1边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>增广n次后的图中的边<span class="markdown-them-math-inline">$\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足<span class="markdown-them-math-inline">$n_v\leq n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></p><p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>2边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>第<span class="markdown-them-math-inline">$(n+1)$</span>次增广时出现的反向边<span class="markdown-them-math-inline">$\langle v,u\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记原边为<span class="markdown-them-math-inline">$\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么由于原边在最短增广路中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一定满足<span class="markdown-them-math-inline">$n_v=n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>类似于上面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以证明沿最短增广路增广<span class="markdown-them-math-inline">$(n+1)$</span>次后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最短增广路长度仍不减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且所有边都仍满足<span class="markdown-them-math-inline">$n_v\leq n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>综上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>沿最短增广路增广后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><em>最短增广路长度</em>不会减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="优化">优化</h2><p>首先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在证明中我们知道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>最短增广路中的每条边<span class="markdown-them-math-inline">$\langle u,v\rangle$</span>都满足<span class="markdown-them-math-inline">$n_v=n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而我们只考虑<em>递增的边</em>不会出现错误<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>实际上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次分层完后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只要找到增广路就可以增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不必局限在最短增广路中增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是自缚手脚<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只考虑递增的边的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>情况立刻不同了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>图成为了DAG<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span>从而<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>边<span class="markdown-them-math-inline">$\langle u,v\rangle$</span>能否使用只与<span class="markdown-them-math-inline">$v$</span>可达的点<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>记符合条件的点集为<span class="markdown-them-math-inline">$V$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$\forall g \in V$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$n_g&gt;n_v$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的情况有关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而与<span class="markdown-them-math-inline">$s$</span>如何到达<span class="markdown-them-math-inline">$u$</span>无关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果某一时刻发现一条边不能使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么在重新bfs<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即重新标号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>之前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无论其他地方如何增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其后的边流量只会减少不会增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这条边都仍然不能用来增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是可以记录这些边使之只遍历一次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次分层至多访问它们<span class="markdown-them-math-inline">$O(|E|)$</span>次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="算法描述">算法描述</h2><p>下面的算法只是大致的描述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>没有伪代码那么明确<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>重在讲清楚过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>希望我做到了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><blockquote><p><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Dinic算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>输入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>网络<span class="markdown-them-math-inline">$G(V,E)$</span> 输出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>最大流<span class="markdown-them-math-inline">$max\_flow$</span></p><p>步骤0. [准备]建立数组<span class="markdown-them-math-inline">$iter[V]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义<span class="markdown-them-math-inline">$max\_flow\gets0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用邻接表<span class="markdown-them-math-inline">$G[V]$</span>存储网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></p><p>步骤1. [建立分层图]bfs(s,0)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当bfs(u,n)时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若<span class="markdown-them-math-inline">$n_u$</span>已定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>返回<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>否则记<span class="markdown-them-math-inline">$n_u=n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并对<span class="markdown-them-math-inline">$G[u]$</span>中的所有元素<span class="markdown-them-math-inline">$v$</span>进行bfs(v, n+1)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>清零<span class="markdown-them-math-inline">$iter[]$</span>数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>步骤2. [有增广路吗<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>]若<span class="markdown-them-math-inline">$n_t$</span>未定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>退出算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>返回<span class="markdown-them-math-inline">$max\_flow$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>步骤3. [寻找增广路]在<span class="markdown-them-math-inline">$G$</span>上DFS<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>寻找从<span class="markdown-them-math-inline">$s$</span>到<span class="markdown-them-math-inline">$t$</span>的简单路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要求该路径上每条边<span class="markdown-them-math-inline">$e\langle u,v\rangle$</span>可用权值<span class="markdown-them-math-inline">$(w_e-f_e)$</span>大于0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且<span class="markdown-them-math-inline">$n_v&gt;n_u$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若找到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记该路径上的权值最小的边权值为<span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则<span class="markdown-them-math-inline">$f\gets0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>DFS(u)时按顺序遍历<span class="markdown-them-math-inline">$G[u]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若<span class="markdown-them-math-inline">$G[u][i]$</span>不可用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$iter[u]\gets iter[u]+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>步骤4. [找到了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新残余网络]如果<span class="markdown-them-math-inline">$f&gt;0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置<span class="markdown-them-math-inline">$max\_flow\gets max\_flow+f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对路径上的每条边<span class="markdown-them-math-inline">$e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置<span class="markdown-them-math-inline">$f_e\gets f_e+f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记其反向边为<span class="markdown-them-math-inline">$e'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置<span class="markdown-them-math-inline">$w_{e'}\gets w_{e'}+f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>返回步骤3<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>步骤5. [没有找到]如果<span class="markdown-them-math-inline">$f=0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>返回步骤1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><h2 id="复杂度">复杂度</h2><p>由于每次dfs都至少使一条边满流<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>从而使之无法使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>dfs次数上界为<span class="markdown-them-math-inline">$O(|E|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在当前弧优化后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次dfs经过的边有两种可能性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>是无用边<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>在增广路里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>无用边在一次分层内总共访问<span class="markdown-them-math-inline">$O(|E|)$</span>次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>成功增广的情况中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>增广路长度不超过<span class="markdown-them-math-inline">$|V|$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次分层中情况<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的总复杂度上界为<span class="markdown-them-math-inline">$O(|E||V|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而每次分层的复杂度上界为<span class="markdown-them-math-inline">$O(|E||V|+|E|)=O(|E||V|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而Dinic算法总的时间复杂度为<span class="markdown-them-math-inline">$O(|E||V|^2)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="模板">模板</h2><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> V 5005 <span class="hljs-comment">//V为顶点最大个数&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;视数据范围而定</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x7fffffffffffffff</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span>
    ll to, w, rev;
&#125;;
vector&lt;edge&gt; G[V];
<span class="hljs-keyword">int</span> num[V], iter[V];
<span class="hljs-keyword">int</span> s, t;<span class="hljs-comment">//源点和汇点&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;是全局变量</span>

<span class="hljs-function">ll <span class="hljs-title">max_flow</span><span class="hljs-params">()</span></span>;
<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(ll u, ll f)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(ll from, ll to, ll w)</span></span>;

<span class="hljs-function">ll <span class="hljs-title">max_flow</span><span class="hljs-params">()</span> </span>&#123;
    ll f = <span class="hljs-number">0</span>, flow = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;
        <span class="hljs-built_in">memset</span>(iter, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(iter));
        <span class="hljs-built_in">bfs</span>();
        <span class="hljs-keyword">if</span>(num[t] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> flow;
        <span class="hljs-keyword">while</span>(f = <span class="hljs-built_in">dfs</span>(s, INF)) &#123;
            flow += f;
        &#125;
    &#125;
&#125;
<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(ll u, ll f)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(u == t) <span class="hljs-keyword">return</span> f;
    ll flow;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> &amp;i = iter[u]; i &lt; G[u].<span class="hljs-built_in">size</span>(); i++) &#123;
        edge &amp;e = G[u][i];<span class="hljs-comment">//注意是引用&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;需要直接修改原图</span>
        <span class="hljs-keyword">if</span>(e.w &gt; <span class="hljs-number">0</span> &amp;&amp; num[u] &lt; num[e.to]) &#123;
            <span class="hljs-keyword">if</span>(flow = <span class="hljs-built_in">dfs</span>(e.to, (f &gt; e.w ? e.w : f))) &#123;
                <span class="hljs-comment">//min函数有些编译器不给过&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;所以用三目</span>
                e.w -= flow;
                <span class="hljs-comment">//直接修改容量而非同时记录f和w&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;只是为了方便</span>
                G[e.to][e.rev].w += flow;
                <span class="hljs-keyword">return</span> flow;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-built_in">memset</span>(num, <span class="hljs-number">-1</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(num));
    queue&lt;<span class="hljs-keyword">int</span>&gt; que;
    que.<span class="hljs-built_in">push</span>(s);
    num[s] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;
        <span class="hljs-keyword">int</span> u = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G[u].<span class="hljs-built_in">size</span>(); i++)&#123;
            edge &amp;e = G[u][i];
            <span class="hljs-keyword">if</span>(e.w &gt; <span class="hljs-number">0</span> &amp;&amp; num[e.to] &lt; <span class="hljs-number">0</span>) &#123;
                num[e.to] = num[u] + <span class="hljs-number">1</span>;
                que.<span class="hljs-built_in">push</span>(e.to);
            &#125;
        &#125;
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(ll from, ll to, ll w)</span> </span>&#123;
    G[from].<span class="hljs-built_in">push_back</span>(edge&#123;to, w, G[to].<span class="hljs-built_in">size</span>()&#125;);
    G[to].<span class="hljs-built_in">push_back</span>(edge&#123;from, <span class="hljs-number">0</span>, G[from].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>&#125;);
&#125;
</code></pre></div><p>如有发现模板的错误请联系我指正<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我将不胜感激<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/Dinic%E7%AE%97%E6%B3%95/" rel="tag">Dinic算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%9C%80%E5%A4%A7%E6%B5%81-%E6%9C%80%E5%B0%8F%E5%89%B2/" rel="tag">最大流&#x2F;最小割</a></li></ul></footer></div></article><article id="post-网络流" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="../../%E7%BD%91%E7%BB%9C%E6%B5%81/" class="article-date"><time class="dt-published" datetime="2020-04-24T03:35:55.000Z" itemprop="datePublished">2020-04-24</time></a><div class="article-category"><a class="article-category-link" href="../../categories/Algorithm/">Algorithm</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="p-name article-title" href="../../%E7%BD%91%E7%BB%9C%E6%B5%81/">网络流</a></h1></header><div class="e-content article-entry" itemprop="articleBody"><h2 id="最大流问题">最大流问题</h2><p>举个例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>互联网上有几台计算机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>某些计算机之间建立了一定带宽的有向连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>目标是将数据从某台指定的计算机<span class="markdown-them-math-inline">$s$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>称为源点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>传输到<span class="markdown-them-math-inline">$t$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>称为汇点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求单位时间内最多能传输多少数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>有许多类似的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都可以抽象成类似的网络流问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>上面的问题是一个<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>单源单汇<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>最大流问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>形式化地描述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><blockquote><p>对无重边与自环的有向图<span class="markdown-them-math-inline">$G(V,E)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若每条边<span class="markdown-them-math-inline">$e\in E$</span>有一个权值<span class="markdown-them-math-inline">$w_e$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>称作该边的容量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且<span class="markdown-them-math-inline">$s\in V,t\in V$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>称该图为一个网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若一个有向图<span class="markdown-them-math-inline">$G'(V,E)$</span>满足<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$G'$</span>与<span class="markdown-them-math-inline">$G$</span>完全相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>除去每条边<span class="markdown-them-math-inline">$e\in E$</span>有另一个权值<span class="markdown-them-math-inline">$f_e$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>称作该边的流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>以外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>并且对<span class="markdown-them-math-inline">$\forall u\in V,u\ne s,u\ne t$</span>满足<span class="markdown-them-math-inline">$\sum\limits_{e=\langle u,v\rangle}{f_e}=\sum\limits_{e=\langle v,u\rangle}{f_e}$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即流入每个顶点的流量等于流出的流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么称该有向图<span class="markdown-them-math-inline">$G'$</span>为网络<span class="markdown-them-math-inline">$G$</span>上的一个流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>该流的流量<span class="markdown-them-math-inline">$f$</span>定义为<span class="markdown-them-math-inline">$\sum\limits_{e=\langle s,u\rangle}{f_e}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一个网络的最大流是指该网络的所有流中流量最大的那个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><p>通常在不引起歧义的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并不区分<strong>最大流</strong>和<strong>最大流的流量</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>对上面的抽象模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解决最大流问题的算法有两类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>增广路算法和预流推进算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>最常用的是增广路算法中的 Ford-Fulkerson 算法和​ Dinic​ 算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里将常见的算法罗列如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><table><thead><tr><th>算法名</th><th>算法分类</th><th>复杂度</th></tr></thead><tbody><tr><td><a href="Ford-Fulkerson%E7%AE%97%E6%B3%95/" title="Ford-Fulkerson算法">Ford-Fulkerson算法</a></td><td>增广路</td><td><span class="markdown-them-math-inline">$O(FE)$</span></td></tr><tr><td><a href="Dinic%E7%AE%97%E6%B3%95/" title="Dinic算法">Dinic算法</a></td><td>增广路</td><td><span class="markdown-them-math-inline">$O(n^2m)$</span></td></tr><tr><td>HLPP<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>我也不会<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></td><td>预流推进</td><td><span class="markdown-them-math-inline">$O(n^2\sqrt{m})$</span></td></tr></tbody></table></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/Dinic%E7%AE%97%E6%B3%95/" rel="tag">Dinic算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/Ford-Fulkerson%E7%AE%97%E6%B3%95/" rel="tag">Ford-Fulkerson算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%9C%80%E5%A4%A7%E6%B5%81-%E6%9C%80%E5%B0%8F%E5%89%B2/" rel="tag">最大流&#x2F;最小割</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" rel="tag">网络流</a></li></ul></footer></div></article><nav id="page-nav"><a class="extend prev" rel="prev" href="../2/">&laquo; 上一页</a><a class="page-number" href="../../">1</a><a class="page-number" href="../2/">2</a><span class="page-number current">3</span><a class="page-number" href="../4/">4</a><a class="extend next" rel="next" href="../4/">下一页 &raquo;</a></nav></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2024 Wilson Xia<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/bill-xia/hexo-theme-mashiro" target="_blank">Mashiro</a><br></div></div></footer></div><nav id="mobile-nav"><a href="/blog/" class="mobile-nav-link">Home</a> <a href="/blog/archives/" class="mobile-nav-link">Archives</a> <a href="/blog/paper_list/" class="mobile-nav-link">Paper List</a> <a href="/blog/about/" class="mobile-nav-link">About</a></nav><script src="../../js/clipboard.min.js"></script><script src="../../js/jquery-1.4.3.min.js"></script><script src="../../fancybox/jquery.fancybox-1.3.4.pack.js"></script><script src="../../js/script.js"></script></div></body></html>