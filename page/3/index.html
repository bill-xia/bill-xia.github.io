<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Wilson&#39;s blog</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bill-xia/blog-font/Chinese-normal-normal.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bill-xia/blog-font/ChineseMono-normal-normal.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bill-xia/blog-font/Chinese-italic-normal.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bill-xia/blog-font/Chinese-normal-bold.min.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  
    <link rel="alternate" href="../../atom.xml" title="Wilson's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="../../favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css">
  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="../../index.html">Home</a>
    
      <a class="main-nav-link" href="../../archives">Archives</a>
    
      <a class="main-nav-link" href="../../about">About</a>
    
    <div class="main-nav-space-between"></div>
    
      <a id="nav-rss-link" class="nav-icon" href="../../atom.xml" title="RSS 订阅"></a>
    
  </nav>
</div>
<div id="header-title">
  <h1 id="logo-wrap">
    <a href="../../index.html" id="logo">Wilson&#39;s blog</a>
  </h1>
  
</div>

      <div id="content" class="outer">
        <section id="main">
  
    <article id="post-BIT在线求第k大数" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../../BIT%E5%9C%A8%E7%BA%BF%E6%B1%82%E7%AC%ACk%E5%A4%A7%E6%95%B0/" class="article-date">
  <time class="dt-published" datetime="2020-07-18T11:43:35.000Z" itemprop="datePublished">2020-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../../categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../../BIT%E5%9C%A8%E7%BA%BF%E6%B1%82%E7%AC%ACk%E5%A4%A7%E6%95%B0/">BIT在线求第k大数</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在做小学期<a target="_blank" rel="noopener" href="https://oj.skyair.org/contest/47/problem/3">Day5C题</a><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>在线维护中位数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于我没有做过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也没有想到正解<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>对顶堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>卡了很久<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后用一个奇怪的方法做出来了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>发现这个奇怪的做法复杂度稍高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是可以扩展<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对顶堆只能维护中位数或固定k的第k大数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而奇怪做法可以<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>伪<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>在线查找第k大数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>k可变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>代价是<span class="markdown-them-math-inline">$O(\log^2 n)$</span>的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$n$</span>为数列长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
        
          <p class="article-more-link">
            <a href="../../BIT%E5%9C%A8%E7%BA%BF%E6%B1%82%E7%AC%ACk%E5%A4%A7%E6%95%B0/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/BIT/" rel="tag">BIT</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-day6E" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../../day6E/" class="article-date">
  <time class="dt-published" datetime="2020-07-18T11:43:35.000Z" itemprop="datePublished">2020-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E9%A2%98%E8%A7%A3/">题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../../day6E/">day6E</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题意">题意</h2>
<p>正权无向图<span class="markdown-them-math-inline">$G$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有<span class="markdown-them-math-inline">$n$</span>个点与<span class="markdown-them-math-inline">$m$</span>条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>你要回答<span class="markdown-them-math-inline">$q$</span>次询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次询问<span class="markdown-them-math-inline">$u,v$</span>两点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>回答对于<span class="markdown-them-math-inline">$u,v$</span>两点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这张图上有多少条边在它们任意一条最短路上出现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
        
          <p class="article-more-link">
            <a href="../../day6E/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-popcount原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../../popcount%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2020-06-30T04:47:39.000Z" itemprop="datePublished">2020-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/">奇技淫巧</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../../popcount%E5%8E%9F%E7%90%86/">__builtin_popcount原理</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>小学期题用了这个函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>觉得十分高级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>学习一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这个函数用来数二进制数中1的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>正常的操作是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>看<code>unsigned int</code>二进制表示下最右端是不是1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>若是1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则计数器+1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再右移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>重复32次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样的操作需要进行32次int运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>效率不够高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个问题可以二分解决<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
        
          <p class="article-more-link">
            <a href="../../popcount%E5%8E%9F%E7%90%86/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="tag">位运算</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CF630D2F" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../../CF630D2F/" class="article-date">
  <time class="dt-published" datetime="2020-05-08T01:55:40.000Z" itemprop="datePublished">2020-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E9%A2%98%E8%A7%A3/">题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../../CF630D2F/">CF630D2F</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>将每个独立集<span class="markdown-them-math-inline">$V$</span>考虑为原图中被染色的一些顶点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而在原图中加边后<span class="markdown-them-math-inline">$E'$</span>可以得到一个子图<span class="markdown-them-math-inline">$G'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个子图如果满足一些条件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$V$</span>就是<span class="markdown-them-math-inline">$E'$</span>生成的子图<span class="markdown-them-math-inline">$G'$</span>中的一个独立集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这些条件为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ol>
<li>一条边的两端不同时被染色<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>或<span class="markdown-them-math-inline">$V$</span>中任意两点间没有边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>没有孤立顶点被染色<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><span class="markdown-them-math-inline">$V$</span>中的每个点都应当与<span class="markdown-them-math-inline">$E'$</span>中的一条边相连<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
</ol>
        
          <p class="article-more-link">
            <a href="../../CF630D2F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%A0%91%E5%BD%A2dp/" rel="tag">树形dp</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CF620D2E" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../../CF620D2E/" class="article-date">
  <time class="dt-published" datetime="2020-04-29T01:44:42.000Z" itemprop="datePublished">2020-04-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E9%A2%98%E8%A7%A3/">题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../../CF620D2E/">CF620D2E</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>由于一条路径可以包含一条边多次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以如果<span class="markdown-them-math-inline">$a$</span>能经历<span class="markdown-them-math-inline">$k$</span>条边到达<span class="markdown-them-math-inline">$b$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那就可以经过<span class="markdown-them-math-inline">$k+2n$</span>条边到达<span class="markdown-them-math-inline">$b$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只需要在路径中随便找一条边不停折返即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是考虑对树黑白染色<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>注意结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即<strong>树是二分图</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而可以dfs染成黑白两色<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>方便考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
        
          <p class="article-more-link">
            <a href="../../CF620D2E/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/tarjan%E7%AE%97%E6%B3%95/" rel="tag">tarjan算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" rel="tag">最近公共祖先</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Dinic算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../../Dinic%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-04-26T06:24:27.000Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../../Dinic%E7%AE%97%E6%B3%95/">Dinic算法</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文讲解Dinic算法的思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>算法本身与证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>关于<strong>残余网络</strong>和<strong>增广路</strong>等概念的说明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请看<a href="/Ford-Fulkerson%E7%AE%97%E6%B3%95/" title="Ford-Fulkerson算法">Ford-Fulkerson算法</a>这篇文章<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里只致力于改进Ford-Fulkerson算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到一个与<span class="markdown-them-math-inline">$F$</span>无关的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="问题">问题</h2>
<p>当<span class="markdown-them-math-inline">$F$</span>较大时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>影响Ford-Folkerson算法效率的主要因素在于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>每次dfs可能可以找到许多条路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是该算法中每次dfs只进行一次增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就导致增广次数与<span class="markdown-them-math-inline">$F$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>可能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>相关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一种想法是一次dfs多次增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但这样做能否成功是取决于dfs顺序的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>dfs顺序如何时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>效率较高呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>
<h2 id="思路">思路</h2>
<p>Dinic算法的核心是每次寻找最短的增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并进行增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样做的理由<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>既是依据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也是好处<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次<strong>沿最短增广路</strong>增广后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><em>最短增广路的长度</em>一定不会减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>稍后会给出证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假如有了这一结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次找到最短增广路的长度时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将该长度的增广路[全部增广]<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后重新寻找最短增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其长度至少增1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而增广路长度不会超过<span class="markdown-them-math-inline">$|V|$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>因为增广路是简单路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而增广次数上界<span class="markdown-them-math-inline">$O(|V|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="证明">证明</h2>
<p>下面证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次<strong>沿最短增广路</strong>增广后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><em>最短增广路的长度</em>一定不会减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在原图上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为寻找最短增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从<span class="markdown-them-math-inline">$s$</span>出发bfs<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设第一次到达点<span class="markdown-them-math-inline">$v$</span>的边为<span class="markdown-them-math-inline">$\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为点<span class="markdown-them-math-inline">$v$</span>编号<span class="markdown-them-math-inline">$n_v=n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由bfs的特性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><em>每条边增量</em><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>指该边终点与起点编号差<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可为负值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后均同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>不超过1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>特别地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$n_s=0,s$</span>为源点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>称这个图为<strong>分层图</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>此时有结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>若<span class="markdown-them-math-inline">$n_t$</span>被更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么最短增广路的长度为<span class="markdown-them-math-inline">$n_t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>为了证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以寻找为<span class="markdown-them-math-inline">$n_t$</span>标号的边的出发点<span class="markdown-them-math-inline">$i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再寻找为<span class="markdown-them-math-inline">$i$</span>标号的边的出发点<span class="markdown-them-math-inline">$j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>…<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最终会回到<span class="markdown-them-math-inline">$s$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且沿每条边标号增1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于每条边增量不超过1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每条边都增1是从0到<span class="markdown-them-math-inline">$n_t$</span>最快的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而我们找到了<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>一条<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>最短增广路<span class="markdown-them-math-inline">$l_{min}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且每个最短增广路中的每条边<span class="markdown-them-math-inline">$\langle u,v\rangle$</span>都满足<span class="markdown-them-math-inline">$n_v=n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>下面使用数学归纳法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>在<strong>分层图</strong>上沿最短增广路增广1次后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>新图中可能出现一些新的反向边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若新图中有增广路<span class="markdown-them-math-inline">$l'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中的边的来源有两种可能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>1边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>原分层图中的边<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>bfs时经历过的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span><span class="markdown-them-math-inline">$\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足<span class="markdown-them-math-inline">$n_v\leq n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>2边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>增广时出现的反向边<span class="markdown-them-math-inline">$\langle v,u\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记原边为<span class="markdown-them-math-inline">$\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么由于原边在最短增广路中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一定满足<span class="markdown-them-math-inline">$n_v=n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>那么<em>沿该路径中任何一条边编号增加</em>不超过1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为了从<span class="markdown-them-math-inline">$0$</span>到达<span class="markdown-them-math-inline">$n_t$</span>仍然至少需要<span class="markdown-them-math-inline">$n_t$</span>条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>长度没有变短<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以最短增广路长度没有减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且所有边都仍满足<span class="markdown-them-math-inline">$n_v\leq n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>假设沿最短增广路增广n次后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最短增广路长度不减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当增广<span class="markdown-them-math-inline">$(n+1)$</span>次后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若图中无增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结论成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若图中仍有增广路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中的边可能是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>1边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>增广n次后的图中的边<span class="markdown-them-math-inline">$\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足<span class="markdown-them-math-inline">$n_v\leq n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>2边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>第<span class="markdown-them-math-inline">$(n+1)$</span>次增广时出现的反向边<span class="markdown-them-math-inline">$\langle v,u\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记原边为<span class="markdown-them-math-inline">$\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么由于原边在最短增广路中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一定满足<span class="markdown-them-math-inline">$n_v=n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>类似于上面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以证明沿最短增广路增广<span class="markdown-them-math-inline">$(n+1)$</span>次后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最短增广路长度仍不减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且所有边都仍满足<span class="markdown-them-math-inline">$n_v\leq n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>综上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>沿最短增广路增广后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><em>最短增广路长度</em>不会减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="优化">优化</h2>
<p>首先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在证明中我们知道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>最短增广路中的每条边<span class="markdown-them-math-inline">$\langle u,v\rangle$</span>都满足<span class="markdown-them-math-inline">$n_v=n_u+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而我们只考虑<em>递增的边</em>不会出现错误<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>实际上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次分层完后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只要找到增广路就可以增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不必局限在最短增广路中增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是自缚手脚<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只考虑递增的边的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span> 情况立刻不同了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>图成为了DAG<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span>从而<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>边<span class="markdown-them-math-inline">$\langle u,v\rangle$</span>能否使用只与<span class="markdown-them-math-inline">$v$</span>可达的点<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>记符合条件的点集为<span class="markdown-them-math-inline">$V$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$\forall g \in V$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$n_g&gt;n_v$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的情况有关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而与<span class="markdown-them-math-inline">$s$</span>如何到达<span class="markdown-them-math-inline">$u$</span>无关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果某一时刻发现一条边不能使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么在重新bfs<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即重新标号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>之前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无论其他地方如何增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其后的边流量只会减少不会增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这条边都仍然不能用来增广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是可以记录这些边使之只遍历一次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次分层至多访问它们<span class="markdown-them-math-inline">$O(|E|)$</span>次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="算法描述">算法描述</h2>
<p>下面的算法只是大致的描述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>没有伪代码那么明确<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>重在讲清楚过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>希望我做到了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Dinic算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>输入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>网络<span class="markdown-them-math-inline">$G(V,E)$</span> 输出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>最大流<span class="markdown-them-math-inline">$max\_flow$</span></p>
<p>步骤0. [准备]建立数组<span class="markdown-them-math-inline">$iter[V]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义<span class="markdown-them-math-inline">$max\_flow\gets0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用邻接表<span class="markdown-them-math-inline">$G[V]$</span>存储网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></p>
<p>步骤1. [建立分层图]bfs(s,0)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当bfs(u,n)时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若<span class="markdown-them-math-inline">$n_u$</span>已定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>返回<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>否则记<span class="markdown-them-math-inline">$n_u=n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并对<span class="markdown-them-math-inline">$G[u]$</span>中的所有元素<span class="markdown-them-math-inline">$v$</span>进行bfs(v, n+1)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>清零<span class="markdown-them-math-inline">$iter[]$</span>数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>步骤2. [有增广路吗<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>]若<span class="markdown-them-math-inline">$n_t$</span>未定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>退出算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>返回<span class="markdown-them-math-inline">$max\_flow$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>步骤3. [寻找增广路]在<span class="markdown-them-math-inline">$G$</span>上DFS<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>寻找从<span class="markdown-them-math-inline">$s$</span>到<span class="markdown-them-math-inline">$t$</span>的简单路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要求该路径上每条边<span class="markdown-them-math-inline">$e\langle u,v\rangle$</span>可用权值<span class="markdown-them-math-inline">$(w_e-f_e)$</span>大于0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且<span class="markdown-them-math-inline">$n_v&gt;n_u$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若找到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记该路径上的权值最小的边权值为<span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则<span class="markdown-them-math-inline">$f\gets0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>DFS(u)时按顺序遍历<span class="markdown-them-math-inline">$G[u]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若<span class="markdown-them-math-inline">$G[u][i]$</span>不可用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$iter[u]\gets iter[u]+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>步骤4. [找到了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新残余网络]如果<span class="markdown-them-math-inline">$f&gt;0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置<span class="markdown-them-math-inline">$max\_flow\gets max\_flow+f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对路径上的每条边<span class="markdown-them-math-inline">$e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置<span class="markdown-them-math-inline">$f_e\gets f_e+f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记其反向边为<span class="markdown-them-math-inline">$e'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置<span class="markdown-them-math-inline">$w_{e'}\gets w_{e'}+f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>返回步骤3<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>步骤5. [没有找到]如果<span class="markdown-them-math-inline">$f=0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>返回步骤1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<h2 id="复杂度">复杂度</h2>
<p>由于每次dfs都至少使一条边满流<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>从而使之无法使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>dfs次数上界为<span class="markdown-them-math-inline">$O(|E|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在当前弧优化后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次dfs经过的边有两种可能性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>是无用边<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>在增广路里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>无用边在一次分层内总共访问<span class="markdown-them-math-inline">$O(|E|)$</span>次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>成功增广的情况中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>增广路长度不超过<span class="markdown-them-math-inline">$|V|$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次分层中情况<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的总复杂度上界为<span class="markdown-them-math-inline">$O(|E||V|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而每次分层的复杂度上界为<span class="markdown-them-math-inline">$O(|E||V|+|E|)=O(|E||V|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而Dinic算法总的时间复杂度为<span class="markdown-them-math-inline">$O(|E||V|^2)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="模板">模板</h2>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> V 5005 <span class="hljs-comment">//V为顶点最大个数&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;视数据范围而定</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x7fffffffffffffff</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span>
    ll to, w, rev;
&#125;;
vector&lt;edge&gt; G[V];
<span class="hljs-keyword">int</span> num[V], iter[V];
<span class="hljs-keyword">int</span> s, t;<span class="hljs-comment">//源点和汇点&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;是全局变量</span>

<span class="hljs-function">ll <span class="hljs-title">max_flow</span><span class="hljs-params">()</span></span>;
<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(ll u, ll f)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(ll from, ll to, ll w)</span></span>;

<span class="hljs-function">ll <span class="hljs-title">max_flow</span><span class="hljs-params">()</span> </span>&#123;
    ll f = <span class="hljs-number">0</span>, flow = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;
        <span class="hljs-built_in">memset</span>(iter, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(iter));
        <span class="hljs-built_in">bfs</span>();
        <span class="hljs-keyword">if</span>(num[t] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> flow;
        <span class="hljs-keyword">while</span>(f = <span class="hljs-built_in">dfs</span>(s, INF)) &#123;
            flow += f;
        &#125;
    &#125;
&#125;
<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(ll u, ll f)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(u == t) <span class="hljs-keyword">return</span> f;
    ll flow;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> &amp;i = iter[u]; i &lt; G[u].<span class="hljs-built_in">size</span>(); i++) &#123;
        edge &amp;e = G[u][i];<span class="hljs-comment">//注意是引用&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;需要直接修改原图</span>
        <span class="hljs-keyword">if</span>(e.w &gt; <span class="hljs-number">0</span> &amp;&amp; num[u] &lt; num[e.to]) &#123;
            <span class="hljs-keyword">if</span>(flow = <span class="hljs-built_in">dfs</span>(e.to, (f &gt; e.w ? e.w : f))) &#123;
                <span class="hljs-comment">//min函数有些编译器不给过&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;所以用三目</span>
                e.w -= flow;
                <span class="hljs-comment">//直接修改容量而非同时记录f和w&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;只是为了方便</span>
                G[e.to][e.rev].w += flow;
                <span class="hljs-keyword">return</span> flow;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-built_in">memset</span>(num, <span class="hljs-number">-1</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(num));
    queue&lt;<span class="hljs-keyword">int</span>&gt; que;
    que.<span class="hljs-built_in">push</span>(s);
    num[s] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;
        <span class="hljs-keyword">int</span> u = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G[u].<span class="hljs-built_in">size</span>(); i++)&#123;
            edge &amp;e = G[u][i];
            <span class="hljs-keyword">if</span>(e.w &gt; <span class="hljs-number">0</span> &amp;&amp; num[e.to] &lt; <span class="hljs-number">0</span>) &#123;
                num[e.to] = num[u] + <span class="hljs-number">1</span>;
                que.<span class="hljs-built_in">push</span>(e.to);
            &#125;
        &#125;
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(ll from, ll to, ll w)</span> </span>&#123;
    G[from].<span class="hljs-built_in">push_back</span>(edge&#123;to, w, G[to].<span class="hljs-built_in">size</span>()&#125;);
    G[to].<span class="hljs-built_in">push_back</span>(edge&#123;from, <span class="hljs-number">0</span>, G[from].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>&#125;);
&#125;
</code></pre></div>
<p>如有发现模板的错误请联系我指正<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我将不胜感激<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/Dinic%E7%AE%97%E6%B3%95/" rel="tag">Dinic算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%9C%80%E5%A4%A7%E6%B5%81-%E6%9C%80%E5%B0%8F%E5%89%B2/" rel="tag">最大流&#x2F;最小割</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-网络流" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../../%E7%BD%91%E7%BB%9C%E6%B5%81/" class="article-date">
  <time class="dt-published" datetime="2020-04-24T03:35:55.000Z" itemprop="datePublished">2020-04-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../../categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../../%E7%BD%91%E7%BB%9C%E6%B5%81/">网络流</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="最大流问题">最大流问题</h2>
<p>举个例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>互联网上有几台计算机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>某些计算机之间建立了一定带宽的有向连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>目标是将数据从某台指定的计算机<span class="markdown-them-math-inline">$s$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>称为源点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>传输到<span class="markdown-them-math-inline">$t$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>称为汇点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求单位时间内最多能传输多少数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>有许多类似的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都可以抽象成类似的网络流问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>上面的问题是一个<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>单源单汇<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>最大流问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>形式化地描述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<blockquote>
<p>对无重边与自环的有向图<span class="markdown-them-math-inline">$G(V,E)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若每条边<span class="markdown-them-math-inline">$e\in E$</span>有一个权值<span class="markdown-them-math-inline">$w_e$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>称作该边的容量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且<span class="markdown-them-math-inline">$s\in V,t\in V$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>称该图为一个网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若一个有向图<span class="markdown-them-math-inline">$G'(V,E)$</span>满足<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$G'$</span>与<span class="markdown-them-math-inline">$G$</span>完全相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>除去每条边<span class="markdown-them-math-inline">$e\in E$</span>有另一个权值<span class="markdown-them-math-inline">$f_e$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>称作该边的流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>以外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>并且对<span class="markdown-them-math-inline">$\forall u\in V,u\ne s,u\ne t$</span>满足<span class="markdown-them-math-inline">$\sum\limits_{e=\langle u,v\rangle}{f_e}=\sum\limits_{e=\langle v,u\rangle}{f_e}$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即流入每个顶点的流量等于流出的流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么称该有向图<span class="markdown-them-math-inline">$G'$</span>为网络<span class="markdown-them-math-inline">$G$</span>上的一个流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>该流的流量<span class="markdown-them-math-inline">$f$</span>定义为<span class="markdown-them-math-inline">$\sum\limits_{e=\langle s,u\rangle}{f_e}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一个网络的最大流是指该网络的所有流中流量最大的那个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>通常在不引起歧义的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并不区分<strong>最大流</strong>和<strong>最大流的流量</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>对上面的抽象模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解决最大流问题的算法有两类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>增广路算法和预流推进算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>最常用的是增广路算法中的 Ford-Fulkerson 算法和​ Dinic​ 算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里将常见的算法罗列如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<table>
<thead>
<tr>
<th>算法名</th>
<th>算法分类</th>
<th>复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/Ford-Fulkerson%E7%AE%97%E6%B3%95/" title="Ford-Fulkerson算法">Ford-Fulkerson算法</a></td>
<td>增广路</td>
<td><span class="markdown-them-math-inline">$O(FE)$</span></td>
</tr>
<tr>
<td><a href="/Dinic%E7%AE%97%E6%B3%95/" title="Dinic算法">Dinic算法</a></td>
<td>增广路</td>
<td><span class="markdown-them-math-inline">$O(n^2m)$</span></td>
</tr>
<tr>
<td>HLPP<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>我也不会<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></td>
<td>预流推进</td>
<td><span class="markdown-them-math-inline">$O(n^2\sqrt{m})$</span></td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/Dinic%E7%AE%97%E6%B3%95/" rel="tag">Dinic算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/Ford-Fulkerson%E7%AE%97%E6%B3%95/" rel="tag">Ford-Fulkerson算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%9C%80%E5%A4%A7%E6%B5%81-%E6%9C%80%E5%B0%8F%E5%89%B2/" rel="tag">最大流&#x2F;最小割</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" rel="tag">网络流</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Ford-Fulkerson算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../../Ford-Fulkerson%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-04-24T03:28:02.000Z" itemprop="datePublished">2020-04-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../../Ford-Fulkerson%E7%AE%97%E6%B3%95/">Ford-Fulkerson算法</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文讲解Ford-Fulkerson算法的思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>算法本身与证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后会给出模板<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>Ford-Fulkerson算法是增广路算法的一种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用于求解最大流问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不明背景请看<a href="/%E7%BD%91%E7%BB%9C%E6%B5%81">网络流</a>这篇文章<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="分析">分析</h2>
<h3 id="朴素算法">朴素算法</h3>
<p>朴素的想法<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>的一种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>是这样的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在图中DFS<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一旦找到一条从s指向t并且可以在这条路径上添加流量<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>每条边<span class="markdown-them-math-inline">$e$</span>都满足<span class="markdown-them-math-inline">$f_e&lt;w_e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么就在这条路径的所有边上同时不断添加流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到无法再添加<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>某条边<span class="markdown-them-math-inline">$e$</span>上<span class="markdown-them-math-inline">$f_e=w_e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>直到无法再找到任何这样的路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即得到最大流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如下图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="https://s1.ax1x.com/2020/07/18/Ug5n0I.png" alt="朴素想法求最大流"></p>
<p>上面的图中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>黑色为边的容量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>红色为边的容量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>图1为原来的网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中1为源点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>6为汇点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>图二为DFS时<strong>可能</strong>得到的一个图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以看到上面的算法在这里就会停止<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而图三是该网络的最大流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以轻松地验证这一点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为从1出发的边都已经满流了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无法再增加新的流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>注意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>DFS<strong>可能</strong>得到最优解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但不是一定得到最优解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>所以上述的算法是错误的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是它错在哪里呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>
<h3 id="改进">改进</h3>
<p>观察图3<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个流比图2多的流如图4<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="https://s1.ax1x.com/2020/07/18/Ug5lh8.png" alt="朴素想法与最大流之差"></p>
<p>从图4看<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它是把图2中<span class="markdown-them-math-inline">$2\rightarrow4$</span>已有的流量1<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>推了回去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>而产生的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这也正是增广路算法的核心所在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这看起来不可理喻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>原图中没有的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为什么凭空造出来一条就正确呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>
<h3 id="解释">解释</h3>
<p>仔细观察图2和图3<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就会发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$4\rightarrow6$</span>的边流量没变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仍然是1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$2\rightarrow4$</span>的流量没有了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那最大流中谁为4提供那一个流量呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>显然是<span class="markdown-them-math-inline">$1\rightarrow3\rightarrow4$</span>的路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>同理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$1\rightarrow2$</span>的流量也没有变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它从<span class="markdown-them-math-inline">$2\rightarrow5\rightarrow6$</span>的路径流出去了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这就可以想象成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>节点4不知道是谁给他的流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是在这个过程中4的上游的信息被屏蔽了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时2的下游的信息也被屏蔽了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只要有人能为4提供流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他就什么都不知道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>同样的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只要有人能从2运走流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他也什么都不知道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在新的流中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>原本只有一份的流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$1\rightarrow3\rightarrow 4$</span>流走了一份<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$1\rightarrow2\rightarrow5$</span>又流走了一份<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以流量+1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>所以<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\langle u,v\rangle$</span>的反向边<span class="markdown-them-math-inline">$\langle v,u\rangle$</span>的意义就是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在<span class="markdown-them-math-inline">$\langle u,v\rangle$</span>有流<span class="markdown-them-math-inline">$f$</span>的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果有一个路径可以从<span class="markdown-them-math-inline">$v$</span>流入<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>称其前面的那段路经为上游<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>再从<span class="markdown-them-math-inline">$u$</span>流出<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>称其后的那段路径为下游<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>且流为<span class="markdown-them-math-inline">$f_0\le f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么就可以认为上游为<span class="markdown-them-math-inline">$v$</span>提供原来的一部分流<span class="markdown-them-math-inline">$f_0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而从<span class="markdown-them-math-inline">$u$</span>流入的那些<span class="markdown-them-math-inline">$f_0$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>改道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>从下游流出了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>上面的做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以算作对朴素DFS做法的一个修正<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大概可以理解为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>避免了因DFS顺序不确定而导致的错误<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>于是对一个流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以对图上所有有流<span class="markdown-them-math-inline">$f$</span>的边<span class="markdown-them-math-inline">$\langle u,v\rangle$</span>建立反向边<span class="markdown-them-math-inline">$\langle v,u\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其容量为<span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样得到的新的图称为<strong>残余网络</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>残余网络上从<span class="markdown-them-math-inline">$s$</span>到<span class="markdown-them-math-inline">$t$</span>的路径叫做<strong>增广路</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在<strong>残余网络</strong>上进行<strong>dfs</strong>沿着<strong>增广路</strong>来添加流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就是Ford-Fulkerson算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="算法描述">算法描述</h2>
<p>对网络上的每个流<span class="markdown-them-math-inline">$G(V,E)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义与之对应的<strong>残余网络</strong><span class="markdown-them-math-inline">$G'(V,E')$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>若<span class="markdown-them-math-inline">$f_e&gt;0(e=\langle u,v\rangle\in E)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$e\in E'$</span>且<span class="markdown-them-math-inline">$rev(e)=\langle v,u\rangle\in E'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且<span class="markdown-them-math-inline">$w_{rev(e)}=f_e,f_{rev(e)}=0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$E'$</span>中的元素只有刚才描述的那些<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>那么算法可以描述为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<blockquote>
<p>Ford-Fulkerson算法</p>
<p>输入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>网络<span class="markdown-them-math-inline">$G$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>一个图<span class="markdown-them-math-inline">$G(V,E)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$E$</span>中的边<span class="markdown-them-math-inline">$e$</span>有权重<span class="markdown-them-math-inline">$w_e\in\mathbb{N_+}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$max\_flow=0$</span></p>
<p>输出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>该网络上的最大流的流量<span class="markdown-them-math-inline">$f$</span></p>
<p>步骤0. [建立反向边]定义<span class="markdown-them-math-inline">$max\_flow\gets0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用邻接表G[V]存储网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>对<span class="markdown-them-math-inline">$E$</span>中的每条边<span class="markdown-them-math-inline">$e=\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>作其反向边<span class="markdown-them-math-inline">$e'=\langle v,u\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并置<span class="markdown-them-math-inline">$w_{e'}\gets0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>步骤1. [寻找增广路]在<span class="markdown-them-math-inline">$G$</span>上DFS<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>寻找从<span class="markdown-them-math-inline">$s$</span>到<span class="markdown-them-math-inline">$t$</span>的简单路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要求该路径上每条边可用权值<span class="markdown-them-math-inline">$(w_e-f_e)$</span>大于0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若找到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记该路径上的权值最小的边权值为<span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则<span class="markdown-them-math-inline">$f\gets0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>步骤2. [找到了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新残余网络]如果<span class="markdown-them-math-inline">$f&gt;0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置<span class="markdown-them-math-inline">$max\_flow\gets max\_flow+f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对路径上的每条边<span class="markdown-them-math-inline">$e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置<span class="markdown-them-math-inline">$f_e\gets f_e+f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记其反向边为<span class="markdown-them-math-inline">$e'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置<span class="markdown-them-math-inline">$w_{e'}\gets w_{e'}+f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>返回1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>步骤3. [没有找到]如果<span class="markdown-them-math-inline">$f=0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>输出<span class="markdown-them-math-inline">$max\_flow$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>算法结束<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>最大流不会超过从<span class="markdown-them-math-inline">$s$</span>出发的所有边的边权和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而该算法中每次进入步骤1后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$f$</span>总是正整数<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>也有<span class="markdown-them-math-inline">$f=0$</span>的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时算法结束<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以该算法对整数总是有限的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若记最大流流量上界为<span class="markdown-them-math-inline">$F$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则该算法最多进入步骤1<span class="markdown-them-math-inline">$(F+1)$</span>次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而每次进入步骤1需要<span class="markdown-them-math-inline">$O(|E|)$</span>的复杂度进行搜索<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>所以总的时间复杂度是<span class="markdown-them-math-inline">$O(F|E|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但这个复杂度上界是很松的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实际用起来效率比较高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以有时即使估计复杂度偏高也可以使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对<span class="markdown-them-math-inline">$F$</span>较小的情况则可以轻松应对<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="证明">证明</h2>
<p>在Ford-Fulkerson算法结束后的残余网络上没有<span class="markdown-them-math-inline">$s\rightarrow t$</span>路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>残余网络上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>从<span class="markdown-them-math-inline">$s$</span>可达的所有点构成的集合<span class="markdown-them-math-inline">$S$</span>不包含<span class="markdown-them-math-inline">$t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记<span class="markdown-them-math-inline">$T=V-S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$T$</span>不空<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且<span class="markdown-them-math-inline">$T\cap S=\varnothing$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>结论1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>从<span class="markdown-them-math-inline">$S$</span>指向<span class="markdown-them-math-inline">$T$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>满足<span class="markdown-them-math-inline">$u\in S,v\in T$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的边<span class="markdown-them-math-inline">$e=\langle u, v\rangle$</span>都应当满流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即<span class="markdown-them-math-inline">$w_e=f_e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>否则<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于从<span class="markdown-them-math-inline">$s$</span>可达<span class="markdown-them-math-inline">$u$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$s$</span>也可以从<span class="markdown-them-math-inline">$s\rightarrow u\rightarrow v$</span>到达<span class="markdown-them-math-inline">$v$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$v\in S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>矛盾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>结论2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>从<span class="markdown-them-math-inline">$T$</span>指向<span class="markdown-them-math-inline">$S$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>满足<span class="markdown-them-math-inline">$u\in T,v\in S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的边<span class="markdown-them-math-inline">$e=\langle u,v\rangle$</span>流量必为0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>否则<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$s$</span>可由其反向边到达<span class="markdown-them-math-inline">$u$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>即<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>流入<span class="markdown-them-math-inline">$S$</span>的流量为0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>反向边就是在这里用到的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p>对于任意一个流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$S-\{s\}$</span>中的点流入的流量都等于流出的流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么流入<span class="markdown-them-math-inline">$S-\{s\}$</span>的流量<span class="markdown-them-math-inline">$f_{in}$</span>等于从<span class="markdown-them-math-inline">$S$</span>流向<span class="markdown-them-math-inline">$T$</span>的所有边的流量和<span class="markdown-them-math-inline">$S_f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个和不超过从<span class="markdown-them-math-inline">$S$</span>流向<span class="markdown-them-math-inline">$T$</span>的所有边的容量和<span class="markdown-them-math-inline">$S_w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>写在一起就是<span class="markdown-them-math-inline">$f_{in}=S_f\le S_w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>从而从<span class="markdown-them-math-inline">$s$</span>流出的流量<span class="markdown-them-math-inline">$f_s$</span>一定不超过<span class="markdown-them-math-inline">$S_w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为<span class="markdown-them-math-inline">$f_s$</span>应当是<span class="markdown-them-math-inline">$f_{in}$</span>的一部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>即<span class="markdown-them-math-inline">$f_{s}\le S_w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是对任意流的结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>而对于残余网络<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>注意残余网络也是一个流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由结论1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$S_f=S_w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>又由结论2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$f_s$</span>即为<span class="markdown-them-math-inline">$f_{in}$</span>的全部<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以有<span class="markdown-them-math-inline">$f_s=f_{in}=S_w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以<span class="markdown-them-math-inline">$f_s$</span>为所有流中的最大者<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>也可以用反证法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若存在比Ford-Fulkerson算法得到的流更大的流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仍然观察上面的点集<span class="markdown-them-math-inline">$S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时从<span class="markdown-them-math-inline">$s$</span>流出的流量<span class="markdown-them-math-inline">$f_{s'}$</span>应当超过了<span class="markdown-them-math-inline">$f_x=S_w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这时<span class="markdown-them-math-inline">$S-\{s\}$</span>中的点不可能满足<em>流入每个顶点的流量等于流出的流量</em><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以这样的流不存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>至此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就证明了Ford-Fulkerson算法的正确性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="模板">模板</h2>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> V 5005 <span class="hljs-comment">//V为顶点最大个数&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;视数据范围而定</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x7fffffffffffffff</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span>
    ll to, w, rev;
&#125;;
vector&lt;edge&gt; G[V];
<span class="hljs-keyword">int</span> s, t;<span class="hljs-comment">//源点和汇点&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;是全局变量</span>
<span class="hljs-keyword">bool</span> vis[V];

<span class="hljs-function">ll <span class="hljs-title">max_flow</span><span class="hljs-params">()</span></span>;
<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(ll u, ll f)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(ll from, ll to, ll w)</span></span>;

<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(ll u, ll f)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    vis[u] = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span>(u == t) <span class="hljs-keyword">return</span> f;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G[u].<span class="hljs-built_in">size</span>(); i++) &#123;
        edge &amp;e = G[u][i];<span class="hljs-comment">//注意是引用&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;需要直接修改原图</span>
        <span class="hljs-keyword">if</span>(!vis[e.to] &amp;&amp; e.w &gt; <span class="hljs-number">0</span>) &#123;
            ll curf = <span class="hljs-built_in">dfs</span>(e.to, (f &gt; e.w) ? e.w : f);
            <span class="hljs-comment">//min函数有些编译器不给过</span>
            <span class="hljs-keyword">if</span>(curf &gt; <span class="hljs-number">0</span>) &#123;
                e.w -= curf;
                <span class="hljs-comment">//直接修改容量而非同时记录f和w&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;只是为了方便</span>
                G[e.to][e.rev].w += curf;
                <span class="hljs-keyword">return</span> curf;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
<span class="hljs-function">ll <span class="hljs-title">max_flow</span><span class="hljs-params">()</span> </span>&#123;
    ll maxf = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;
        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));
        ll f = <span class="hljs-built_in">dfs</span>(s, INF);
        <span class="hljs-keyword">if</span>(f == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
        maxf += f;
    &#125;
    <span class="hljs-keyword">return</span> maxf;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(ll from, ll to, ll w)</span> </span>&#123;
    G[from].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(to, G[to].<span class="hljs-built_in">size</span>(), w));
    G[to].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(from, G[from].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));
&#125;
</code></pre></div>
<p>如有发现模板的错误请联系我指正<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我将不胜感激<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/Ford-Fulkerson%E7%AE%97%E6%B3%95/" rel="tag">Ford-Fulkerson算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%9C%80%E5%A4%A7%E6%B5%81-%E6%9C%80%E5%B0%8F%E5%89%B2/" rel="tag">最大流&#x2F;最小割</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-POJ2987-firing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="../../POJ2987-firing/" class="article-date">
  <time class="dt-published" datetime="2020-04-23T14:20:31.000Z" itemprop="datePublished">2020-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../../categories/%E9%A2%98%E8%A7%A3/">题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../../POJ2987-firing/">POJ2987-Firing</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这是一道<strong>最大点权闭合图</strong>的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有论文<a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/986baf00b52acfc789ebc9a9.html">最小割模型在信息学竞赛中的应用</a><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>%%<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这类问题的解法是建图转化成最小割问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再用最大流求解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>
        
          <p class="article-more-link">
            <a href="../../POJ2987-firing/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/Dinic%E7%AE%97%E6%B3%95/" rel="tag">Dinic算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../tags/%E6%9C%80%E5%A4%A7%E7%82%B9%E6%9D%83%E9%97%AD%E5%90%88%E5%9B%BE/" rel="tag">最大点权闭合图</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="../2/">&laquo; 上一页</a><a class="page-number" href="../../">1</a><a class="page-number" href="../2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        &copy; 2022 Wilson Xia<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a><br>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../../about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="../../js/clipboard.min.js"></script>
<script src="../../js/jquery-1.4.3.min.js"></script>

<script src="../../fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="../../js/script.js"></script>








<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$', right: '$', display: false},
        {left: '\\(', right: '\\)', display: false},
        {left: '\\[', right: '\\]', display: true}
      ],
      throwOnError : false
    });
  });
</script>

  </div>
</body>
</html>