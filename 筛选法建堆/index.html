<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>筛选法建堆 | Wilson&#39;s blog | 我的算法竞赛知识</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="这可能是本学期学习数据结构与算法课的最大收获，就是知道了还有线性建堆的方法。线性建堆可能也是有应用场景的，比如用$O(n)$的空间及时间复杂度，取出前$n/\log n$大的所有数。（？">
  
  
    <link rel="alternate" href="../atom.xml" title="Wilson's blog | 我的算法竞赛知识" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="../favicon.ico">
  
  <link rel="stylesheet" href="../css/style.css">
  
    <link rel="stylesheet" href="../fancybox/jquery.fancybox-1.3.4.css">
  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="../index.html">Home</a>
    
      <a class="main-nav-link" href="../archives">Archives</a>
    
      <a class="main-nav-link" href="../about">About</a>
    
    <div class="main-nav-space-between"></div>
    
      <a id="nav-rss-link" class="nav-icon" href="../atom.xml" title="RSS 订阅"></a>
    
  </nav>
</div>
<div id="header-title">
  <h1 id="logo-wrap">
    <a href="../index.html" id="logo">Wilson&#39;s blog | 我的算法竞赛知识</a>
  </h1>
  
</div>

      <div id="content" class="outer">
        <section id="main"><article id="post-筛选法建堆" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="" class="article-date">
  <time class="dt-published" datetime="2021-02-05T04:07:28.000Z" itemprop="datePublished">2021-02-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/">奇技淫巧</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      筛选法建堆
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这可能是本学期学习数据结构与算法课的最大收获<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是知道了还有线性建堆的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>线性建堆可能也是有应用场景的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比如用<span class="markdown-them-math-inline">$O(n)$</span>的空间及时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取出前<span class="markdown-them-math-inline">$n/\log n$</span>大的所有数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>
<span id="more"></span>
<h2 id="算法描述">算法描述</h2>
<p>筛选法作用在一棵二叉树上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在不改变其形态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>只交换其元素的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使其满足堆的定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>所以无论使用二叉链表还是数组建立二叉树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都可以使用筛选法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>并且这个方法不改变树的形态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不用担心深度增加之类的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>筛选法就是将所有非叶子节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>按照树上的祖孙关系<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>孙子在先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>祖先在后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>得到的一个拓扑序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进行如下操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>若这个叶子节点大于其每个儿子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跳过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>否则将其与较大的那个儿子交换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到满足<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>显然这个操作得到的是一个堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>下面证明这个操作的复杂度是<span class="markdown-them-math-inline">$O(n)$</span>的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="复杂度证明">复杂度证明</h2>
<p>考虑<span class="markdown-them-math-inline">$n$</span>层的完美二叉树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最坏情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>第<span class="markdown-them-math-inline">$k$</span>层结点交换<span class="markdown-them-math-inline">$(n-k)$</span>次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>第<span class="markdown-them-math-inline">$k$</span>层结点有<span class="markdown-them-math-inline">$2^{k-1}$</span>个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是总交换次数为</p>
<div class="markdown-them-math-block">$$\begin{aligned}
  &amp; \sum_{k=1}^{n}(n-k)2^{k-1}\\
= &amp; n\sum_{k=1}^{n}2^{k-1}-\sum_{k=1}^{n}k2^{k-1}\\
= &amp; (n2^n-n)-(\sum_{k=1}^{n}2^{k-1}+\sum_{k=2}^{n}2^{k-1}+...+\sum_{k=n}^{n}2^{k-1})\\
= &amp; (n2^n-n)-\Big[(2^n-2^0)+(2^n-2^1)+...+(2^n-2^{n-1})\Big]\\
= &amp; (n2^n-n)-(n2^n-2^n+1)\\
= &amp; 2^n - n - 1
\end{aligned}
$$</div><p>是元素个数级别的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对其他的完全二叉树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不妨想象将其最后一层填充满<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然也是线性的时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这个算法不占用辅助空间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>空间复杂度仅为原来的数组空间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是线性的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/%E7%AD%9B%E9%80%89%E6%B3%95%E5%BB%BA%E5%A0%86/" rel="tag">筛选法建堆</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../%E5%8C%BA%E9%97%B4%E4%BC%97%E6%95%B0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          区间众数
        
      </div>
    </a>
  
  
    <a href="../ICPC2020%E6%B5%8E%E5%8D%97%E7%AB%99/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          ICPC2020济南站
        
      </div>
    </a>
  
</nav>

  
</article>


</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        &copy; 2022 Wilson Xia<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a><br>
<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">陕ICP备2021014297号</a>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="../js/clipboard.min.js"></script>
<script src="../js/jquery-1.4.3.min.js"></script>

<script src="../fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="../js/script.js"></script>






<script>
  MathJax = {
    options: {
      enableMenu: false
    },
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
    }
  };
</script>
<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
    CommonHTML: {
      linebreaks: false
    }
  });
  </script> -->
<script type="text/javascript" id="MathJax-script" async
  src="../mathjax/tex-chtml.js">
</script>
<!-- <script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_CHTML">
</script> -->



  </div>
</body>
</html>