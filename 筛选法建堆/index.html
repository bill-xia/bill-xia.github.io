<!DOCTYPE html><html><head><meta charset="utf-8"><title>筛选法建堆 | Wilson&#39;s blog</title><link rel="stylesheet" href="/css/fonts/Chinese-normal-normal.min.css"><link rel="stylesheet" href="/css/fonts/ChineseMono-normal-normal.min.css"><link rel="stylesheet" href="/css/fonts/Chinese-italic-normal.min.css"><link rel="stylesheet" href="/css/fonts/Chinese-normal-bold.min.css"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="这可能是本学期学习数据结构与算法课的最大收获，就是知道了还有线性建堆的方法。线性建堆可能也是有应用场景的，比如用$O(n)$的空间及时间复杂度，取出前$n/\log n$大的所有数。（？"><link rel="alternate" href="../atom.xml" title="Wilson's blog" type="application/atom+xml"><link rel="shortcut icon" href="../favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css"><link rel="stylesheet" href="/katex/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><script defer src="/katex/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script><script defer src="/katex/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="container"><div id="wrap"><div id="nav-outer"><nav id="main-nav" class="outer"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="../index.html">Home</a> <a class="main-nav-link" href="../archives/">Archives</a> <a class="main-nav-link" href="../paper_list/">Paper List</a> <a class="main-nav-link" href="../about/">About</a><div class="main-nav-space-between"></div><a id="nav-rss-link" class="nav-icon" href="../atom.xml" title="RSS 订阅"></a></nav></div><div id="header-title"><h1 id="logo-wrap"><a href="../index.html" id="logo">Wilson&#39;s blog</a></h1></div><div id="content" class="outer"><section id="main"><article id="post-筛选法建堆" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="" class="article-date"><time class="dt-published" datetime="2021-02-05T04:07:28.000Z" itemprop="datePublished">2021-02-05</time></a><div class="article-category"><a class="article-category-link" href="../categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/">奇技淫巧</a></div></div><div class="article-inner"><header class="article-header"><h1 class="p-name article-title" itemprop="headline name">筛选法建堆</h1></header><div class="e-content article-entry" itemprop="articleBody"><p>这可能是本学期学习数据结构与算法课的最大收获<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是知道了还有线性建堆的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>线性建堆可能也是有应用场景的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比如用<span class="markdown-them-math-inline">$O(n)$</span>的空间及时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取出前<span class="markdown-them-math-inline">$n/\log n$</span>大的所有数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p><span id="more"></span><h2 id="算法描述">算法描述</h2><p>筛选法作用在一棵二叉树上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在不改变其形态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>只交换其元素的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使其满足堆的定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>所以无论使用二叉链表还是数组建立二叉树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都可以使用筛选法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>并且这个方法不改变树的形态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不用担心深度增加之类的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>筛选法就是将所有非叶子节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>按照树上的祖孙关系<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>孙子在先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>祖先在后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>得到的一个拓扑序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进行如下操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>若这个叶子节点大于其每个儿子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跳过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></p><p><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>否则将其与较大的那个儿子交换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到满足<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>显然这个操作得到的是一个堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>下面证明这个操作的复杂度是<span class="markdown-them-math-inline">$O(n)$</span>的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="复杂度证明">复杂度证明</h2><p>考虑<span class="markdown-them-math-inline">$n$</span>层的完美二叉树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最坏情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>第<span class="markdown-them-math-inline">$k$</span>层结点交换<span class="markdown-them-math-inline">$(n-k)$</span>次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>第<span class="markdown-them-math-inline">$k$</span>层结点有<span class="markdown-them-math-inline">$2^{k-1}$</span>个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是总交换次数为</p><div class="markdown-them-math-block">$$\begin{aligned} &amp; \sum_{k=1}^{n}(n-k)2^{k-1}\\ = &amp; n\sum_{k=1}^{n}2^{k-1}-\sum_{k=1}^{n}k2^{k-1}\\ = &amp; (n2^n-n)-(\sum_{k=1}^{n}2^{k-1}+\sum_{k=2}^{n}2^{k-1}+...+\sum_{k=n}^{n}2^{k-1})\\ = &amp; (n2^n-n)-\Big[(2^n-2^0)+(2^n-2^1)+...+(2^n-2^{n-1})\Big]\\ = &amp; (n2^n-n)-(n2^n-2^n+1)\\ = &amp; 2^n - n - 1 \end{aligned} $$</div><p>是元素个数级别的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对其他的完全二叉树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不妨想象将其最后一层填充满<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>显然也是线性的时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>这个算法不占用辅助空间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>空间复杂度仅为原来的数组空间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是线性的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"><section id="isso-thread"><noscript>Javascript needs to be activated to view comments.</noscript></section><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/%E7%AD%9B%E9%80%89%E6%B3%95%E5%BB%BA%E5%A0%86/" rel="tag">筛选法建堆</a></li></ul></footer></div><nav id="article-nav"><a href="../%E5%8C%BA%E9%97%B4%E4%BC%97%E6%95%B0/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">区间众数</div></a><a href="../ICPC2020%E6%B5%8E%E5%8D%97%E7%AB%99/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">ICPC2020济南站</div></a></nav></article></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2024 Wilson Xia<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/bill-xia/hexo-theme-mashiro" target="_blank">Mashiro</a><br></div></div></footer></div><nav id="mobile-nav"><a href="../index.html" class="mobile-nav-link">Home</a> <a href="../archives/" class="mobile-nav-link">Archives</a> <a href="../paper_list/" class="mobile-nav-link">Paper List</a> <a href="../about/" class="mobile-nav-link">About</a></nav><script src="../js/clipboard.min.js"></script><script src="../js/jquery-1.4.3.min.js"></script><script src="../fancybox/jquery.fancybox-1.3.4.pack.js"></script><script src="../js/script.js"></script><script data-isso="https://isso.wilsonxia.cn" src="https://isso.wilsonxia.cn/js/embed.min.js"></script></div></body></html>