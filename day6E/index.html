<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>day6E | Wilson&#39;s blog</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bill-xia/blog-font/Chinese-normal-normal.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bill-xia/blog-font/ChineseMono-normal-normal.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bill-xia/blog-font/Chinese-italic-normal.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bill-xia/blog-font/Chinese-normal-bold.min.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="题意
正权无向图$G$，有$n$个点与$m$条边。你要回答$q$次询问，每次询问$u,v$两点，回答对于$u,v$两点，这张图上有多少条边在它们任意一条最短路上出现。">
  
  
    <link rel="alternate" href="../atom.xml" title="Wilson's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="../favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css">
  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="../index.html">Home</a>
    
      <a class="main-nav-link" href="../archives">Archives</a>
    
      <a class="main-nav-link" href="../about">About</a>
    
    <div class="main-nav-space-between"></div>
    
      <a id="nav-rss-link" class="nav-icon" href="../atom.xml" title="RSS 订阅"></a>
    
  </nav>
</div>
<div id="header-title">
  <h1 id="logo-wrap">
    <a href="../index.html" id="logo">Wilson&#39;s blog</a>
  </h1>
  
</div>

      <div id="content" class="outer">
        <section id="main"><article id="post-day6E" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="" class="article-date">
  <time class="dt-published" datetime="2020-07-18T11:43:35.000Z" itemprop="datePublished">2020-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../categories/%E9%A2%98%E8%A7%A3/">题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      day6E
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题意">题意</h2>
<p>正权无向图<span class="markdown-them-math-inline">$G$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有<span class="markdown-them-math-inline">$n$</span>个点与<span class="markdown-them-math-inline">$m$</span>条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>你要回答<span class="markdown-them-math-inline">$q$</span>次询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次询问<span class="markdown-them-math-inline">$u,v$</span>两点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>回答对于<span class="markdown-them-math-inline">$u,v$</span>两点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这张图上有多少条边在它们任意一条最短路上出现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<span id="more"></span>
<h3 id="数据范围">数据范围</h3>
<div class="markdown-them-math-block">$$\begin{align*}
&amp;1\leq n\leq 500\\
&amp;1\leq m,q\leq n\cdot(n-1)/2\\
&amp;1\leq u,v\leq n\\
&amp;1\leq w\leq 1000
\end{align*}
$$</div><h2 id="题解">题解</h2>
<p>容易想到的做法是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对每次询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>遍历每条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>看这条边是否在<span class="markdown-them-math-inline">$u,v$</span>的最短路上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只需判断<code>d[u] + w == d[v]</code>是否成立即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但这样的做法是<span class="markdown-them-math-inline">$O(qm)=O(n^4)$</span>的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>稳稳的TLE<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>究其原因<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是因为计数的时候不够高效<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这种每找到合法边时就+1的策略<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以卡到每次遍历<span class="markdown-them-math-inline">$O(n^2)$</span>条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>举一个例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对18个点的图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将17放在最左边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>18放在最右边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>剩下的点从小到大4个一列摆放<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后记17在第一层<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>1,2,3,4在第二层<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>…<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>18在第六层<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>之后同一层内的点之间不连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不同层间连一条长为层数差的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就得到了一个<span class="markdown-them-math-inline">$O(n^2)$</span>级别边数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且每条边都在某条最短路上的图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每次都这样询问就会达到复杂度上界<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>举这个例子不是为了特判这种情况并打表过掉<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>真的可以吗<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而是为了说明这种对每个点对枚举所有边的做法枚举效率太低了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>考虑如何降低到<span class="markdown-them-math-inline">$O(qn)$</span>级别的复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一种想法是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>既然定源汇最短路和单源最短路可以同时解决<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么定源汇最短路边数能不能和单源最短路边数同时解决呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>换句话说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一次单源最短路边数的统计结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>能不能想办法应用到不同终点处<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>最终经过某种思考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对每个指定的<span class="markdown-them-math-inline">$s$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们将最短路中的边用其终点标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这句话的想法是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对某个指定的<span class="markdown-them-math-inline">$t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果该边终点<span class="markdown-them-math-inline">$v$</span>在<span class="markdown-them-math-inline">$s,t$</span>最短路上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么由于该边在<span class="markdown-them-math-inline">$s,v$</span>最短路上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而<span class="markdown-them-math-inline">$v,t$</span>最短路是某条<span class="markdown-them-math-inline">$s,t$</span>最短路的一部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就一定可以构造一条<span class="markdown-them-math-inline">$s,t$</span>最短路使它包含该边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>最终的做法是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对每个源<span class="markdown-them-math-inline">$s$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只沿满足<span class="markdown-them-math-inline">$d[v]=d[u]+w$</span>的边<span class="markdown-them-math-inline">$(u,v)$</span>做某种bfs<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是为了满足拓扑序在前的先遍历<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>拓扑序在后的后遍历<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>遍历过程是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次从堆中取出结点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只沿满足条件的边前进<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在终点上计数器+1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若堆中没有终点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将其终点加入按d排列的小顶堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>直至堆为空<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>最后获取答案<span class="markdown-them-math-inline">$s,t$</span>时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>遍历所有点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将每个满足<span class="markdown-them-math-inline">$d[s][u]+d[u][t]$</span>的点u的计数器加到答案中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于每条边只由其终点标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样计数是不重不漏的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>成功降低至<span class="markdown-them-math-inline">$O(q,n)$</span>复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="ac代码">AC代码</h2>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 505</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inf 100000000005LL</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
<span class="hljs-keyword">typedef</span> pair&lt;ll, ll&gt; pll;
vector&lt;pll&gt; G[maxn];
ll d[maxn][maxn], ans[maxn][maxn];
<span class="hljs-keyword">bool</span> vis[maxn][maxn];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(ll u)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    ll n, m, q, u, v, w;
    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
    <span class="hljs-comment">//freopen(&quot;2020dlcterm2/day06/E/1.in&quot;, &quot;r&quot;, stdin);</span>
    <span class="hljs-comment">//freopen(&quot;2020dlcterm2/day06/E/1.out&quot;, &quot;w&quot;, stdout);</span>
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
        <span class="hljs-keyword">for</span> (ll j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;
            d[i][j] = i == j ? <span class="hljs-number">0</span> : inf;
        &#125;
    &#125;
    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        G[u].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pll</span>(v, w));
        G[v].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pll</span>(u, w));
        d[u][v] = d[v][u] = w;
    &#125;
    <span class="hljs-keyword">for</span> (ll k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;
        <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;
            <span class="hljs-keyword">for</span> (ll j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;
                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;
        <span class="hljs-built_in">bfs</span>(i);
    &#125;
    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= q; i++)
    &#123;
        cin &gt;&gt; u &gt;&gt; v;
        ll outans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (ll j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;
            <span class="hljs-keyword">if</span>(d[u][j] + d[j][v] == d[u][v]) &#123;
                outans += ans[u][j];
            &#125;
        &#125;
        cout &lt;&lt; outans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
        <span class="hljs-comment">//cout &lt;&lt; &quot;u,v:&quot; &lt;&lt; u &lt;&lt; &#x27; &#x27; &lt;&lt; v &lt;&lt; &#x27; &#x27; &lt;&lt; &quot;d:&quot; &lt;&lt; d[u][v] &lt;&lt; &quot; ans:&quot; </span>
        <span class="hljs-comment">//cout &lt;&lt; &quot;vu:&quot; &lt;&lt; ans[v][u] &lt;&lt; &#x27;\n&#x27;;</span>
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
ll depth[maxn];
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pt</span>&#123;</span>
    ll d, id;
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> pt&amp; pt2) <span class="hljs-keyword">const</span> &#123;
        <span class="hljs-keyword">return</span> d &lt; pt2.d;
    &#125;
&#125;;
priority_queue&lt;pt&gt; que;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(ll u)</span>
</span>&#123;
    ans[u][u] = <span class="hljs-number">-1</span>;
    que.<span class="hljs-built_in">push</span>(pt&#123;-d[u][u], u&#125;);
    pt tmp;
    <span class="hljs-comment">//cout &lt;&lt; &quot;bfs:&quot; &lt;&lt; u &lt;&lt; endl;</span>
    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())
    &#123;
        tmp = que.<span class="hljs-built_in">top</span>();
        que.<span class="hljs-built_in">pop</span>();
        ans[u][tmp.id]++;
        <span class="hljs-keyword">if</span>(vis[u][tmp.id]) &#123;
            <span class="hljs-keyword">continue</span>;
        &#125;
        vis[u][tmp.id] = <span class="hljs-literal">true</span>;
        <span class="hljs-comment">//if(tmp.fencha)</span>
        <span class="hljs-comment">//cout &lt;&lt; tmp.id &lt;&lt; &#x27; &#x27; &lt;&lt; tmp.cnte &lt;&lt; &#x27; &#x27; &lt;&lt; tmp.fencha &lt;&lt; endl;</span>
        <span class="hljs-comment">//ll cntson = 0;</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : G[tmp.id])
        &#123;
            <span class="hljs-keyword">if</span>(d[u][tmp.id] + e.second == d[u][e.first]) &#123;
                que.<span class="hljs-built_in">push</span>(pt&#123;-d[u][e.first], e.first&#125;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre></div>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../BIT%E5%9C%A8%E7%BA%BF%E6%B1%82%E7%AC%ACk%E5%A4%A7%E6%95%B0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          BIT在线求第k大数
        
      </div>
    </a>
  
  
    <a href="../popcount%E5%8E%9F%E7%90%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          __builtin_popcount原理
        
      </div>
    </a>
  
</nav>

  
</article>


</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        &copy; 2022 Wilson Xia<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a><br>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="../js/clipboard.min.js"></script>
<script src="../js/jquery-1.4.3.min.js"></script>

<script src="../fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="../js/script.js"></script>








<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$', right: '$', display: false},
        {left: '\\(', right: '\\)', display: false},
        {left: '\\[', right: '\\]', display: true}
      ],
      throwOnError : false
    });
  });
</script>

  </div>
</body>
</html>