<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>ARC135题解 | Wilson&#39;s blog</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bill-xia/blog-font/Chinese-normal-normal.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bill-xia/blog-font/ChineseMono-normal-normal.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bill-xia/blog-font/Chinese-italic-normal.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bill-xia/blog-font/Chinese-normal-bold.min.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="F暂时有个地方没搞明白，但我会研究题解和正确代码，把它搞会。
C - XOR to All
题面
关键在于发现若干次操作一定可以等价于一次操作。
假设进行了多次操作，考察前两次操作$B_0$和$B_1$。由定义，$B_0$一定是原数组中的一个数，而$B_1$一定是原数组中的某个数$A$与$B_0$的">
  
  
    <link rel="alternate" href="../atom.xml" title="Wilson's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="../favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css">
  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="../index.html">Home</a>
    
      <a class="main-nav-link" href="../archives">Archives</a>
    
      <a class="main-nav-link" href="../about">About</a>
    
    <div class="main-nav-space-between"></div>
    
      <a id="nav-rss-link" class="nav-icon" href="../atom.xml" title="RSS 订阅"></a>
    
  </nav>
</div>
<div id="header-title">
  <h1 id="logo-wrap">
    <a href="../index.html" id="logo">Wilson&#39;s blog</a>
  </h1>
  
</div>

      <div id="content" class="outer">
        <section id="main"><article id="post-ARC135题解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="" class="article-date">
  <time class="dt-published" datetime="2022-02-14T14:27:52.000Z" itemprop="datePublished">2022-02-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      ARC135题解
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>F暂时有个地方没搞明白<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但我会研究题解和正确代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>把它搞会<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="c-- xor to all">C - XOR to All</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc135/tasks/arc135_c">题面</a></p>
<p>关键在于发现若干次操作一定可以等价于一次操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>假设进行了多次操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考察前两次操作<span class="markdown-them-math-inline">$B_0$</span>和<span class="markdown-them-math-inline">$B_1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$B_0$</span>一定是原数组中的一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而<span class="markdown-them-math-inline">$B_1$</span>一定是原数组中的某个数<span class="markdown-them-math-inline">$A$</span>与<span class="markdown-them-math-inline">$B_0$</span>的异或和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为<span class="markdown-them-math-inline">$B_1$</span>取自被<span class="markdown-them-math-inline">$B_0$</span>更新过的数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们发现<span class="markdown-them-math-inline">$B_0,B_1$</span>两次操作的结果等价于直接用<span class="markdown-them-math-inline">$A$</span>进行一次操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>现在操作次数减少了1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以一直使用这个方法直到将多次操作等价为一次操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>现在只需要比较选择每个数对数组元素之和的影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这可以按位统计做到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对每一位<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>最多30位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>统计有多少个数在这一位是1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后选择<span class="markdown-them-math-inline">$A_i$</span>对和的影响就是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$A_i$</span>会对数组中所有的数翻转<span class="markdown-them-math-inline">$A_i$</span>中为1的那些位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>翻转的贡献可以由统计的数据计算出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="e-- sequence of multiples">E - Sequence of Multiples</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc135/tasks/arc135_e">题面</a></p>
<p>赛后自己做出来了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>很高兴<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>下面记题目描述的数列本身为<span class="markdown-them-math-inline">$A_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而不论怎样得到它<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="初见端倪的朴素算法">初见端倪的朴素算法</h3>
<p>观察一个特殊的例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$X=1,N=1e18$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时数列就是<span class="markdown-them-math-inline">$1$</span>到<span class="markdown-them-math-inline">$n$</span>本身<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span>然后考察<span class="markdown-them-math-inline">$X=2,N=1e18$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现数列是<span class="markdown-them-math-inline">$\{2n\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>继续观察<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>会总结出一个规律<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>无论<span class="markdown-them-math-inline">$X$</span>如何<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当<span class="markdown-them-math-inline">$n$</span>充分大时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数列会变成<span class="markdown-them-math-inline">$\{kn\}$</span>的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$k$</span>为常数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>假设第<span class="markdown-them-math-inline">$n$</span>项是<span class="markdown-them-math-inline">$kn$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么第<span class="markdown-them-math-inline">$n+1$</span>项的一个上界是<span class="markdown-them-math-inline">$k(n+1)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这比前一项大了<span class="markdown-them-math-inline">$k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只要<span class="markdown-them-math-inline">$k\leq n+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个上界就会被取到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为更小的<span class="markdown-them-math-inline">$n+1$</span>的倍数已经小于第<span class="markdown-them-math-inline">$n$</span>项了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这不符合题目要求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>于是我们发现这个<span class="markdown-them-math-inline">$k$</span>的变化趋势是很重要的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果我们能搞清楚什么时候<span class="markdown-them-math-inline">$k\leq n+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这之后的内容就可以<span class="markdown-them-math-inline">$O(1)$</span>计算了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>为了研究它<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>构造新的数组<span class="markdown-them-math-inline">$\{B_n\}:B_i=A_i/i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>在特殊例子上构造<span class="markdown-them-math-inline">$\{B_n\}$</span>会给我们一些最基本的认识<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$\{B_n\}$</span>是不增的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>前面的证明过程稍加修改就能证明这个结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>实际上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们感到它以类似于反比函数的速度减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>为了解出<span class="markdown-them-math-inline">$B_i\leq i+1$</span>的时刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们研究<span class="markdown-them-math-inline">$B_i$</span>的变化趋势<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而这可以其定义中的<span class="markdown-them-math-inline">$A_i$</span>入手<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考察<span class="markdown-them-math-inline">$A_i$</span>的变化趋势<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们发现<span class="markdown-them-math-inline">$A_{i+1}-A_i\leq i+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则<span class="markdown-them-math-inline">$A_{i+1}$</span>会被<span class="markdown-them-math-inline">$A_{i+1}-(i+1)$</span>取代<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是<span class="markdown-them-math-inline">$A_i$</span>大致以<span class="markdown-them-math-inline">$O(n^2)$</span>的速度增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$A_i-A_1\leq(\sum_{k=2}^{i} k)=(i+2)(i-1)/2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>得到了<span class="markdown-them-math-inline">$\{A_i\}$</span>的变化趋势<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>两侧同时除以<span class="markdown-them-math-inline">$i$</span>即可得到<span class="markdown-them-math-inline">$\{B_i\}$</span>的变化趋势上界<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$B_i-\frac{X}{i}\leq \frac{(i+2)(i-1)}{2i}\leq i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$B_i\leq \frac{X}{i}+i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个上界是有极小值的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但我们知道<span class="markdown-them-math-inline">$B_i$</span>不增<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以我们可以先增加<span class="markdown-them-math-inline">$i$</span>得到极小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后等待<span class="markdown-them-math-inline">$i+1$</span>追上这个极小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>显然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个极小值在<span class="markdown-them-math-inline">$i=\sqrt{X}$</span>附近取到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而<span class="markdown-them-math-inline">$i=2\sqrt{X}$</span>时就一定有<span class="markdown-them-math-inline">$B_i\leq i+1$</span>了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是我们证明了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果我们暴力计算<span class="markdown-them-math-inline">$\{A_i\}$</span>直到<span class="markdown-them-math-inline">$B_i\leq i+1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间复杂度是<span class="markdown-them-math-inline">$O(\sqrt{X})$</span>的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>尽管我们没有证明其下界<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但这个算法实际效率也不够高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对<code>1e18 1e18</code>的输入需要计算20秒<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>10组就是200秒<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>远不是常数问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="正解">正解</h3>
<p><span class="markdown-them-math-inline">$B_i$</span>有一个类似于反比函数的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一开始快速下降<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后缓慢下降<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后不变的变化过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对反比函数的取整求和有整除分块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对<span class="markdown-them-math-inline">$B_i$</span>能不能也找到某种分块来合并一些计算呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/%E9%A2%98%E8%A7%A3/" rel="tag">题解</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../ARC136%E9%A2%98%E8%A7%A3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          ARC136题解
        
      </div>
    </a>
  
  
    <a href="../%E5%9C%A8Linux%E4%B8%8A%E4%BD%BF%E7%94%A8clash/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          在Linux上使用clash
        
      </div>
    </a>
  
</nav>

  
</article>


</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        &copy; 2022 Wilson Xia<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a><br>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="../js/clipboard.min.js"></script>
<script src="../js/jquery-1.4.3.min.js"></script>

<script src="../fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="../js/script.js"></script>








<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$', right: '$', display: false},
        {left: '\\(', right: '\\)', display: false},
        {left: '\\[', right: '\\]', display: true}
      ],
      throwOnError : false
    });
  });
</script>

  </div>
</body>
</html>