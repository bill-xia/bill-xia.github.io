<!DOCTYPE html><html><head><meta charset="utf-8"><title>Profiling with Perf | Wilson&#39;s blog</title><link rel="stylesheet" href="../css/fonts/Chinese-normal-normal.min.css"><link rel="stylesheet" href="../css/fonts/ChineseMono-normal-normal.min.css"><link rel="stylesheet" href="../css/fonts/Chinese-italic-normal.min.css"><link rel="stylesheet" href="../css/fonts/Chinese-normal-bold.min.css"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="有一个很好的参考资料 perfwiki。
perfwiki 的组织方式是从 perf 的实现原理出发，先讲 perf 提供了什么手段，再举例子讲能用来干什么。即先讲 perf profiling 过程中最重要的对象 event，然后 perf stat 就是执行程序前后 event 数量之差，per"><link rel="alternate" href="../atom.xml" title="Wilson's blog" type="application/atom+xml"><link rel="shortcut icon" href="../favicon.ico"><link rel="stylesheet" href="../css/style.css"><link rel="stylesheet" href="../fancybox/jquery.fancybox-1.3.4.css"><link rel="stylesheet" href="../katex/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><script defer src="../katex/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script><script defer src="../katex/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="container"><div id="wrap"><div id="nav-outer"><nav id="main-nav" class="outer"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/blog/">Home</a> <a class="main-nav-link" href="/blog/archives/">Archives</a> <a class="main-nav-link" href="/blog/paper_list/">Paper List</a> <a class="main-nav-link" href="/blog/about/">About</a><div class="main-nav-space-between"></div><a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS 订阅"></a></nav></div><div id="header-title"><h1 id="logo-wrap"><a href="../index.html" id="logo">Wilson&#39;s blog</a></h1></div><div id="content" class="outer"><section id="main"><article id="post-Profiling" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="" class="article-date"><time class="dt-published" datetime="2024-07-06T07:21:39.000Z" itemprop="datePublished">2024-07-06</time></a></div><div class="article-inner"><header class="article-header"><h1 class="p-name article-title" itemprop="headline name">Profiling with Perf</h1></header><div class="e-content article-entry" itemprop="articleBody"><p>有一个很好的参考资料 <a target="_blank" rel="noopener" href="https://perfwiki.github.io">perfwiki</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>perfwiki 的组织方式是从 perf 的实现原理出发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>先讲 perf 提供了什么手段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再举例子讲能用来干什么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>即先讲 perf profiling 过程中最重要的对象 event<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后 <code>perf stat</code> 就是执行程序前后 event 数量之差<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>perf record</code> 就是执行程序过程中事件每发生固定次数就采集一个样本<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个角度 perfwiki 做得很好了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>本文尝试换一个角度组织<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>先讲有哪些 profiling 任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再讲用户可能希望一个 profiling 工具提供哪些功能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后映射到 perf 的实现上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>理论上这种结构可以落实到多种 profiler 实现上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但我其实没用过其他 profiler<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>挖坑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p><h2 id="识别性能瓶颈">识别性能瓶颈</h2><p>最经典的任务是将 CPU 执行的时间按<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>CPU在执行哪个函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>进行划分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后查看哪些函数用时最长<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后着力优化这些函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>实际上还有其他类型的性能瓶颈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如 Top-down 将 CPU uop-slot 按<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>等前端<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>等后端<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>执行错误的分支<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>正常执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>进行划分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或者有些性能瓶颈是多核间在等锁<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>CPU 大部分时间其实在等锁<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但我们看到 <span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>CPU 在等待<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>这个信息其实没啥价值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>等等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>最直觉的做法是进出函数时都打印带时间戳的日志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后分析日志来统计每个函数的执行时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这种做法有其优势<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>日志内容运行时可控<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如可以记录下函数参数和返回值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这些日志可以同时用于 debug<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但显著的问题有两点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ol><li>需要主动知道哪些函数是潜在的热点需要被记录<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后手动为他们写日志语句<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>或者需要一个额外工具来自动为所有函数插入这种日志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>更进一步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这两点在没有源码时都不现实<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></li><li>当函数调用次数过多时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记录这些日志本身可能会成为性能瓶颈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为这涉及格式化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>与硬盘交互等等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></li></ol><p>幸运的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有一个非常聪明的思路同时解决了这两个问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是把<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>CPU在执行哪个函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>看作一个概率分布<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后对他进行采样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只要采样频率足够<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就能足够逼近原始分布<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>并且<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果一个地方是性能瓶颈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他在原始分布中应该占比很高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以不用担心采样过程中漏掉它<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>实现这种采样有两个要点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>实现<strong>固定间隔</strong>发起采样事件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这在 perf 里用 <code>perf record</code> 实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个命令做的就是固定间隔采样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里的间隔具体的定义是 event 数量间隔<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当事件为 <code>cycles</code> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>固定 event 数量间隔就对应于固定执行时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><code>-F</code> 参数可以指定采样频率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>-a</code> 参数指定对所有 CPU 采样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>-C</code> 参数指定了要采样的 CPU 列表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>每个样本内需要记录 CPU 在执行哪个函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更好的情况是知道当前调用栈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><code>-g</code> 参数就告诉 <code>perf record</code> 记录下调用栈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里记录的只是每层调用栈的返回地址<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>挖坑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>调用栈的栈帧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及这里记的是不是返回地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>把它翻译成函数符号是后续工作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个命令对整个 CPU 采样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以可能会采到其他进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以直接把执行其他进程的样本剃除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或者给 <code>perf record</code> 加上 <code>-p</code> 参数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>考虑到 <code>perf record</code> 的意义是对概率分布进行采样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这么操作没什么问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><blockquote><p><a target="_blank" rel="noopener" href="https://perfwiki.github.io/main/tutorial/#event-based-sampling-overview">perfwiki</a> 中指出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现代 CPU 的实现方式导致采集到的样本的指令位置可能并不精准地是 event 数量间隔到达的那一刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>会有偏移<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>skid<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当事件为 cycles 时这不是太大的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但事件是 cache-miss 等时就要注意精确的样本位置不能用来参考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></blockquote><p><code>perf record</code> 采集到的样本内容是二进制的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用 <code>perf script</code> 处理后长下面的样子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>TODO: 换一个简单的程序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不要用cpu-clock<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code>zebra <span class="hljs-number">2228528</span> [<span class="hljs-number">007</span>] <span class="hljs-number">196350.576148</span>:   <span class="hljs-number">10101010</span> cpu-clock: 
            <span class="hljs-number">72</span>be3b6fa59f __libc_calloc+<span class="hljs-number">0</span>x7f (<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/x86_64-linux-gnu/</span>libc.so.<span class="hljs-number">6</span>)
            <span class="hljs-number">72</span>be3bacf581 listnode_add+<span class="hljs-number">0</span>x61 (<span class="hljs-regexp">/usr/</span>lib/libfrr.so.<span class="hljs-number">0.0</span>.<span class="hljs-number">0</span>)
            <span class="hljs-number">5</span>ebb25f4c736 rib_meta_queue_early_route_add+<span class="hljs-number">0</span>x16 (<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/frr/</span>zebra)
            <span class="hljs-number">5</span>ebb25f10345 zread_route_add+<span class="hljs-number">0</span>x1a5 (<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/frr/</span>zebra)
            <span class="hljs-number">5</span>ebb25f14046 zserv_handle_commands+<span class="hljs-number">0</span>x116 (<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/frr/</span>zebra)
            <span class="hljs-number">5</span>ebb25f83780 zserv_process_messages+<span class="hljs-number">0</span>x100 (<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/frr/</span>zebra)
            <span class="hljs-number">72</span>be3bb25854 event_call+<span class="hljs-number">0</span>x84 (<span class="hljs-regexp">/usr/</span>lib/libfrr.so.<span class="hljs-number">0.0</span>.<span class="hljs-number">0</span>)
            <span class="hljs-number">72</span>be3bacec78 frr_run+<span class="hljs-number">0</span>xc8 (<span class="hljs-regexp">/usr/</span>lib/libfrr.so.<span class="hljs-number">0.0</span>.<span class="hljs-number">0</span>)
            <span class="hljs-number">5</span>ebb25ee3bc6 main+<span class="hljs-number">0</span>x3e6 (<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/frr/</span>zebra)
            <span class="hljs-number">72</span>be3b67dd90 __libc_start_call_main+<span class="hljs-number">0</span>x80 (<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/x86_64-linux-gnu/</span>libc.so.<span class="hljs-number">6</span>)

bgpd <span class="hljs-number">2225676</span> [<span class="hljs-number">006</span>] <span class="hljs-number">196350.576150</span>:   <span class="hljs-number">10101010</span> cpu-clock: 
            <span class="hljs-number">75</span>d5018c01dd __tls_get_addr+<span class="hljs-number">0</span>xd (<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/x86_64-linux-gnu/</span>ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span>)
            <span class="hljs-number">75</span>d501851d68 socket+<span class="hljs-number">0</span>x4ee (<span class="hljs-regexp">/usr/</span>lib/libpreload.so)
            <span class="hljs-number">75</span>d501851efe socket+<span class="hljs-number">0</span>x684 (<span class="hljs-regexp">/usr/</span>lib/libpreload.so)
            <span class="hljs-number">75</span>d501710ec2 event_fetch+<span class="hljs-number">0</span>x322 (<span class="hljs-regexp">/usr/</span>lib/libfrr.so.<span class="hljs-number">0.0</span>.<span class="hljs-number">0</span>)
            <span class="hljs-number">75</span>d5016bac83 frr_run+<span class="hljs-number">0</span>xd3 (<span class="hljs-regexp">/usr/</span>lib/libfrr.so.<span class="hljs-number">0.0</span>.<span class="hljs-number">0</span>)
            <span class="hljs-number">574331820</span>f53 main+<span class="hljs-number">0</span>x393 (<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/frr/</span>bgpd)
            <span class="hljs-number">75</span>d5012bad90 __libc_start_call_main+<span class="hljs-number">0</span>x80 (<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/x86_64-linux-gnu/</span>libc.so.<span class="hljs-number">6</span>)
...
</code></pre></div><p>采到样本之后展示性能瓶颈有几种方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我最喜欢的是火焰图<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><a target="_blank" rel="noopener" href="https://www.brendangregg.com/flamegraphs.html">flamegraph</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个项目画火焰图的方法很直白<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>首先获得调用栈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对上面的输出做简单的文字处理就能得到下面的内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它按照字典序<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>而非时间序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且调用栈相同的样本被合并<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code>bgpd;<span class="hljs-variable">__libc_start_call_main</span>;main;frr_run;event_fetch;socket;socket;<span class="hljs-variable">__tls_get_addr</span> <span class="hljs-number">10101010</span>
zebra;<span class="hljs-variable">__libc_start_call_main</span>;main;frr_run;event_call;zserv_process_messages;zserv_handle_commands;zread_route_add;rib_meta_queue_early_route_add;listnode_add;<span class="hljs-variable">__libc_calloc</span> <span class="hljs-number">10101010</span>
...
</code></pre></div><p>一般要做 breakdown 的话调用栈就是这样从 main 开始逐渐细化即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>效果如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p>TODO</p><p>理解这个图的方式是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>第 k 层的宽度代表了 CPU 处在这个函数内的时间比例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>第 k+1 层可能有多个被调用的函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他们之间的关系也就显示了这个函数内部<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>画这个图的方法就是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果两个样本第 k 层相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就把他们在第 k 层连起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>还有有一种 reversed 火焰图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>火焰图最宽的部分是最后被调用的函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后它的宽度被分成它的每个 caller 分别占据多少比例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在确定了某个热点函数后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果这个函数有多个 caller<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个图会很有用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>效果如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p></div><footer class="article-footer"></footer></div><nav id="article-nav"><a href="../Static-dashboard-site-with-Hexo-and-Vega-Lite/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">Static dashboard site with Hexo and Vega-Lite</div></a><a href="../%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E7%9A%84%E7%B3%BB%E7%BB%9Fidea/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">一些经典的系统idea</div></a></nav></article></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2024 Wilson Xia<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/bill-xia/hexo-theme-mashiro" target="_blank">Mashiro</a><br></div></div></footer></div><nav id="mobile-nav"><a href="/blog/" class="mobile-nav-link">Home</a> <a href="/blog/archives/" class="mobile-nav-link">Archives</a> <a href="/blog/paper_list/" class="mobile-nav-link">Paper List</a> <a href="/blog/about/" class="mobile-nav-link">About</a></nav><script src="../js/clipboard.min.js"></script><script src="../js/jquery-1.4.3.min.js"></script><script src="../fancybox/jquery.fancybox-1.3.4.pack.js"></script><script src="../js/script.js"></script></div></body></html>