<!DOCTYPE html><html><head><meta charset="utf-8"><title>POJ2987-Firing | Wilson&#39;s blog</title><link rel="stylesheet" href="../css/fonts/Chinese-normal-normal.min.css"><link rel="stylesheet" href="../css/fonts/ChineseMono-normal-normal.min.css"><link rel="stylesheet" href="../css/fonts/Chinese-italic-normal.min.css"><link rel="stylesheet" href="../css/fonts/Chinese-normal-bold.min.css"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="这是一道最大点权闭合图的问题，有论文最小割模型在信息学竞赛中的应用（%%）。这类问题的解法是建图转化成最小割问题，再用最大流求解。"><link rel="alternate" href="../atom.xml" title="Wilson's blog" type="application/atom+xml"><link rel="shortcut icon" href="../favicon.ico"><link rel="stylesheet" href="../css/style.css"><link rel="stylesheet" href="../fancybox/jquery.fancybox-1.3.4.css"><link rel="stylesheet" href="../katex/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><script defer src="../katex/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script><script defer src="../katex/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="container"><div id="wrap"><div id="nav-outer"><nav id="main-nav" class="outer"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/blog/">Home</a> <a class="main-nav-link" href="/blog/archives/">Archives</a> <a class="main-nav-link" href="/blog/paper_list/">Paper List</a> <a class="main-nav-link" href="/blog/about/">About</a><div class="main-nav-space-between"></div><a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS 订阅"></a></nav></div><div id="header-title"><h1 id="logo-wrap"><a href="../index.html" id="logo">Wilson&#39;s blog</a></h1></div><div id="content" class="outer"><section id="main"><article id="post-POJ2987-firing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="" class="article-date"><time class="dt-published" datetime="2020-04-23T14:20:31.000Z" itemprop="datePublished">2020-04-23</time></a><div class="article-category"><a class="article-category-link" href="../categories/%E9%A2%98%E8%A7%A3/">题解</a></div></div><div class="article-inner"><header class="article-header"><h1 class="p-name article-title" itemprop="headline name">POJ2987-Firing</h1></header><div class="e-content article-entry" itemprop="articleBody"><p>这是一道<strong>最大点权闭合图</strong>的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有论文<a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/986baf00b52acfc789ebc9a9.html">最小割模型在信息学竞赛中的应用</a><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>%%<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这类问题的解法是建图转化成最小割问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再用最大流求解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span id="more"></span>这篇论文里讲的很好<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我这里基本按照原文思路进行证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果有时间和兴趣建议通读上面推荐的论文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先定义闭合图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><strong>闭合图</strong>是指一个图<span class="markdown-them-math-inline">$G$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>若点<span class="markdown-them-math-inline">$u$</span>在<span class="markdown-them-math-inline">$G$</span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么从<span class="markdown-them-math-inline">$u$</span>可达的所有点<span class="markdown-them-math-inline">$v$</span>也在<span class="markdown-them-math-inline">$G$</span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>建图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>除开题目所给的点之外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再建立源点<span class="markdown-them-math-inline">$s$</span>和汇点<span class="markdown-them-math-inline">$t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记题目输入的图为<span class="markdown-them-math-inline">$G_0(V_0,E_0)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>按如下规则建立图<span class="markdown-them-math-inline">$G(V, E )$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p></p><div class="markdown-them-math-block">$$ \begin{cases} \langle s,u\rangle=w[u] \in E &amp; u\in V_0,w[u] &gt; 0,\\ \langle u,t\rangle=-w[u] \in E &amp; u\in V_0,w[u] &lt; 0,\\ \langle u,v\rangle=+\infty\in E &amp; \langle u,v\rangle\in E_0.\end{cases} $$</div><p></p><p>这样处理之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于原图中的边权值都变成了正无穷<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以最小割中的边要么与<span class="markdown-them-math-inline">$s$</span>相连<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么与<span class="markdown-them-math-inline">$t$</span>相连<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>称这样的割为简单割<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>下面证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有向图中简单割和闭合图可以建立一一对应关系<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>数学中称为同构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>下面的证明不知道思路乱不乱<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>建议结合那篇论文一起食用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>他的证明比较简短<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果哪里搞不懂再回来看这里的证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>先证明一个闭合图必存在一个简单割与之对应<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>闭合图对应简单割<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>考虑图<span class="markdown-them-math-inline">$G$</span>的闭合子图<span class="markdown-them-math-inline">$G'(V',E')$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中一定没有指向<span class="markdown-them-math-inline">$G'$</span>外的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$G_0$</span>中对应的子图<span class="markdown-them-math-inline">$G_0'$</span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>流出<span class="markdown-them-math-inline">$G_0'$</span>的一定是直接流出到t的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>为了切断<span class="markdown-them-math-inline">$s$</span>与<span class="markdown-them-math-inline">$u$</span>的联系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以考虑将<span class="markdown-them-math-inline">$G_0'$</span>流出的边集<span class="markdown-them-math-inline">$O$</span>纳入割中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记<span class="markdown-them-math-inline">$G_0'$</span>的补图为<span class="markdown-them-math-inline">$\overline{G_0'}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么现在只要防止流量从<span class="markdown-them-math-inline">$\overline{G_0'}$</span>流出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于从<span class="markdown-them-math-inline">$s$</span>流进<span class="markdown-them-math-inline">$G_0'$</span>的边只可能从<span class="markdown-them-math-inline">$O$</span>流出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以不必考虑它们<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只要考虑从<span class="markdown-them-math-inline">$s$</span>流进<span class="markdown-them-math-inline">$\overline{G_0'}$</span>的边集<span class="markdown-them-math-inline">$I$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>显然<span class="markdown-them-math-inline">$O\cup I$</span>删除后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以切断s与t的联系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>证明1<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><span class="markdown-them-math-inline">$O\cup I$</span>是割<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>割的定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对某个顶点集合<span class="markdown-them-math-inline">$S\subset V$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从<span class="markdown-them-math-inline">$S$</span>出发指向<span class="markdown-them-math-inline">$S$</span>外部的那些边的集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在这里取<span class="markdown-them-math-inline">$S=V'\cup\{s\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对<span class="markdown-them-math-inline">$u\in S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若<span class="markdown-them-math-inline">$u=s$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从<span class="markdown-them-math-inline">$u$</span>出发指向<span class="markdown-them-math-inline">$S$</span>外部的边集即是<span class="markdown-them-math-inline">$I$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>若<span class="markdown-them-math-inline">$u\in V'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从<span class="markdown-them-math-inline">$u$</span>出发指向<span class="markdown-them-math-inline">$S$</span>外部的边集即是<span class="markdown-them-math-inline">$O$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>从而由定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O\cup I$</span>是割<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>还有事实<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>由于<span class="markdown-them-math-inline">$s$</span>不会直接向<span class="markdown-them-math-inline">$t$</span>连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O\cap I=\varnothing$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p><p>再证明一个简单割必对应一个闭合图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>希望仿照上面的构造方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将简单割对应回闭合图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即寻找逆映射<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设简单割<span class="markdown-them-math-inline">$[S,T]$</span>中与<span class="markdown-them-math-inline">$s$</span>相连的边集为<span class="markdown-them-math-inline">$I$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>与<span class="markdown-them-math-inline">$t$</span>相连的边集为<span class="markdown-them-math-inline">$O$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么这个割<span class="markdown-them-math-inline">$[S, T]$</span>对应的<span class="markdown-them-math-inline">$S$</span>应当是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>删掉简单割<span class="markdown-them-math-inline">$[S,T]$</span>中的边后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从<span class="markdown-them-math-inline">$s$</span>可达的点的集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>记作<span class="markdown-them-math-inline">$V'=S-\{s\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span><span class="markdown-them-math-inline">$\cup \{s\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>下面证明这些点恰恰构成上面证明中提到的闭合图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>证明2<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><span class="markdown-them-math-inline">$V'$</span>中的点及由<span class="markdown-them-math-inline">$V'$</span>出发的边集构成闭合图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>由于<span class="markdown-them-math-inline">$[S,T]$</span>是割<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>删去<span class="markdown-them-math-inline">$[S,T]$</span>后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从<span class="markdown-them-math-inline">$s$</span>可达的点<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>一定在<span class="markdown-them-math-inline">$S$</span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>一定无法离开<span class="markdown-them-math-inline">$S$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>找到指向<span class="markdown-them-math-inline">$S$</span>外的路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由定义这些点是闭合图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若<span class="markdown-them-math-inline">$V'$</span>中有负权点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么它指向<span class="markdown-them-math-inline">$t$</span>的边应当已被包含在<span class="markdown-them-math-inline">$[S,T]$</span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于<span class="markdown-them-math-inline">$[S,T]$</span>是简单割<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$V'$</span>指向<span class="markdown-them-math-inline">$S$</span>外的边只有这些边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$s$</span>指向<span class="markdown-them-math-inline">$S$</span>外的边全部指向<span class="markdown-them-math-inline">$V-V'$</span>中的正权点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它们也应当已被包含在<span class="markdown-them-math-inline">$[S,T]$</span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>至此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$[S,T]$</span>的结构就清楚了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>从<span class="markdown-them-math-inline">$s$</span>指向<span class="markdown-them-math-inline">$V-V'$</span>的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及从<span class="markdown-them-math-inline">$V'$</span>指向<span class="markdown-them-math-inline">$t$</span>的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>发现这个割对应的点集<span class="markdown-them-math-inline">$V'=S- \{s\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果按照证明1中的方法寻找割<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仍得到这个割<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>一一对应关系建立完成后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>试图建立最小割与最大点权的关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对最小割<span class="markdown-them-math-inline">$[S,T]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记<span class="markdown-them-math-inline">$V'=S-\{s\},\overline{V'}=T-\{t\},V'$</span>中点权为正的点集为 <span class="markdown-them-math-inline">$V'_+$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>点权为负的点集为<span class="markdown-them-math-inline">$V'_-$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>类似地定义<span class="markdown-them-math-inline">$\overline{V_+'},\overline{V_-'}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>那么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最小割中的边权为<span class="markdown-them-math-inline">$w(\overline{V'_+})+w(V'_-)\left(w(V)=\sum\limits_{v\in V}{|w(v)|}\right)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而最大点权应为<span class="markdown-them-math-inline">$w(V'_+)-w(V'_-)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他们的和为<span class="markdown-them-math-inline">$w(\overline{V'_+})+w(V'_+)=w(V_+)$</span>不变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么取得最小割时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就会得到最大点权闭合图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>问题就解决了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>由于流的上限太高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><a href="Ford-Fulkerson%E7%AE%97%E6%B3%95/" title="Ford-Fulkerson算法">Ford-Fulkerson算法</a>会TLE<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要用<a href="Dinic%E7%AE%97%E6%B3%95/" title="Dinic算法">Dinic算法</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>最后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在残留网络上从源点<span class="markdown-them-math-inline">$s$</span>出发dfs一下就知道<span class="markdown-them-math-inline">$G'$</span>中的点数了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>挖个坑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要证明按照这种做法得到的一定是点数最少的子图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="ac代码">AC代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span>
    <span class="hljs-keyword">int</span> from, to;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> w, f;
    <span class="hljs-keyword">int</span> rev;
    <span class="hljs-built_in">edge</span>(<span class="hljs-keyword">int</span> i_from, <span class="hljs-keyword">int</span> i_to, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i_w, <span class="hljs-keyword">int</span> i_rev) &#123;
        <span class="hljs-keyword">this</span>-&gt;from = i_from;
        <span class="hljs-keyword">this</span>-&gt;to = i_to;
        <span class="hljs-keyword">this</span>-&gt;w = i_w;
        <span class="hljs-keyword">this</span>-&gt;rev = i_rev;
        <span class="hljs-keyword">this</span>-&gt;f = <span class="hljs-number">0</span>;
    &#125;
&#125;;
vector&lt;edge&gt; G[<span class="hljs-number">5005</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> to, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> w)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">max_flow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pt, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> f)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pt)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">int</span> level[<span class="hljs-number">5005</span>];
<span class="hljs-keyword">int</span> iter[<span class="hljs-number">5005</span>];
<span class="hljs-keyword">int</span> n, m, w[<span class="hljs-number">5005</span>];
<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">5005</span>];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sumw = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;w[i]);
        <span class="hljs-keyword">if</span> (w[i] &gt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-built_in">addedge</span>(<span class="hljs-number">0</span>, i, w[i]);
            sumw += w[i];
        &#125;
        <span class="hljs-keyword">if</span>(w[i] &lt; <span class="hljs-number">0</span>)&#123;
            <span class="hljs-built_in">addedge</span>(i, n + <span class="hljs-number">1</span>, -w[i]);
        &#125;
    &#125;
    <span class="hljs-keyword">int</span> father, son;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;father, &amp;son);
        <span class="hljs-built_in">addedge</span>(father, son, sumw + <span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> maxf = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
        <span class="hljs-built_in">memset</span>(level, <span class="hljs-number">-1</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(level));
        <span class="hljs-built_in">bfs</span>();
        <span class="hljs-keyword">if</span> (level[n + <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">memset</span>(iter, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(iter));
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> f = <span class="hljs-built_in">max_flow</span>(<span class="hljs-number">0</span>, sumw);
            <span class="hljs-keyword">if</span> (f == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
            maxf += f;
        &#125;
    &#125;
    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));
    <span class="hljs-keyword">int</span> cnt = <span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>) - <span class="hljs-number">1</span>;
    cout &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (sumw - maxf);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> to, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> w)</span> </span>&#123;
    G[from].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(from, to, w, G[to].<span class="hljs-built_in">size</span>()));
    G[to].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(to, from, <span class="hljs-number">0</span>, G[from].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>));
&#125;
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">max_flow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pt, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> f)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (pt == n + <span class="hljs-number">1</span>) &#123;
        <span class="hljs-keyword">return</span> f;
    &#125;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> curf = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;i = iter[pt]; i &lt; G[pt].<span class="hljs-built_in">size</span>(); i++) &#123;
        edge &amp;v = G[pt][i];
        <span class="hljs-keyword">if</span> (level[v.to] &lt;= level[pt] || v.w &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
        curf = <span class="hljs-built_in">max_flow</span>(v.to, ((f &gt; v.w) ? v.w : f));
        <span class="hljs-keyword">if</span> (curf &gt; <span class="hljs-number">0</span>) &#123;
            v.w -= curf;
            v.f += curf;
            G[v.to][v.rev].w += curf;
            <span class="hljs-keyword">return</span> curf;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;
    queue&lt;<span class="hljs-keyword">int</span>&gt; que;
    que.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);
    level[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;
        <span class="hljs-keyword">int</span> u = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G[u].<span class="hljs-built_in">size</span>(); i++) &#123;
            <span class="hljs-keyword">if</span> (level[G[u][i].to] &gt;= <span class="hljs-number">0</span> || G[u][i].w &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
            level[G[u][i].to] = level[u] + <span class="hljs-number">1</span>;
            que.<span class="hljs-built_in">push</span>(G[u][i].to);
        &#125;
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pt)</span> </span>&#123;<span class="hljs-comment">//dfs</span>
    <span class="hljs-keyword">if</span>(vis[pt]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;
    vis[pt] = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G[pt].<span class="hljs-built_in">size</span>(); i++) &#123;
        <span class="hljs-keyword">if</span>(vis[G[pt][i].to] || G[pt][i].w &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
        ans += <span class="hljs-built_in">count</span>(G[pt][i].to);
    &#125;
    <span class="hljs-keyword">return</span> ans;
&#125;
</code></pre></div></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/Dinic%E7%AE%97%E6%B3%95/" rel="tag">Dinic算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/%E6%9C%80%E5%A4%A7%E7%82%B9%E6%9D%83%E9%97%AD%E5%90%88%E5%9B%BE/" rel="tag">最大点权闭合图</a></li></ul></footer></div><nav id="article-nav"><a href="../Ford-Fulkerson%E7%AE%97%E6%B3%95/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">Ford-Fulkerson算法</div></a><a href="../%E6%B5%8B%E8%AF%95%E8%AF%84%E8%AE%BA/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">测试评论</div></a></nav></article></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2024 Wilson Xia<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/bill-xia/hexo-theme-mashiro" target="_blank">Mashiro</a><br></div></div></footer></div><nav id="mobile-nav"><a href="/blog/" class="mobile-nav-link">Home</a> <a href="/blog/archives/" class="mobile-nav-link">Archives</a> <a href="/blog/paper_list/" class="mobile-nav-link">Paper List</a> <a href="/blog/about/" class="mobile-nav-link">About</a></nav><script src="../js/clipboard.min.js"></script><script src="../js/jquery-1.4.3.min.js"></script><script src="../fancybox/jquery.fancybox-1.3.4.pack.js"></script><script src="../js/script.js"></script></div></body></html>