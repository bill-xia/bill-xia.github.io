<!DOCTYPE html><html><head><meta charset="utf-8"><title>POJ2987-Firing | Wilson&#39;s blog</title><link rel="stylesheet" href="/css/fonts/Chinese-normal-normal.min.css"><link rel="stylesheet" href="/css/fonts/ChineseMono-normal-normal.min.css"><link rel="stylesheet" href="/css/fonts/Chinese-italic-normal.min.css"><link rel="stylesheet" href="/css/fonts/Chinese-normal-bold.min.css"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="这是一道最大点权闭合图的问题，有论文最小割模型在信息学竞赛中的应用（%%）。这类问题的解法是建图转化成最小割问题，再用最大流求解。"><link rel="alternate" href="../atom.xml" title="Wilson's blog" type="application/atom+xml"><link rel="shortcut icon" href="../favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css"><link rel="stylesheet" href="/katex/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><script defer src="/katex/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script><script defer src="/katex/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="container"><div id="wrap"><div id="nav-outer"><nav id="main-nav" class="outer"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="../index.html">Home</a> <a class="main-nav-link" href="../archives/">Archives</a> <a class="main-nav-link" href="../paper_list/">Paper List</a> <a class="main-nav-link" href="../about/">About</a><div class="main-nav-space-between"></div><a id="nav-rss-link" class="nav-icon" href="../atom.xml" title="RSS 订阅"></a></nav></div><div id="header-title"><h1 id="logo-wrap"><a href="../index.html" id="logo">Wilson&#39;s blog</a></h1></div><div id="content" class="outer"><section id="main"><article id="post-POJ2987-firing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="" class="article-date"><time class="dt-published" datetime="2020-04-23T14:20:31.000Z" itemprop="datePublished">2020-04-23</time></a><div class="article-category"><a class="article-category-link" href="../categories/%E9%A2%98%E8%A7%A3/">题解</a></div></div><div class="article-inner"><header class="article-header"><h1 class="p-name article-title" itemprop="headline name">POJ2987-Firing</h1></header><div class="e-content article-entry" itemprop="articleBody"><p>这是一道<strong>最大点权闭合图</strong>的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有论文<a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/986baf00b52acfc789ebc9a9.html">最小割模型在信息学竞赛中的应用</a><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>%%<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这类问题的解法是建图转化成最小割问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再用最大流求解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span id="more"></span>这篇论文里讲的很好<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我这里基本按照原文思路进行证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果有时间和兴趣建议通读上面推荐的论文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>首先定义闭合图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><strong>闭合图</strong>是指一个图<span class="markdown-them-math-inline">$G$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>若点<span class="markdown-them-math-inline">$u$</span>在<span class="markdown-them-math-inline">$G$</span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么从<span class="markdown-them-math-inline">$u$</span>可达的所有点<span class="markdown-them-math-inline">$v$</span>也在<span class="markdown-them-math-inline">$G$</span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>建图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>除开题目所给的点之外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再建立源点<span class="markdown-them-math-inline">$s$</span>和汇点<span class="markdown-them-math-inline">$t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记题目输入的图为<span class="markdown-them-math-inline">$G_0(V_0,E_0)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>按如下规则建立图<span class="markdown-them-math-inline">$G(V, E )$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p></p><div class="markdown-them-math-block">$$ \begin{cases} \langle s,u\rangle=w[u] \in E &amp; u\in V_0,w[u] &gt; 0,\\ \langle u,t\rangle=-w[u] \in E &amp; u\in V_0,w[u] &lt; 0,\\ \langle u,v\rangle=+\infty\in E &amp; \langle u,v\rangle\in E_0.\end{cases} $$</div><p></p><p>这样处理之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于原图中的边权值都变成了正无穷<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以最小割中的边要么与<span class="markdown-them-math-inline">$s$</span>相连<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么与<span class="markdown-them-math-inline">$t$</span>相连<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>称这样的割为简单割<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>下面证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有向图中简单割和闭合图可以建立一一对应关系<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>数学中称为同构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>下面的证明不知道思路乱不乱<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>建议结合那篇论文一起食用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>他的证明比较简短<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果哪里搞不懂再回来看这里的证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>先证明一个闭合图必存在一个简单割与之对应<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>闭合图对应简单割<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>考虑图<span class="markdown-them-math-inline">$G$</span>的闭合子图<span class="markdown-them-math-inline">$G'(V',E')$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中一定没有指向<span class="markdown-them-math-inline">$G'$</span>外的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$G_0$</span>中对应的子图<span class="markdown-them-math-inline">$G_0'$</span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>流出<span class="markdown-them-math-inline">$G_0'$</span>的一定是直接流出到t的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>为了切断<span class="markdown-them-math-inline">$s$</span>与<span class="markdown-them-math-inline">$u$</span>的联系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以考虑将<span class="markdown-them-math-inline">$G_0'$</span>流出的边集<span class="markdown-them-math-inline">$O$</span>纳入割中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记<span class="markdown-them-math-inline">$G_0'$</span>的补图为<span class="markdown-them-math-inline">$\overline{G_0'}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么现在只要防止流量从<span class="markdown-them-math-inline">$\overline{G_0'}$</span>流出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于从<span class="markdown-them-math-inline">$s$</span>流进<span class="markdown-them-math-inline">$G_0'$</span>的边只可能从<span class="markdown-them-math-inline">$O$</span>流出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以不必考虑它们<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只要考虑从<span class="markdown-them-math-inline">$s$</span>流进<span class="markdown-them-math-inline">$\overline{G_0'}$</span>的边集<span class="markdown-them-math-inline">$I$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>显然<span class="markdown-them-math-inline">$O\cup I$</span>删除后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以切断s与t的联系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>证明1<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><span class="markdown-them-math-inline">$O\cup I$</span>是割<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>割的定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对某个顶点集合<span class="markdown-them-math-inline">$S\subset V$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从<span class="markdown-them-math-inline">$S$</span>出发指向<span class="markdown-them-math-inline">$S$</span>外部的那些边的集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在这里取<span class="markdown-them-math-inline">$S=V'\cup\{s\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对<span class="markdown-them-math-inline">$u\in S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若<span class="markdown-them-math-inline">$u=s$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从<span class="markdown-them-math-inline">$u$</span>出发指向<span class="markdown-them-math-inline">$S$</span>外部的边集即是<span class="markdown-them-math-inline">$I$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>若<span class="markdown-them-math-inline">$u\in V'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从<span class="markdown-them-math-inline">$u$</span>出发指向<span class="markdown-them-math-inline">$S$</span>外部的边集即是<span class="markdown-them-math-inline">$O$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>从而由定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O\cup I$</span>是割<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>还有事实<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>由于<span class="markdown-them-math-inline">$s$</span>不会直接向<span class="markdown-them-math-inline">$t$</span>连边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O\cap I=\varnothing$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p><p>再证明一个简单割必对应一个闭合图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>希望仿照上面的构造方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将简单割对应回闭合图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即寻找逆映射<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设简单割<span class="markdown-them-math-inline">$[S,T]$</span>中与<span class="markdown-them-math-inline">$s$</span>相连的边集为<span class="markdown-them-math-inline">$I$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>与<span class="markdown-them-math-inline">$t$</span>相连的边集为<span class="markdown-them-math-inline">$O$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么这个割<span class="markdown-them-math-inline">$[S, T]$</span>对应的<span class="markdown-them-math-inline">$S$</span>应当是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>删掉简单割<span class="markdown-them-math-inline">$[S,T]$</span>中的边后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从<span class="markdown-them-math-inline">$s$</span>可达的点的集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>记作<span class="markdown-them-math-inline">$V'=S-\{s\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span><span class="markdown-them-math-inline">$\cup \{s\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>下面证明这些点恰恰构成上面证明中提到的闭合图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>证明2<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><span class="markdown-them-math-inline">$V'$</span>中的点及由<span class="markdown-them-math-inline">$V'$</span>出发的边集构成闭合图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>由于<span class="markdown-them-math-inline">$[S,T]$</span>是割<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>删去<span class="markdown-them-math-inline">$[S,T]$</span>后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从<span class="markdown-them-math-inline">$s$</span>可达的点<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>一定在<span class="markdown-them-math-inline">$S$</span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>一定无法离开<span class="markdown-them-math-inline">$S$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>找到指向<span class="markdown-them-math-inline">$S$</span>外的路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由定义这些点是闭合图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若<span class="markdown-them-math-inline">$V'$</span>中有负权点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么它指向<span class="markdown-them-math-inline">$t$</span>的边应当已被包含在<span class="markdown-them-math-inline">$[S,T]$</span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于<span class="markdown-them-math-inline">$[S,T]$</span>是简单割<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$V'$</span>指向<span class="markdown-them-math-inline">$S$</span>外的边只有这些边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$s$</span>指向<span class="markdown-them-math-inline">$S$</span>外的边全部指向<span class="markdown-them-math-inline">$V-V'$</span>中的正权点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它们也应当已被包含在<span class="markdown-them-math-inline">$[S,T]$</span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>至此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$[S,T]$</span>的结构就清楚了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>从<span class="markdown-them-math-inline">$s$</span>指向<span class="markdown-them-math-inline">$V-V'$</span>的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及从<span class="markdown-them-math-inline">$V'$</span>指向<span class="markdown-them-math-inline">$t$</span>的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>发现这个割对应的点集<span class="markdown-them-math-inline">$V'=S- \{s\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果按照证明1中的方法寻找割<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仍得到这个割<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>一一对应关系建立完成后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>试图建立最小割与最大点权的关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对最小割<span class="markdown-them-math-inline">$[S,T]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记<span class="markdown-them-math-inline">$V'=S-\{s\},\overline{V'}=T-\{t\},V'$</span>中点权为正的点集为 <span class="markdown-them-math-inline">$V'_+$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>点权为负的点集为<span class="markdown-them-math-inline">$V'_-$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>类似地定义<span class="markdown-them-math-inline">$\overline{V_+'},\overline{V_-'}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>那么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最小割中的边权为<span class="markdown-them-math-inline">$w(\overline{V'_+})+w(V'_-)\left(w(V)=\sum\limits_{v\in V}{|w(v)|}\right)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而最大点权应为<span class="markdown-them-math-inline">$w(V'_+)-w(V'_-)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他们的和为<span class="markdown-them-math-inline">$w(\overline{V'_+})+w(V'_+)=w(V_+)$</span>不变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么取得最小割时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就会得到最大点权闭合图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>问题就解决了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>由于流的上限太高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><a href="Ford-Fulkerson%E7%AE%97%E6%B3%95/" title="Ford-Fulkerson算法">Ford-Fulkerson算法</a>会TLE<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要用<a href="Dinic%E7%AE%97%E6%B3%95/" title="Dinic算法">Dinic算法</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>最后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在残留网络上从源点<span class="markdown-them-math-inline">$s$</span>出发dfs一下就知道<span class="markdown-them-math-inline">$G'$</span>中的点数了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>挖个坑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要证明按照这种做法得到的一定是点数最少的子图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="ac代码">AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> from, to;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> w, f;</span><br><span class="line">    <span class="type">int</span> rev;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> i_from, <span class="type">int</span> i_to, <span class="type">long</span> <span class="type">long</span> i_w, <span class="type">int</span> i_rev) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;from = i_from;</span><br><span class="line">        <span class="keyword">this</span>-&gt;to = i_to;</span><br><span class="line">        <span class="keyword">this</span>-&gt;w = i_w;</span><br><span class="line">        <span class="keyword">this</span>-&gt;rev = i_rev;</span><br><span class="line">        <span class="keyword">this</span>-&gt;f = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; G[<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">long</span> <span class="type">long</span> w)</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">max_flow</span><span class="params">(<span class="type">int</span> pt, <span class="type">long</span> <span class="type">long</span> f)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> pt)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span> level[<span class="number">5005</span>];</span><br><span class="line"><span class="type">int</span> iter[<span class="number">5005</span>];</span><br><span class="line"><span class="type">int</span> n, m, w[<span class="number">5005</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sumw = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;w[i]);</span><br><span class="line">        <span class="keyword">if</span> (w[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">addedge</span>(<span class="number">0</span>, i, w[i]);</span><br><span class="line">            sumw += w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">addedge</span>(i, n + <span class="number">1</span>, -w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> father, son;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;father, &amp;son);</span><br><span class="line">        <span class="built_in">addedge</span>(father, son, sumw + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(level, <span class="number">-1</span>, <span class="built_in">sizeof</span>(level));</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">        <span class="keyword">if</span> (level[n + <span class="number">1</span>] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(iter, <span class="number">0</span>, <span class="built_in">sizeof</span>(iter));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> f = <span class="built_in">max_flow</span>(<span class="number">0</span>, sumw);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            maxf += f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="type">int</span> cnt = <span class="built_in">count</span>(<span class="number">0</span>) - <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (sumw - maxf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">long</span> <span class="type">long</span> w)</span> </span>&#123;</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(from, to, w, G[to].<span class="built_in">size</span>()));</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(to, from, <span class="number">0</span>, G[from].<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">max_flow</span><span class="params">(<span class="type">int</span> pt, <span class="type">long</span> <span class="type">long</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt == n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> curf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i = iter[pt]; i &lt; G[pt].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        edge &amp;v = G[pt][i];</span><br><span class="line">        <span class="keyword">if</span> (level[v.to] &lt;= level[pt] || v.w &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        curf = <span class="built_in">max_flow</span>(v.to, ((f &gt; v.w) ? v.w : f));</span><br><span class="line">        <span class="keyword">if</span> (curf &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            v.w -= curf;</span><br><span class="line">            v.f += curf;</span><br><span class="line">            G[v.to][v.rev].w += curf;</span><br><span class="line">            <span class="keyword">return</span> curf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    level[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (level[G[u][i].to] &gt;= <span class="number">0</span> || G[u][i].w &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            level[G[u][i].to] = level[u] + <span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(G[u][i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> pt)</span> </span>&#123;<span class="comment">//dfs</span></span><br><span class="line">    <span class="keyword">if</span>(vis[pt]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    vis[pt] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[pt].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[G[pt][i].to] || G[pt][i].w &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans += <span class="built_in">count</span>(G[pt][i].to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/Dinic%E7%AE%97%E6%B3%95/" rel="tag">Dinic算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/%E6%9C%80%E5%A4%A7%E7%82%B9%E6%9D%83%E9%97%AD%E5%90%88%E5%9B%BE/" rel="tag">最大点权闭合图</a></li></ul></footer></div></article><section id="isso-thread"><noscript>Javascript needs to be activated to view comments.</noscript></section><nav id="article-nav"><a href="../Ford-Fulkerson%E7%AE%97%E6%B3%95/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">Ford-Fulkerson算法</div></a><a href="../%E6%B5%8B%E8%AF%95%E8%AF%84%E8%AE%BA/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">测试评论</div></a></nav></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2024 Wilson Xia<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/bill-xia/hexo-theme-mashiro" target="_blank">Mashiro</a><br></div></div></footer></div><nav id="mobile-nav"><a href="../index.html" class="mobile-nav-link">Home</a> <a href="../archives/" class="mobile-nav-link">Archives</a> <a href="../paper_list/" class="mobile-nav-link">Paper List</a> <a href="../about/" class="mobile-nav-link">About</a></nav><script src="../js/clipboard.min.js"></script><script src="../js/jquery-1.4.3.min.js"></script><script src="../fancybox/jquery.fancybox-1.3.4.pack.js"></script><script src="../js/script.js"></script><script data-isso="https://isso.wilsonxia.cn" src="https://isso.wilsonxia.cn/js/embed.min.js"></script></div></body></html>