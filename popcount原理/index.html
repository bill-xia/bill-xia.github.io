<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>__builtin_popcount原理 | Wilson&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="小学期题用了这个函数，觉得十分高级，学习一个。
这个函数用来数二进制数中1的个数。正常的操作是：看unsigned int二进制表示下最右端是不是1；若是1，则计数器+1，再右移；重复32次。这样的操作需要进行32次int运算，效率不够高。这个问题可以二分解决。">
  
  
    <link rel="alternate" href="../atom.xml" title="Wilson's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="../favicon.ico">
  
  <link rel="stylesheet" href="../css/style.css">
  
    <link rel="stylesheet" href="../fancybox/jquery.fancybox-1.3.4.css">
  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="../index.html">Home</a>
    
      <a class="main-nav-link" href="../archives">Archives</a>
    
      <a class="main-nav-link" href="../about">About</a>
    
    <div class="main-nav-space-between"></div>
    
      <a id="nav-rss-link" class="nav-icon" href="../atom.xml" title="RSS 订阅"></a>
    
  </nav>
</div>
<div id="header-title">
  <h1 id="logo-wrap">
    <a href="../index.html" id="logo">Wilson&#39;s blog</a>
  </h1>
  
</div>

      <div id="content" class="outer">
        <section id="main"><article id="post-popcount原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="" class="article-date">
  <time class="dt-published" datetime="2020-06-30T04:47:39.000Z" itemprop="datePublished">2020-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/">奇技淫巧</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      __builtin_popcount原理
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>小学期题用了这个函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>觉得十分高级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>学习一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这个函数用来数二进制数中1的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>正常的操作是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>看<code>unsigned int</code>二进制表示下最右端是不是1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>若是1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则计数器+1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再右移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>重复32次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样的操作需要进行32次int运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>效率不够高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个问题可以二分解决<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<span id="more"></span>
<p>首先看一个结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对等长<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>含前导0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的二进制数<span class="markdown-them-math-inline">$a$</span>和<span class="markdown-them-math-inline">$b$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设他们长为<span class="markdown-them-math-inline">$k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并记将<span class="markdown-them-math-inline">$a$</span>接在<span class="markdown-them-math-inline">$b$</span>前面形成的<span class="markdown-them-math-inline">$2k$</span>位的二进制数为<span class="markdown-them-math-inline">$(a|b)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$a+b=(a|b)&gt;&gt;k+(a|b)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这是显而易见的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这个操作将直接的加法转换为了位运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当k较小时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以将多个k拼在一起放在int32中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时进行多个位运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样就有了提高加法效率的可能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>相当于多线程了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若k=1时将和用2位来存储<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再取k=2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再将和用4位存储<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再取k=4…然后就可以进行二分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在<span class="markdown-them-math-inline">$O(\log n)$</span>时间内求n个和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这是计算机的特性造就的性能提升<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>下面模拟一下这个过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>现在有一个int8数n=01011100b<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>首先<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对每一位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这一位本身的数字恰好记录了这一位上1的个数<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>这一位是1就有1个1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是0就有0个1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>接下来要将这些1加起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>首先取k=1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将n分为8位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后相邻两位相加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时每两位<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>指1-2,3-4这样的两位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>共同构成的二进制数表示这两位上1的和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>例如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>(0|1|0|1|1|1|0|0)相邻两位相加后应为(01|01|10|00)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个操作可以用刚刚的公式来进行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体来讲<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>两位一格分为4格<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每格里都是右移一位后相加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于位运算可以同时进行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么16格同时运算就应该是(n-偶数位-置0 + (n-奇数位-置0 &gt;&gt; 1))=((<font color="red">0</font>1|<font color="red">0</font>1|<font color="red">0</font>1|<font color="red">0</font>0)+(0<font color="red">0</font>|0<font color="red">0</font>|1<font color="red">0</font>|0<font color="red">0</font>)&gt;&gt;1)=(01|01|01|00)+(_0|00|01|00)=(01|01|10|00)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>奇<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>偶从右数起<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>此时每格里都完成了一次上述运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>接下来两位一份分为四份<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>相邻两份再次相加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即(01+01|10+00)=(0010|0010)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>为了求和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要构造<span class="markdown-them-math-inline">$2k$</span>位的格子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是四位一格分成2格<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为(0101|1000)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求和过程应为(<font color="red">00</font>|01|<font color="red">00</font>|00)+(01|<font color="red">00</font>|10|<font color="red">00</font>)&gt;&gt;2=(00|01|00|00)+(00|01|00|10)=(0010|0010)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>最后是0010+0010=(<font color="red">0000</font>|0010)+(0010|<font color="red">0000</font>)&gt;&gt;4=(0000|0010)+(0000|0010)=(0000|0100)=4<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为n中1的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>过程不再赘述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>唉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>语言表达能力差<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也不知道说清楚没<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>最后给出代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">popcount</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n)</span>
</span>&#123;
	n = (n &amp; <span class="hljs-number">0x55555555</span>) + ((n &gt;&gt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x55555555</span>);
	n = (n &amp; <span class="hljs-number">0x33333333</span>) + ((n &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x33333333</span>);
	n = (n &amp; <span class="hljs-number">0x0f0f0f0f</span>) + ((n &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0f0f0f0f</span>);
	n = (n &amp; <span class="hljs-number">0x00ff00ff</span>) + ((n &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0x00ff00ff</span>);
	n = (n &amp; <span class="hljs-number">0x0000ffff</span>) + ((n &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0x0000ffff</span>);
	<span class="hljs-keyword">return</span> n;
&#125;
</code></pre></div>
<p>gcc内置了这个函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>名字是__builtin_popcount<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当正常函数调用就行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即__builtin_popcount(n);<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="tag">位运算</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../day6E/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          day6E
        
      </div>
    </a>
  
  
    <a href="../CF630D2F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          CF630D2F
        
      </div>
    </a>
  
</nav>

  
</article>


</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        &copy; 2022 Wilson Xia<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a><br>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="../js/clipboard.min.js"></script>
<script src="../js/jquery-1.4.3.min.js"></script>

<script src="../fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="../js/script.js"></script>






<script>
  MathJax = {
    options: {
      enableMenu: false
    },
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
    }
  };
</script>
<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
    CommonHTML: {
      linebreaks: false
    }
  });
  </script> -->
<script type="text/javascript" id="MathJax-script" async
  src="../mathjax/tex-chtml.js">
</script>
<!-- <script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_CHTML">
</script> -->



  </div>
</body>
</html>