<!DOCTYPE html><html><head><meta charset="utf-8"><title>一些经典的系统idea | Wilson&#39;s blog</title><link rel="stylesheet" href="/css/fonts/Chinese-normal-normal.min.css"><link rel="stylesheet" href="/css/fonts/ChineseMono-normal-normal.min.css"><link rel="stylesheet" href="/css/fonts/Chinese-italic-normal.min.css"><link rel="stylesheet" href="/css/fonts/Chinese-normal-bold.min.css"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="类似于 CS61C 提出的体系结构经典 idea，我也想在这里总结一下我在学习/读论文过程中看到的可复用的 idea。很多文章就是对这些 idea 进行排列组合，用于实现 tradeoff 的一部分，实现整体的性能目标。"><link rel="alternate" href="../atom.xml" title="Wilson's blog" type="application/atom+xml"><link rel="shortcut icon" href="../favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css"><link rel="stylesheet" href="/katex/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><script defer src="/katex/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script><script defer src="/katex/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="container"><div id="wrap"><div id="nav-outer"><nav id="main-nav" class="outer"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="../index.html">Home</a> <a class="main-nav-link" href="../archives/">Archives</a> <a class="main-nav-link" href="../paper_list/">Paper List</a> <a class="main-nav-link" href="../about/">About</a><div class="main-nav-space-between"></div><a id="nav-rss-link" class="nav-icon" href="../atom.xml" title="RSS 订阅"></a></nav></div><div id="header-title"><h1 id="logo-wrap"><a href="../index.html" id="logo">Wilson&#39;s blog</a></h1></div><div id="content" class="outer"><section id="main"><article id="post-一些经典的系统idea" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="" class="article-date"><time class="dt-published" datetime="2023-08-02T07:32:37.000Z" itemprop="datePublished">2023-08-02</time></a><div class="article-category"><a class="article-category-link" href="../categories/research/">research</a></div></div><div class="article-inner"><header class="article-header"><h1 class="p-name article-title" itemprop="headline name">一些经典的系统idea</h1></header><div class="e-content article-entry" itemprop="articleBody"><p>类似于 CS61C 提出的体系结构经典 idea<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我也想在这里总结一下我在学习/读论文过程中看到的可复用的 idea<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>很多文章就是对这些 idea 进行排列组合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用于实现 tradeoff 的一部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实现整体的性能目标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><span id="more"></span><h2 id="分层以利用局部性">分层以利用局部性</h2><p>数据的访问存在局部性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>指令的局部性体现在循环和经常调用的函数上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数据的局部性体现在数组上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>存在局部性的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就可以用少量快速<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>昂贵的存储<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>上层<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>和大量慢速<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>廉价的存储<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>下层<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>进行组合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实现既快速又大量的存储<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里纯粹是讲利用局部性达到的提升<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假如上层(<span class="markdown-them-math-inline">$t_1$</span>)比下层(<span class="markdown-them-math-inline">$t_2$</span>)快20倍<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是直接访问上层内容命中率为95%<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么访问数据期望的时间是<span class="markdown-them-math-inline">$0.95t_1+0.05t_2=1.95t_1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>命中率更高时效果更好<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>内存层级系统是最经典的例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>寄存器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>L1i/L1d Cache, L2 Cache, L3 Cache, 内存<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>虽然机制有所不同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是可以加上硬盘<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>一层一层叠起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实现接近寄存器读写速度和硬盘容量的存储<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这中间还可以再添加层级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如固态硬盘的控制芯片一般会自带一些缓存块和一个缓存系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>类似的例子还有用于地址翻译的 TLB 会带有页表的 Cache<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>DPDK 的内存池会在每个核设置 Cache<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>操作系统会缓存文件系统的元信息/文件内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>存储敏感的应用程序<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如数据库<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>会自行建立对硬盘数据的缓存等等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>无论在硬件还是软件中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Cache 的思想都是十分常用的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="fast-path">Fast Path</h2><p>这是一种优化复杂逻辑的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>软件中经常出现这种情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>某部分的逻辑很复杂<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是如果加以一定的假设/理想条件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>逻辑就能得到大幅的简化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果这种假设经常能够被满足<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么就可以为满足这种假设的情况单独编写一个简单的分支<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就是 Fast Path<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而只在假设不满足的时候进入复杂分支<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>存在这种优化的信号通常是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>为了解决某个不经常出现的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>引入了某种新的数据结构/逻辑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而新逻辑的 overhead 非常高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>例如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>TCP 为了解决不经常出现的乱序包问题而引入了重排 buffer 这种数据结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是每收到一个包都需要在重排 buffer 中寻找它的位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就多了一份访问链表/红黑树的 overhead<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果不认真加以解决<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这份开销会在每次收到数据包时发生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>影响严重<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>解决的方案就是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对经常出现的情况<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>数据包顺序到来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>进行特殊的检查<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里就是存储一个待接收的序列号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发现序列号等于待接收的号时就直接放在重排buffer的开头<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>另一个例子来自 SRNIC(NSDI 23)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>RDMA 为了解决不经常出现的乱序问题而在硬件中引入了 bitmap 结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>重传队列结构和复杂的重传逻辑带来较高内存开销<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解决方案就是只在硬件实现顺序到来的部分逻辑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>监测到乱序时就通知软件进行处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以节约硬件资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于数据中心网络中乱序很少发生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对整体性能的影响很小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="批处理">批处理</h2><p>批处理通常用于将一些较高的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>重复的 overhead 均摊到多次操作中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>例如 mTCP 与 I/O 库的交互就是批处理式的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>网卡一次传递给 mTCP 多个数据包<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>mTCP 再生成一批事件传递给应用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>均摊了 mTCP 与 I/O 库交互的上下文切换等开销<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>I/O 库与网卡的交互也是批处理式的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>均摊了一些昂贵的 PCIe 操作开销<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>再例如 TCP delayed ACK 是希望 TCP 实现不要收到每个数据包都发送 ACK<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>平均每 2 个包发送一个 ACK 是推荐的量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个量的选取还考虑到了 ACK 承载的拥塞控制功能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果没有这方面考虑可以将发送频率设置得更低<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>TCP Nagle 是希望 TCP 不要发送过多的小数据包<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而是攒成更大的数据包进行发送<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>显存对不同区域内容的写入顺序要求并不严格<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此可以将需要写入显存的数据暂存起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再一起<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>成批<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>写入显存的硬件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以均摊与显存交互的开销<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这些都可以看做批处理思想的例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>批处理涉及到平均处理时间和响应时间的 tradeoff<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>批处理时平均处理时间比较短<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是最早到来的请求需要等待其他请求的到来才能被写入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以响应时间会变慢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果能取得平衡就能得到较好的效果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="抽象&lt;span-class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;、&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;生成与中间层">抽象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>生成与中间层</h2><p>编译器的诞生可以说是计算机发展史上的一次工业革命<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它将人们从手写汇编的繁重劳动中解放出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>开始用高级语言编程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里要说的概念都是从编译器中得到的启示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="抽象">抽象</h3><p>编译器的工作就是根据抽象而人类易懂的高级语言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>生成功能简单<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>易于执行的低级语言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>抽象从来没有增加程序员能做的事情<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>它只是对程序员进行了更多的限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但这种限制降低了程序员的心智模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一旦理解高级语言后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>高级语言编写的程序就<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>比低级语言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>更加易懂<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>高级语言可以针对其要表达的内容简化语法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从编译器和程序员共同认同的假定中推断信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>编程语言的例子不必再举<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>举一些其他抽象的例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ol><li>操作系统将对硬件的操作抽象为系统调用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里的低级语言相当于操作硬件的寄存器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>高级语言就是系统调用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>例如将对硬盘/网络的访问抽象为文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只允许程序员把它当成流来读取/写入<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>从编译器和程序员共同认同的假定中推断出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>按流操作的能力已经足够<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>简化了程序员对硬盘/网卡的操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>十分易懂<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时还实现了对硬件统一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>高效<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>安全的管理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>Rubik 是一个用于生成网络中间件的领域特定语言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将连接抽象为 id, sequence, 状态机和数据的集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只允许程序员操作这些数据结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>降低了心智开销<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样的数据结构设计<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及优化过程中用到的假设都从编译器和程序员共同认同的假定中推断出非常多的信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>极端一点的例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>导航系统的<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>起点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>终点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>语言就是一种抽象语言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>补充语法有选择交通工具<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>红灯少/价格便宜/时间短的偏好选择等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ol><h3 id="生成">生成</h3><p>从高级语言生成低级语言的过程是自动化的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>特别地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对代码的优化过程也可以自动化进行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这说明编写低级语言的过程中隐含了许多重复性的劳动<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它们被自动化后减少了程序员的心智负担<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且机器通常做得比程序员还要好<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="中间层">中间层</h3><p>在源语言和目标语言中间可以插入中间语言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将源语言先编译成中间语言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再编译成目标语言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>通常<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里的中间语言是对各种目标语言共性的提炼<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此语言前端只需编译到同一种中间语言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>中间语言再编译成各种目标语言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>前端的工作便无需针对多种目标语言重复进行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>减少了重复的工作量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>中间语言比源语言更加具体<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>更加接近机器执行的语义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此便于进行优化<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>这些几乎是照着 LLVM 说的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>此外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Rubik 也用到了中间语言进行优化<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>目标语言是 C 语言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>目前看来没有多目标语言的必要<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>DPDK 的 EAL<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>SQL Server 的 SQLPAL 用中间层的方式实现了跨操作系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Nginx 自己实现的事件处理层实现了多种系统调用<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>epoll/kqueue/IOCP<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>之上的事件处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p></div><footer class="article-footer"><section id="isso-thread"><noscript>Javascript needs to be activated to view comments.</noscript></section></footer></div><nav id="article-nav"><a href="../6-824-Lab2B-Raft/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">6.824 Lab2B Raft</div></a></nav></article></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2024 Wilson Xia<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/bill-xia/hexo-theme-mashiro" target="_blank">Mashiro</a><br></div></div></footer></div><nav id="mobile-nav"><a href="../index.html" class="mobile-nav-link">Home</a> <a href="../archives/" class="mobile-nav-link">Archives</a> <a href="../paper_list/" class="mobile-nav-link">Paper List</a> <a href="../about/" class="mobile-nav-link">About</a></nav><script src="../js/clipboard.min.js"></script><script src="../js/jquery-1.4.3.min.js"></script><script src="../fancybox/jquery.fancybox-1.3.4.pack.js"></script><script src="../js/script.js"></script><script data-isso="https://isso.wilsonxia.cn" src="https://isso.wilsonxia.cn/js/embed.min.js"></script></div></body></html>