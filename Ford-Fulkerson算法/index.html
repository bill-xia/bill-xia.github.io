<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Ford-Fulkerson算法 | Wilson&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="本文讲解Ford-Fulkerson算法的思路，算法本身与证明，最后会给出模板。Ford-Fulkerson算法是增广路算法的一种，用于求解最大流问题，不明背景请看网络流这篇文章。
分析
朴素算法
朴素的想法（的一种）是这样的：在图中DFS，一旦找到一条从s指向t并且可以在这条路径上添加流量（即：每">
  
  
    <link rel="alternate" href="../atom.xml" title="Wilson's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="../favicon.ico">
  
  <link rel="stylesheet" href="../css/style.css">
  
    <link rel="stylesheet" href="../fancybox/jquery.fancybox-1.3.4.css">
  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="../index.html">Home</a>
    
      <a class="main-nav-link" href="../archives">Archives</a>
    
      <a class="main-nav-link" href="../about">About</a>
    
    <div class="main-nav-space-between"></div>
    
      <a id="nav-rss-link" class="nav-icon" href="../atom.xml" title="RSS 订阅"></a>
    
  </nav>
</div>
<div id="header-title">
  <h1 id="logo-wrap">
    <a href="../index.html" id="logo">Wilson&#39;s blog</a>
  </h1>
  
</div>

      <div id="content" class="outer">
        <section id="main"><article id="post-Ford-Fulkerson算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="" class="article-date">
  <time class="dt-published" datetime="2020-04-24T03:28:02.000Z" itemprop="datePublished">2020-04-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Ford-Fulkerson算法
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文讲解Ford-Fulkerson算法的思路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>算法本身与证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后会给出模板<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>Ford-Fulkerson算法是增广路算法的一种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用于求解最大流问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不明背景请看<a href="/%E7%BD%91%E7%BB%9C%E6%B5%81">网络流</a>这篇文章<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="分析">分析</h2>
<h3 id="朴素算法">朴素算法</h3>
<p>朴素的想法<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>的一种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>是这样的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在图中DFS<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一旦找到一条从s指向t并且可以在这条路径上添加流量<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>每条边<span class="markdown-them-math-inline">$e$</span>都满足<span class="markdown-them-math-inline">$f_e&lt;w_e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么就在这条路径的所有边上同时不断添加流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到无法再添加<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>即<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>某条边<span class="markdown-them-math-inline">$e$</span>上<span class="markdown-them-math-inline">$f_e=w_e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>直到无法再找到任何这样的路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即得到最大流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如下图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="https://s1.ax1x.com/2020/07/18/Ug5n0I.png" alt="朴素想法求最大流"></p>
<p>上面的图中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>黑色为边的容量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>红色为边的容量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>图1为原来的网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中1为源点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>6为汇点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>图二为DFS时<strong>可能</strong>得到的一个图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以看到上面的算法在这里就会停止<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而图三是该网络的最大流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以轻松地验证这一点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为从1出发的边都已经满流了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无法再增加新的流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>注意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>DFS<strong>可能</strong>得到最优解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但不是一定得到最优解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>所以上述的算法是错误的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是它错在哪里呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>
<h3 id="改进">改进</h3>
<p>观察图3<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个流比图2多的流如图4<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="https://s1.ax1x.com/2020/07/18/Ug5lh8.png" alt="朴素想法与最大流之差"></p>
<p>从图4看<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它是把图2中<span class="markdown-them-math-inline">$2\rightarrow4$</span>已有的流量1<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>推了回去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>而产生的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这也正是增广路算法的核心所在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这看起来不可理喻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>原图中没有的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为什么凭空造出来一条就正确呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>
<h3 id="解释">解释</h3>
<p>仔细观察图2和图3<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就会发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$4\rightarrow6$</span>的边流量没变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仍然是1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$2\rightarrow4$</span>的流量没有了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那最大流中谁为4提供那一个流量呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>显然是<span class="markdown-them-math-inline">$1\rightarrow3\rightarrow4$</span>的路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>同理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$1\rightarrow2$</span>的流量也没有变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它从<span class="markdown-them-math-inline">$2\rightarrow5\rightarrow6$</span>的路径流出去了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这就可以想象成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>节点4不知道是谁给他的流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是在这个过程中4的上游的信息被屏蔽了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时2的下游的信息也被屏蔽了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只要有人能为4提供流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他就什么都不知道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>同样的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只要有人能从2运走流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他也什么都不知道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在新的流中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>原本只有一份的流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$1\rightarrow3\rightarrow 4$</span>流走了一份<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$1\rightarrow2\rightarrow5$</span>又流走了一份<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以流量+1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>所以<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\langle u,v\rangle$</span>的反向边<span class="markdown-them-math-inline">$\langle v,u\rangle$</span>的意义就是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在<span class="markdown-them-math-inline">$\langle u,v\rangle$</span>有流<span class="markdown-them-math-inline">$f$</span>的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果有一个路径可以从<span class="markdown-them-math-inline">$v$</span>流入<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>称其前面的那段路经为上游<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>再从<span class="markdown-them-math-inline">$u$</span>流出<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>称其后的那段路径为下游<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>且流为<span class="markdown-them-math-inline">$f_0\le f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么就可以认为上游为<span class="markdown-them-math-inline">$v$</span>提供原来的一部分流<span class="markdown-them-math-inline">$f_0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而从<span class="markdown-them-math-inline">$u$</span>流入的那些<span class="markdown-them-math-inline">$f_0$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>改道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>从下游流出了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>上面的做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以算作对朴素DFS做法的一个修正<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大概可以理解为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>避免了因DFS顺序不确定而导致的错误<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>于是对一个流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以对图上所有有流<span class="markdown-them-math-inline">$f$</span>的边<span class="markdown-them-math-inline">$\langle u,v\rangle$</span>建立反向边<span class="markdown-them-math-inline">$\langle v,u\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其容量为<span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样得到的新的图称为<strong>残余网络</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>残余网络上从<span class="markdown-them-math-inline">$s$</span>到<span class="markdown-them-math-inline">$t$</span>的路径叫做<strong>增广路</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在<strong>残余网络</strong>上进行<strong>dfs</strong>沿着<strong>增广路</strong>来添加流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就是Ford-Fulkerson算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="算法描述">算法描述</h2>
<p>对网络上的每个流<span class="markdown-them-math-inline">$G(V,E)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义与之对应的<strong>残余网络</strong><span class="markdown-them-math-inline">$G'(V,E')$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>若<span class="markdown-them-math-inline">$f_e&gt;0(e=\langle u,v\rangle\in E)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$e\in E'$</span>且<span class="markdown-them-math-inline">$rev(e)=\langle v,u\rangle\in E'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且<span class="markdown-them-math-inline">$w_{rev(e)}=f_e,f_{rev(e)}=0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$E'$</span>中的元素只有刚才描述的那些<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>那么算法可以描述为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<blockquote>
<p>Ford-Fulkerson算法</p>
<p>输入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>网络<span class="markdown-them-math-inline">$G$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>一个图<span class="markdown-them-math-inline">$G(V,E)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$E$</span>中的边<span class="markdown-them-math-inline">$e$</span>有权重<span class="markdown-them-math-inline">$w_e\in\mathbb{N_+}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$max\_flow=0$</span></p>
<p>输出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>该网络上的最大流的流量<span class="markdown-them-math-inline">$f$</span></p>
<p>步骤0. [建立反向边]定义<span class="markdown-them-math-inline">$max\_flow\gets0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用邻接表G[V]存储网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>对<span class="markdown-them-math-inline">$E$</span>中的每条边<span class="markdown-them-math-inline">$e=\langle u,v\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>作其反向边<span class="markdown-them-math-inline">$e'=\langle v,u\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并置<span class="markdown-them-math-inline">$w_{e'}\gets0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>步骤1. [寻找增广路]在<span class="markdown-them-math-inline">$G$</span>上DFS<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>寻找从<span class="markdown-them-math-inline">$s$</span>到<span class="markdown-them-math-inline">$t$</span>的简单路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要求该路径上每条边可用权值<span class="markdown-them-math-inline">$(w_e-f_e)$</span>大于0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若找到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记该路径上的权值最小的边权值为<span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则<span class="markdown-them-math-inline">$f\gets0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>步骤2. [找到了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新残余网络]如果<span class="markdown-them-math-inline">$f&gt;0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置<span class="markdown-them-math-inline">$max\_flow\gets max\_flow+f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对路径上的每条边<span class="markdown-them-math-inline">$e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置<span class="markdown-them-math-inline">$f_e\gets f_e+f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记其反向边为<span class="markdown-them-math-inline">$e'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置<span class="markdown-them-math-inline">$w_{e'}\gets w_{e'}+f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>返回1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>步骤3. [没有找到]如果<span class="markdown-them-math-inline">$f=0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>输出<span class="markdown-them-math-inline">$max\_flow$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>算法结束<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>最大流不会超过从<span class="markdown-them-math-inline">$s$</span>出发的所有边的边权和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而该算法中每次进入步骤1后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$f$</span>总是正整数<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>也有<span class="markdown-them-math-inline">$f=0$</span>的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时算法结束<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以该算法对整数总是有限的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若记最大流流量上界为<span class="markdown-them-math-inline">$F$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则该算法最多进入步骤1<span class="markdown-them-math-inline">$(F+1)$</span>次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而每次进入步骤1需要<span class="markdown-them-math-inline">$O(|E|)$</span>的复杂度进行搜索<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>所以总的时间复杂度是<span class="markdown-them-math-inline">$O(F|E|)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但这个复杂度上界是很松的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实际用起来效率比较高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以有时即使估计复杂度偏高也可以使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对<span class="markdown-them-math-inline">$F$</span>较小的情况则可以轻松应对<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="证明">证明</h2>
<p>在Ford-Fulkerson算法结束后的残余网络上没有<span class="markdown-them-math-inline">$s\rightarrow t$</span>路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>残余网络上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>从<span class="markdown-them-math-inline">$s$</span>可达的所有点构成的集合<span class="markdown-them-math-inline">$S$</span>不包含<span class="markdown-them-math-inline">$t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记<span class="markdown-them-math-inline">$T=V-S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$T$</span>不空<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且<span class="markdown-them-math-inline">$T\cap S=\varnothing$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>结论1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>从<span class="markdown-them-math-inline">$S$</span>指向<span class="markdown-them-math-inline">$T$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>满足<span class="markdown-them-math-inline">$u\in S,v\in T$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的边<span class="markdown-them-math-inline">$e=\langle u, v\rangle$</span>都应当满流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即<span class="markdown-them-math-inline">$w_e=f_e$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>否则<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于从<span class="markdown-them-math-inline">$s$</span>可达<span class="markdown-them-math-inline">$u$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$s$</span>也可以从<span class="markdown-them-math-inline">$s\rightarrow u\rightarrow v$</span>到达<span class="markdown-them-math-inline">$v$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么<span class="markdown-them-math-inline">$v\in S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>矛盾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>结论2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>从<span class="markdown-them-math-inline">$T$</span>指向<span class="markdown-them-math-inline">$S$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>满足<span class="markdown-them-math-inline">$u\in T,v\in S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的边<span class="markdown-them-math-inline">$e=\langle u,v\rangle$</span>流量必为0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>否则<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$s$</span>可由其反向边到达<span class="markdown-them-math-inline">$u$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>即<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>流入<span class="markdown-them-math-inline">$S$</span>的流量为0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>反向边就是在这里用到的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p>对于任意一个流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$S-\{s\}$</span>中的点流入的流量都等于流出的流量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么流入<span class="markdown-them-math-inline">$S-\{s\}$</span>的流量<span class="markdown-them-math-inline">$f_{in}$</span>等于从<span class="markdown-them-math-inline">$S$</span>流向<span class="markdown-them-math-inline">$T$</span>的所有边的流量和<span class="markdown-them-math-inline">$S_f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个和不超过从<span class="markdown-them-math-inline">$S$</span>流向<span class="markdown-them-math-inline">$T$</span>的所有边的容量和<span class="markdown-them-math-inline">$S_w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>写在一起就是<span class="markdown-them-math-inline">$f_{in}=S_f\le S_w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>从而从<span class="markdown-them-math-inline">$s$</span>流出的流量<span class="markdown-them-math-inline">$f_s$</span>一定不超过<span class="markdown-them-math-inline">$S_w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为<span class="markdown-them-math-inline">$f_s$</span>应当是<span class="markdown-them-math-inline">$f_{in}$</span>的一部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>即<span class="markdown-them-math-inline">$f_{s}\le S_w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是对任意流的结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>而对于残余网络<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>注意残余网络也是一个流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由结论1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$S_f=S_w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>又由结论2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$f_s$</span>即为<span class="markdown-them-math-inline">$f_{in}$</span>的全部<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以有<span class="markdown-them-math-inline">$f_s=f_{in}=S_w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以<span class="markdown-them-math-inline">$f_s$</span>为所有流中的最大者<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>也可以用反证法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若存在比Ford-Fulkerson算法得到的流更大的流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>仍然观察上面的点集<span class="markdown-them-math-inline">$S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时从<span class="markdown-them-math-inline">$s$</span>流出的流量<span class="markdown-them-math-inline">$f_{s'}$</span>应当超过了<span class="markdown-them-math-inline">$f_x=S_w$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这时<span class="markdown-them-math-inline">$S-\{s\}$</span>中的点不可能满足<em>流入每个顶点的流量等于流出的流量</em><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以这样的流不存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>至此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就证明了Ford-Fulkerson算法的正确性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="模板">模板</h2>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> V 5005 <span class="hljs-comment">//V为顶点最大个数&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;视数据范围而定</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x7fffffffffffffff</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span>
    ll to, w, rev;
&#125;;
vector&lt;edge&gt; G[V];
<span class="hljs-keyword">int</span> s, t;<span class="hljs-comment">//源点和汇点&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;是全局变量</span>
<span class="hljs-keyword">bool</span> vis[V];

<span class="hljs-function">ll <span class="hljs-title">max_flow</span><span class="hljs-params">()</span></span>;
<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(ll u, ll f)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(ll from, ll to, ll w)</span></span>;

<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(ll u, ll f)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    vis[u] = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span>(u == t) <span class="hljs-keyword">return</span> f;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G[u].<span class="hljs-built_in">size</span>(); i++) &#123;
        edge &amp;e = G[u][i];<span class="hljs-comment">//注意是引用&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;需要直接修改原图</span>
        <span class="hljs-keyword">if</span>(!vis[e.to] &amp;&amp; e.w &gt; <span class="hljs-number">0</span>) &#123;
            ll curf = <span class="hljs-built_in">dfs</span>(e.to, (f &gt; e.w) ? e.w : f);
            <span class="hljs-comment">//min函数有些编译器不给过</span>
            <span class="hljs-keyword">if</span>(curf &gt; <span class="hljs-number">0</span>) &#123;
                e.w -= curf;
                <span class="hljs-comment">//直接修改容量而非同时记录f和w&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;，&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;只是为了方便</span>
                G[e.to][e.rev].w += curf;
                <span class="hljs-keyword">return</span> curf;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
<span class="hljs-function">ll <span class="hljs-title">max_flow</span><span class="hljs-params">()</span> </span>&#123;
    ll maxf = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;
        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));
        ll f = <span class="hljs-built_in">dfs</span>(s, INF);
        <span class="hljs-keyword">if</span>(f == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
        maxf += f;
    &#125;
    <span class="hljs-keyword">return</span> maxf;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(ll from, ll to, ll w)</span> </span>&#123;
    G[from].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(to, G[to].<span class="hljs-built_in">size</span>(), w));
    G[to].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(from, G[from].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));
&#125;
</code></pre></div>
<p>如有发现模板的错误请联系我指正<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我将不胜感激<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/Ford-Fulkerson%E7%AE%97%E6%B3%95/" rel="tag">Ford-Fulkerson算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../tags/%E6%9C%80%E5%A4%A7%E6%B5%81-%E6%9C%80%E5%B0%8F%E5%89%B2/" rel="tag">最大流&#x2F;最小割</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../%E7%BD%91%E7%BB%9C%E6%B5%81/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          网络流
        
      </div>
    </a>
  
  
    <a href="../POJ2987-firing/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          POJ2987-Firing
        
      </div>
    </a>
  
</nav>

  
</article>


</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        &copy; 2022 Wilson Xia<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a><br>
<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">陕ICP备2021014297号</a>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="../js/clipboard.min.js"></script>
<script src="../js/jquery-1.4.3.min.js"></script>

<script src="../fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="../js/script.js"></script>






<script>
  MathJax = {
    options: {
      enableMenu: false
    },
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
    }
  };
</script>
<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
    CommonHTML: {
      linebreaks: false
    }
  });
  </script> -->
<script type="text/javascript" id="MathJax-script" async
  src="../mathjax/tex-chtml.js">
</script>
<!-- <script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_CHTML">
</script> -->



  </div>
</body>
</html>